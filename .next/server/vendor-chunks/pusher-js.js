"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pusher-js";
exports.ids = ["vendor-chunks/pusher-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/pusher-js/dist/node/pusher.js":
/*!****************************************************!*\
  !*** ./node_modules/pusher-js/dist/node/pusher.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Pusher JavaScript Library v8.4.0-rc2\n * https://pusher.com/\n *\n * Copyright 2020, Pusher\n * Released under the MIT licence.\n */ \nmodule.exports = /******/ function(modules) {\n    /******/ // The module cache\n    /******/ var installedModules = {};\n    /******/ /******/ // The require function\n    /******/ function __nested_webpack_require_327__(moduleId) {\n        /******/ /******/ // Check if module is in cache\n        /******/ if (installedModules[moduleId]) {\n            /******/ return installedModules[moduleId].exports;\n        /******/ }\n        /******/ // Create a new module (and put it into the cache)\n        /******/ var module1 = installedModules[moduleId] = {\n            /******/ i: moduleId,\n            /******/ l: false,\n            /******/ exports: {}\n        };\n        /******/ /******/ // Execute the module function\n        /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_327__);\n        /******/ /******/ // Flag the module as loaded\n        /******/ module1.l = true;\n        /******/ /******/ // Return the exports of the module\n        /******/ return module1.exports;\n    /******/ }\n    /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n    /******/ __nested_webpack_require_327__.m = modules;\n    /******/ /******/ // expose the module cache\n    /******/ __nested_webpack_require_327__.c = installedModules;\n    /******/ /******/ // define getter function for harmony exports\n    /******/ __nested_webpack_require_327__.d = function(exports, name, getter) {\n        /******/ if (!__nested_webpack_require_327__.o(exports, name)) {\n            /******/ Object.defineProperty(exports, name, {\n                enumerable: true,\n                get: getter\n            });\n        /******/ }\n    /******/ };\n    /******/ /******/ // define __esModule on exports\n    /******/ __nested_webpack_require_327__.r = function(exports) {\n        /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n            /******/ Object.defineProperty(exports, Symbol.toStringTag, {\n                value: \"Module\"\n            });\n        /******/ }\n        /******/ Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n    /******/ };\n    /******/ /******/ // create a fake namespace object\n    /******/ // mode & 1: value is a module id, require it\n    /******/ // mode & 2: merge all properties of value into the ns\n    /******/ // mode & 4: return value when already ns object\n    /******/ // mode & 8|1: behave like require\n    /******/ __nested_webpack_require_327__.t = function(value, mode) {\n        /******/ if (mode & 1) value = __nested_webpack_require_327__(value);\n        /******/ if (mode & 8) return value;\n        /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n        /******/ var ns = Object.create(null);\n        /******/ __nested_webpack_require_327__.r(ns);\n        /******/ Object.defineProperty(ns, \"default\", {\n            enumerable: true,\n            value: value\n        });\n        /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_327__.d(ns, key, (function(key) {\n            return value[key];\n        }).bind(null, key));\n        /******/ return ns;\n    /******/ };\n    /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n    /******/ __nested_webpack_require_327__.n = function(module1) {\n        /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n            return module1[\"default\"];\n        } : /******/ function getModuleExports() {\n            return module1;\n        };\n        /******/ __nested_webpack_require_327__.d(getter, \"a\", getter);\n        /******/ return getter;\n    /******/ };\n    /******/ /******/ // Object.prototype.hasOwnProperty.call\n    /******/ __nested_webpack_require_327__.o = function(object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n    };\n    /******/ /******/ // __webpack_public_path__\n    /******/ __nested_webpack_require_327__.p = \"\";\n    /******/ /******/ /******/ // Load entry module and return exports\n    /******/ return __nested_webpack_require_327__(__nested_webpack_require_327__.s = 21);\n/******/ }([\n    /* 0 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! util */ \"util\");\n    /***/ },\n    /* 1 */ /***/ function(module1, exports, __nested_webpack_require_4314__) {\n        /* eslint-disable node/no-deprecated-api */ var buffer = __nested_webpack_require_4314__(22);\n        var Buffer1 = buffer.Buffer;\n        // alternative to using Object.keys for old browsers\n        function copyProps(src, dst) {\n            for(var key in src){\n                dst[key] = src[key];\n            }\n        }\n        if (Buffer1.from && Buffer1.alloc && Buffer1.allocUnsafe && Buffer1.allocUnsafeSlow) {\n            module1.exports = buffer;\n        } else {\n            // Copy properties from require('buffer')\n            copyProps(buffer, exports);\n            exports.Buffer = SafeBuffer;\n        }\n        function SafeBuffer(arg, encodingOrOffset, length) {\n            return Buffer1(arg, encodingOrOffset, length);\n        }\n        // Copy static methods from Buffer\n        copyProps(Buffer1, SafeBuffer);\n        SafeBuffer.from = function(arg, encodingOrOffset, length) {\n            if (typeof arg === \"number\") {\n                throw new TypeError(\"Argument must not be a number\");\n            }\n            return Buffer1(arg, encodingOrOffset, length);\n        };\n        SafeBuffer.alloc = function(size, fill, encoding) {\n            if (typeof size !== \"number\") {\n                throw new TypeError(\"Argument must be a number\");\n            }\n            var buf = Buffer1(size);\n            if (fill !== undefined) {\n                if (typeof encoding === \"string\") {\n                    buf.fill(fill, encoding);\n                } else {\n                    buf.fill(fill);\n                }\n            } else {\n                buf.fill(0);\n            }\n            return buf;\n        };\n        SafeBuffer.allocUnsafe = function(size) {\n            if (typeof size !== \"number\") {\n                throw new TypeError(\"Argument must be a number\");\n            }\n            return Buffer1(size);\n        };\n        SafeBuffer.allocUnsafeSlow = function(size) {\n            if (typeof size !== \"number\") {\n                throw new TypeError(\"Argument must be a number\");\n            }\n            return buffer.SlowBuffer(size);\n        };\n    /***/ },\n    /* 2 */ /***/ function(module1, exports, __nested_webpack_require_6476__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_6476__(1).Buffer, Emitter = __nested_webpack_require_6476__(23).EventEmitter, util = __nested_webpack_require_6476__(0), streams = __nested_webpack_require_6476__(24), Headers = __nested_webpack_require_6476__(9), Reader = __nested_webpack_require_6476__(25);\n        var Base = function(request, url, options) {\n            Emitter.call(this);\n            Base.validateOptions(options || {}, [\n                \"maxLength\",\n                \"masking\",\n                \"requireMasking\",\n                \"protocols\"\n            ]);\n            this._request = request;\n            this._reader = new Reader();\n            this._options = options || {};\n            this._maxLength = this._options.maxLength || this.MAX_LENGTH;\n            this._headers = new Headers();\n            this.__queue = [];\n            this.readyState = 0;\n            this.url = url;\n            this.io = new streams.IO(this);\n            this.messages = new streams.Messages(this);\n            this._bindEventListeners();\n        };\n        util.inherits(Base, Emitter);\n        Base.isWebSocket = function(request) {\n            var connection = request.headers.connection || \"\", upgrade = request.headers.upgrade || \"\";\n            return request.method === \"GET\" && connection.toLowerCase().split(/ *, */).indexOf(\"upgrade\") >= 0 && upgrade.toLowerCase() === \"websocket\";\n        };\n        Base.validateOptions = function(options, validKeys) {\n            for(var key in options){\n                if (validKeys.indexOf(key) < 0) throw new Error(\"Unrecognized option: \" + key);\n            }\n        };\n        var instance = {\n            // This is 64MB, small enough for an average VPS to handle without\n            // crashing from process out of memory\n            MAX_LENGTH: 0x3ffffff,\n            STATES: [\n                \"connecting\",\n                \"open\",\n                \"closing\",\n                \"closed\"\n            ],\n            _bindEventListeners: function() {\n                var self1 = this;\n                // Protocol errors are informational and do not have to be handled\n                this.messages.on(\"error\", function() {});\n                this.on(\"message\", function(event) {\n                    var messages = self1.messages;\n                    if (messages.readable) messages.emit(\"data\", event.data);\n                });\n                this.on(\"error\", function(error) {\n                    var messages = self1.messages;\n                    if (messages.readable) messages.emit(\"error\", error);\n                });\n                this.on(\"close\", function() {\n                    var messages = self1.messages;\n                    if (!messages.readable) return;\n                    messages.readable = messages.writable = false;\n                    messages.emit(\"end\");\n                });\n            },\n            getState: function() {\n                return this.STATES[this.readyState] || null;\n            },\n            addExtension: function(extension) {\n                return false;\n            },\n            setHeader: function(name, value) {\n                if (this.readyState > 0) return false;\n                this._headers.set(name, value);\n                return true;\n            },\n            start: function() {\n                if (this.readyState !== 0) return false;\n                if (!Base.isWebSocket(this._request)) return this._failHandshake(new Error(\"Not a WebSocket request\"));\n                var response;\n                try {\n                    response = this._handshakeResponse();\n                } catch (error) {\n                    return this._failHandshake(error);\n                }\n                this._write(response);\n                if (this._stage !== -1) this._open();\n                return true;\n            },\n            _failHandshake: function(error) {\n                var headers = new Headers();\n                headers.set(\"Content-Type\", \"text/plain\");\n                headers.set(\"Content-Length\", Buffer1.byteLength(error.message, \"utf8\"));\n                headers = [\n                    \"HTTP/1.1 400 Bad Request\",\n                    headers.toString(),\n                    error.message\n                ];\n                this._write(Buffer1.from(headers.join(\"\\r\\n\"), \"utf8\"));\n                this._fail(\"protocol_error\", error.message);\n                return false;\n            },\n            text: function(message) {\n                return this.frame(message);\n            },\n            binary: function(message) {\n                return false;\n            },\n            ping: function() {\n                return false;\n            },\n            pong: function() {\n                return false;\n            },\n            close: function(reason, code) {\n                if (this.readyState !== 1) return false;\n                this.readyState = 3;\n                this.emit(\"close\", new Base.CloseEvent(null, null));\n                return true;\n            },\n            _open: function() {\n                this.readyState = 1;\n                this.__queue.forEach(function(args) {\n                    this.frame.apply(this, args);\n                }, this);\n                this.__queue = [];\n                this.emit(\"open\", new Base.OpenEvent());\n            },\n            _queue: function(message) {\n                this.__queue.push(message);\n                return true;\n            },\n            _write: function(chunk) {\n                var io = this.io;\n                if (io.readable) io.emit(\"data\", chunk);\n            },\n            _fail: function(type, message) {\n                this.readyState = 2;\n                this.emit(\"error\", new Error(message));\n                this.close();\n            }\n        };\n        for(var key in instance)Base.prototype[key] = instance[key];\n        Base.ConnectEvent = function() {};\n        Base.OpenEvent = function() {};\n        Base.CloseEvent = function(code, reason) {\n            this.code = code;\n            this.reason = reason;\n        };\n        Base.MessageEvent = function(data) {\n            this.data = data;\n        };\n        Base.PingEvent = function(data) {\n            this.data = data;\n        };\n        Base.PongEvent = function(data) {\n            this.data = data;\n        };\n        module1.exports = Base;\n    /***/ },\n    /* 3 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! crypto */ \"crypto\");\n    /***/ },\n    /* 4 */ /***/ function(module1, exports, __nested_webpack_require_12954__) {\n        \"use strict\";\n        // Protocol references:\n        //\n        // * http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-75\n        // * http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76\n        // * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17\n        var Base = __nested_webpack_require_12954__(2), Client = __nested_webpack_require_12954__(26), Server = __nested_webpack_require_12954__(37);\n        var Driver = {\n            client: function(url, options) {\n                options = options || {};\n                if (options.masking === undefined) options.masking = true;\n                return new Client(url, options);\n            },\n            server: function(options) {\n                options = options || {};\n                if (options.requireMasking === undefined) options.requireMasking = true;\n                return new Server(options);\n            },\n            http: function() {\n                return Server.http.apply(Server, arguments);\n            },\n            isSecureRequest: function(request) {\n                return Server.isSecureRequest(request);\n            },\n            isWebSocket: function(request) {\n                return Base.isWebSocket(request);\n            },\n            validateOptions: function(options, validKeys) {\n                Base.validateOptions(options, validKeys);\n            }\n        };\n        module1.exports = Driver;\n    /***/ },\n    /* 5 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! stream */ \"stream\");\n    /***/ },\n    /* 6 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! url */ \"url\");\n    /***/ },\n    /* 7 */ /***/ function(module1, exports, __webpack_require__) {\n        \"use strict\";\n        var Event = function(eventType, options) {\n            this.type = eventType;\n            for(var key in options)this[key] = options[key];\n        };\n        Event.prototype.initEvent = function(eventType, canBubble, cancelable) {\n            this.type = eventType;\n            this.bubbles = canBubble;\n            this.cancelable = cancelable;\n        };\n        Event.prototype.stopPropagation = function() {};\n        Event.prototype.preventDefault = function() {};\n        Event.CAPTURING_PHASE = 1;\n        Event.AT_TARGET = 2;\n        Event.BUBBLING_PHASE = 3;\n        module1.exports = Event;\n    /***/ },\n    /* 8 */ /***/ function(module1, exports, __webpack_require__) {\n        \"use strict\";\n        // Copyright (C) 2016 Dmitry Chestnykh\n        // MIT License. See LICENSE file for details.\n        var __extends = this && this.__extends || function() {\n            var extendStatics = function(d, b) {\n                extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return extendStatics(d, b);\n            };\n            return function(d, b) {\n                extendStatics(d, b);\n                function __() {\n                    this.constructor = d;\n                }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        }();\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        /**\n * Package base64 implements Base64 encoding and decoding.\n */ // Invalid character used in decoding to indicate\n        // that the character to decode is out of range of\n        // alphabet and cannot be decoded.\n        var INVALID_BYTE = 256;\n        /**\n * Implements standard Base64 encoding.\n *\n * Operates in constant time.\n */ var Coder = /** @class */ function() {\n            // TODO(dchest): methods to encode chunk-by-chunk.\n            function Coder(_paddingCharacter) {\n                if (_paddingCharacter === void 0) {\n                    _paddingCharacter = \"=\";\n                }\n                this._paddingCharacter = _paddingCharacter;\n            }\n            Coder.prototype.encodedLength = function(length) {\n                if (!this._paddingCharacter) {\n                    return (length * 8 + 5) / 6 | 0;\n                }\n                return (length + 2) / 3 * 4 | 0;\n            };\n            Coder.prototype.encode = function(data) {\n                var out = \"\";\n                var i = 0;\n                for(; i < data.length - 2; i += 3){\n                    var c = data[i] << 16 | data[i + 1] << 8 | data[i + 2];\n                    out += this._encodeByte(c >>> 3 * 6 & 63);\n                    out += this._encodeByte(c >>> 2 * 6 & 63);\n                    out += this._encodeByte(c >>> 1 * 6 & 63);\n                    out += this._encodeByte(c >>> 0 * 6 & 63);\n                }\n                var left = data.length - i;\n                if (left > 0) {\n                    var c = data[i] << 16 | (left === 2 ? data[i + 1] << 8 : 0);\n                    out += this._encodeByte(c >>> 3 * 6 & 63);\n                    out += this._encodeByte(c >>> 2 * 6 & 63);\n                    if (left === 2) {\n                        out += this._encodeByte(c >>> 1 * 6 & 63);\n                    } else {\n                        out += this._paddingCharacter || \"\";\n                    }\n                    out += this._paddingCharacter || \"\";\n                }\n                return out;\n            };\n            Coder.prototype.maxDecodedLength = function(length) {\n                if (!this._paddingCharacter) {\n                    return (length * 6 + 7) / 8 | 0;\n                }\n                return length / 4 * 3 | 0;\n            };\n            Coder.prototype.decodedLength = function(s) {\n                return this.maxDecodedLength(s.length - this._getPaddingLength(s));\n            };\n            Coder.prototype.decode = function(s) {\n                if (s.length === 0) {\n                    return new Uint8Array(0);\n                }\n                var paddingLength = this._getPaddingLength(s);\n                var length = s.length - paddingLength;\n                var out = new Uint8Array(this.maxDecodedLength(length));\n                var op = 0;\n                var i = 0;\n                var haveBad = 0;\n                var v0 = 0, v1 = 0, v2 = 0, v3 = 0;\n                for(; i < length - 4; i += 4){\n                    v0 = this._decodeChar(s.charCodeAt(i + 0));\n                    v1 = this._decodeChar(s.charCodeAt(i + 1));\n                    v2 = this._decodeChar(s.charCodeAt(i + 2));\n                    v3 = this._decodeChar(s.charCodeAt(i + 3));\n                    out[op++] = v0 << 2 | v1 >>> 4;\n                    out[op++] = v1 << 4 | v2 >>> 2;\n                    out[op++] = v2 << 6 | v3;\n                    haveBad |= v0 & INVALID_BYTE;\n                    haveBad |= v1 & INVALID_BYTE;\n                    haveBad |= v2 & INVALID_BYTE;\n                    haveBad |= v3 & INVALID_BYTE;\n                }\n                if (i < length - 1) {\n                    v0 = this._decodeChar(s.charCodeAt(i));\n                    v1 = this._decodeChar(s.charCodeAt(i + 1));\n                    out[op++] = v0 << 2 | v1 >>> 4;\n                    haveBad |= v0 & INVALID_BYTE;\n                    haveBad |= v1 & INVALID_BYTE;\n                }\n                if (i < length - 2) {\n                    v2 = this._decodeChar(s.charCodeAt(i + 2));\n                    out[op++] = v1 << 4 | v2 >>> 2;\n                    haveBad |= v2 & INVALID_BYTE;\n                }\n                if (i < length - 3) {\n                    v3 = this._decodeChar(s.charCodeAt(i + 3));\n                    out[op++] = v2 << 6 | v3;\n                    haveBad |= v3 & INVALID_BYTE;\n                }\n                if (haveBad !== 0) {\n                    throw new Error(\"Base64Coder: incorrect characters for decoding\");\n                }\n                return out;\n            };\n            // Standard encoding have the following encoded/decoded ranges,\n            // which we need to convert between.\n            //\n            // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  +   /\n            // Index:   0 - 25                    26 - 51              52 - 61   62  63\n            // ASCII:  65 - 90                    97 - 122             48 - 57   43  47\n            //\n            // Encode 6 bits in b into a new character.\n            Coder.prototype._encodeByte = function(b) {\n                // Encoding uses constant time operations as follows:\n                //\n                // 1. Define comparison of A with B using (A - B) >>> 8:\n                //          if A > B, then result is positive integer\n                //          if A <= B, then result is 0\n                //\n                // 2. Define selection of C or 0 using bitwise AND: X & C:\n                //          if X == 0, then result is 0\n                //          if X != 0, then result is C\n                //\n                // 3. Start with the smallest comparison (b >= 0), which is always\n                //    true, so set the result to the starting ASCII value (65).\n                //\n                // 4. Continue comparing b to higher ASCII values, and selecting\n                //    zero if comparison isn't true, otherwise selecting a value\n                //    to add to result, which:\n                //\n                //          a) undoes the previous addition\n                //          b) provides new value to add\n                //\n                var result = b;\n                // b >= 0\n                result += 65;\n                // b > 25\n                result += 25 - b >>> 8 & 0 - 65 - 26 + 97;\n                // b > 51\n                result += 51 - b >>> 8 & 26 - 97 - 52 + 48;\n                // b > 61\n                result += 61 - b >>> 8 & 52 - 48 - 62 + 43;\n                // b > 62\n                result += 62 - b >>> 8 & 62 - 43 - 63 + 47;\n                return String.fromCharCode(result);\n            };\n            // Decode a character code into a byte.\n            // Must return 256 if character is out of alphabet range.\n            Coder.prototype._decodeChar = function(c) {\n                // Decoding works similar to encoding: using the same comparison\n                // function, but now it works on ranges: result is always incremented\n                // by value, but this value becomes zero if the range is not\n                // satisfied.\n                //\n                // Decoding starts with invalid value, 256, which is then\n                // subtracted when the range is satisfied. If none of the ranges\n                // apply, the function returns 256, which is then checked by\n                // the caller to throw error.\n                var result = INVALID_BYTE; // start with invalid character\n                // c == 43 (c > 42 and c < 44)\n                result += (42 - c & c - 44) >>> 8 & -INVALID_BYTE + c - 43 + 62;\n                // c == 47 (c > 46 and c < 48)\n                result += (46 - c & c - 48) >>> 8 & -INVALID_BYTE + c - 47 + 63;\n                // c > 47 and c < 58\n                result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;\n                // c > 64 and c < 91\n                result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;\n                // c > 96 and c < 123\n                result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;\n                return result;\n            };\n            Coder.prototype._getPaddingLength = function(s) {\n                var paddingLength = 0;\n                if (this._paddingCharacter) {\n                    for(var i = s.length - 1; i >= 0; i--){\n                        if (s[i] !== this._paddingCharacter) {\n                            break;\n                        }\n                        paddingLength++;\n                    }\n                    if (s.length < 4 || paddingLength > 2) {\n                        throw new Error(\"Base64Coder: incorrect padding\");\n                    }\n                }\n                return paddingLength;\n            };\n            return Coder;\n        }();\n        exports.Coder = Coder;\n        var stdCoder = new Coder();\n        function encode(data) {\n            return stdCoder.encode(data);\n        }\n        exports.encode = encode;\n        function decode(s) {\n            return stdCoder.decode(s);\n        }\n        exports.decode = decode;\n        /**\n * Implements URL-safe Base64 encoding.\n * (Same as Base64, but '+' is replaced with '-', and '/' with '_').\n *\n * Operates in constant time.\n */ var URLSafeCoder = /** @class */ function(_super) {\n            __extends(URLSafeCoder, _super);\n            function URLSafeCoder() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            // URL-safe encoding have the following encoded/decoded ranges:\n            //\n            // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  -   _\n            // Index:   0 - 25                    26 - 51              52 - 61   62  63\n            // ASCII:  65 - 90                    97 - 122             48 - 57   45  95\n            //\n            URLSafeCoder.prototype._encodeByte = function(b) {\n                var result = b;\n                // b >= 0\n                result += 65;\n                // b > 25\n                result += 25 - b >>> 8 & 0 - 65 - 26 + 97;\n                // b > 51\n                result += 51 - b >>> 8 & 26 - 97 - 52 + 48;\n                // b > 61\n                result += 61 - b >>> 8 & 52 - 48 - 62 + 45;\n                // b > 62\n                result += 62 - b >>> 8 & 62 - 45 - 63 + 95;\n                return String.fromCharCode(result);\n            };\n            URLSafeCoder.prototype._decodeChar = function(c) {\n                var result = INVALID_BYTE;\n                // c == 45 (c > 44 and c < 46)\n                result += (44 - c & c - 46) >>> 8 & -INVALID_BYTE + c - 45 + 62;\n                // c == 95 (c > 94 and c < 96)\n                result += (94 - c & c - 96) >>> 8 & -INVALID_BYTE + c - 95 + 63;\n                // c > 47 and c < 58\n                result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;\n                // c > 64 and c < 91\n                result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;\n                // c > 96 and c < 123\n                result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;\n                return result;\n            };\n            return URLSafeCoder;\n        }(Coder);\n        exports.URLSafeCoder = URLSafeCoder;\n        var urlSafeCoder = new URLSafeCoder();\n        function encodeURLSafe(data) {\n            return urlSafeCoder.encode(data);\n        }\n        exports.encodeURLSafe = encodeURLSafe;\n        function decodeURLSafe(s) {\n            return urlSafeCoder.decode(s);\n        }\n        exports.decodeURLSafe = decodeURLSafe;\n        exports.encodedLength = function(length) {\n            return stdCoder.encodedLength(length);\n        };\n        exports.maxDecodedLength = function(length) {\n            return stdCoder.maxDecodedLength(length);\n        };\n        exports.decodedLength = function(s) {\n            return stdCoder.decodedLength(s);\n        };\n    /***/ },\n    /* 9 */ /***/ function(module1, exports, __webpack_require__) {\n        \"use strict\";\n        var Headers = function() {\n            this.clear();\n        };\n        Headers.prototype.ALLOWED_DUPLICATES = [\n            \"set-cookie\",\n            \"set-cookie2\",\n            \"warning\",\n            \"www-authenticate\"\n        ];\n        Headers.prototype.clear = function() {\n            this._sent = {};\n            this._lines = [];\n        };\n        Headers.prototype.set = function(name, value) {\n            if (value === undefined) return;\n            name = this._strip(name);\n            value = this._strip(value);\n            var key = name.toLowerCase();\n            if (!this._sent.hasOwnProperty(key) || this.ALLOWED_DUPLICATES.indexOf(key) >= 0) {\n                this._sent[key] = true;\n                this._lines.push(name + \": \" + value + \"\\r\\n\");\n            }\n        };\n        Headers.prototype.toString = function() {\n            return this._lines.join(\"\");\n        };\n        Headers.prototype._strip = function(string) {\n            return string.toString().replace(/^ */, \"\").replace(/ *$/, \"\");\n        };\n        module1.exports = Headers;\n    /***/ },\n    /* 10 */ /***/ function(module1, exports, __nested_webpack_require_29545__) {\n        \"use strict\";\n        var NodeHTTPParser = __nested_webpack_require_29545__(27).HTTPParser, Buffer1 = __nested_webpack_require_29545__(1).Buffer;\n        var TYPES = {\n            request: NodeHTTPParser.REQUEST || \"request\",\n            response: NodeHTTPParser.RESPONSE || \"response\"\n        };\n        var HttpParser = function(type) {\n            this._type = type;\n            this._parser = new NodeHTTPParser(TYPES[type]);\n            this._complete = false;\n            this.headers = {};\n            var current = null, self1 = this;\n            this._parser.onHeaderField = function(b, start, length) {\n                current = b.toString(\"utf8\", start, start + length).toLowerCase();\n            };\n            this._parser.onHeaderValue = function(b, start, length) {\n                var value = b.toString(\"utf8\", start, start + length);\n                if (self1.headers.hasOwnProperty(current)) self1.headers[current] += \", \" + value;\n                else self1.headers[current] = value;\n            };\n            this._parser.onHeadersComplete = this._parser[NodeHTTPParser.kOnHeadersComplete] = function(majorVersion, minorVersion, headers, method, pathname, statusCode) {\n                var info = arguments[0];\n                if (typeof info === \"object\") {\n                    method = info.method;\n                    pathname = info.url;\n                    statusCode = info.statusCode;\n                    headers = info.headers;\n                }\n                self1.method = typeof method === \"number\" ? HttpParser.METHODS[method] : method;\n                self1.statusCode = statusCode;\n                self1.url = pathname;\n                if (!headers) return;\n                for(var i = 0, n = headers.length, key, value; i < n; i += 2){\n                    key = headers[i].toLowerCase();\n                    value = headers[i + 1];\n                    if (self1.headers.hasOwnProperty(key)) self1.headers[key] += \", \" + value;\n                    else self1.headers[key] = value;\n                }\n                self1._complete = true;\n            };\n        };\n        HttpParser.METHODS = {\n            0: \"DELETE\",\n            1: \"GET\",\n            2: \"HEAD\",\n            3: \"POST\",\n            4: \"PUT\",\n            5: \"CONNECT\",\n            6: \"OPTIONS\",\n            7: \"TRACE\",\n            8: \"COPY\",\n            9: \"LOCK\",\n            10: \"MKCOL\",\n            11: \"MOVE\",\n            12: \"PROPFIND\",\n            13: \"PROPPATCH\",\n            14: \"SEARCH\",\n            15: \"UNLOCK\",\n            16: \"BIND\",\n            17: \"REBIND\",\n            18: \"UNBIND\",\n            19: \"ACL\",\n            20: \"REPORT\",\n            21: \"MKACTIVITY\",\n            22: \"CHECKOUT\",\n            23: \"MERGE\",\n            24: \"M-SEARCH\",\n            25: \"NOTIFY\",\n            26: \"SUBSCRIBE\",\n            27: \"UNSUBSCRIBE\",\n            28: \"PATCH\",\n            29: \"PURGE\",\n            30: \"MKCALENDAR\",\n            31: \"LINK\",\n            32: \"UNLINK\"\n        };\n        var VERSION = process.version ? process.version.match(/[0-9]+/g).map(function(n) {\n            return parseInt(n, 10);\n        }) : [];\n        if (VERSION[0] === 0 && VERSION[1] === 12) {\n            HttpParser.METHODS[16] = \"REPORT\";\n            HttpParser.METHODS[17] = \"MKACTIVITY\";\n            HttpParser.METHODS[18] = \"CHECKOUT\";\n            HttpParser.METHODS[19] = \"MERGE\";\n            HttpParser.METHODS[20] = \"M-SEARCH\";\n            HttpParser.METHODS[21] = \"NOTIFY\";\n            HttpParser.METHODS[22] = \"SUBSCRIBE\";\n            HttpParser.METHODS[23] = \"UNSUBSCRIBE\";\n            HttpParser.METHODS[24] = \"PATCH\";\n            HttpParser.METHODS[25] = \"PURGE\";\n        }\n        HttpParser.prototype.isComplete = function() {\n            return this._complete;\n        };\n        HttpParser.prototype.parse = function(chunk) {\n            var consumed = this._parser.execute(chunk, 0, chunk.length);\n            if (typeof consumed !== \"number\") {\n                this.error = consumed;\n                this._complete = true;\n                return;\n            }\n            if (this._complete) this.body = consumed < chunk.length ? chunk.slice(consumed) : Buffer1.alloc(0);\n        };\n        module1.exports = HttpParser;\n    /***/ },\n    /* 11 */ /***/ function(module1, exports, __nested_webpack_require_33844__) {\n        \"use strict\";\n        var Stream = __nested_webpack_require_33844__(5).Stream, util = __nested_webpack_require_33844__(0), driver = __nested_webpack_require_33844__(4), EventTarget = __nested_webpack_require_33844__(16), Event = __nested_webpack_require_33844__(7);\n        var API = function(options) {\n            options = options || {};\n            driver.validateOptions(options, [\n                \"headers\",\n                \"extensions\",\n                \"maxLength\",\n                \"ping\",\n                \"proxy\",\n                \"tls\",\n                \"ca\"\n            ]);\n            this.readable = this.writable = true;\n            var headers = options.headers;\n            if (headers) {\n                for(var name in headers)this._driver.setHeader(name, headers[name]);\n            }\n            var extensions = options.extensions;\n            if (extensions) {\n                [].concat(extensions).forEach(this._driver.addExtension, this._driver);\n            }\n            this._ping = options.ping;\n            this._pingId = 0;\n            this.readyState = API.CONNECTING;\n            this.bufferedAmount = 0;\n            this.protocol = \"\";\n            this.url = this._driver.url;\n            this.version = this._driver.version;\n            var self1 = this;\n            this._driver.on(\"open\", function(e) {\n                self1._open();\n            });\n            this._driver.on(\"message\", function(e) {\n                self1._receiveMessage(e.data);\n            });\n            this._driver.on(\"close\", function(e) {\n                self1._beginClose(e.reason, e.code);\n            });\n            this._driver.on(\"error\", function(error) {\n                self1._emitError(error.message);\n            });\n            this.on(\"error\", function() {});\n            this._driver.messages.on(\"drain\", function() {\n                self1.emit(\"drain\");\n            });\n            if (this._ping) this._pingTimer = setInterval(function() {\n                self1._pingId += 1;\n                self1.ping(self1._pingId.toString());\n            }, this._ping * 1000);\n            this._configureStream();\n            if (!this._proxy) {\n                this._stream.pipe(this._driver.io);\n                this._driver.io.pipe(this._stream);\n            }\n        };\n        util.inherits(API, Stream);\n        API.CONNECTING = 0;\n        API.OPEN = 1;\n        API.CLOSING = 2;\n        API.CLOSED = 3;\n        API.CLOSE_TIMEOUT = 30000;\n        var instance = {\n            write: function(data) {\n                return this.send(data);\n            },\n            end: function(data) {\n                if (data !== undefined) this.send(data);\n                this.close();\n            },\n            pause: function() {\n                return this._driver.messages.pause();\n            },\n            resume: function() {\n                return this._driver.messages.resume();\n            },\n            send: function(data) {\n                if (this.readyState > API.OPEN) return false;\n                if (!(data instanceof Buffer)) data = String(data);\n                return this._driver.messages.write(data);\n            },\n            ping: function(message, callback) {\n                if (this.readyState > API.OPEN) return false;\n                return this._driver.ping(message, callback);\n            },\n            close: function(code, reason) {\n                if (code === undefined) code = 1000;\n                if (reason === undefined) reason = \"\";\n                if (code !== 1000 && (code < 3000 || code > 4999)) throw new Error(\"Failed to execute 'close' on WebSocket: \" + \"The code must be either 1000, or between 3000 and 4999. \" + code + \" is neither.\");\n                if (this.readyState !== API.CLOSED) this.readyState = API.CLOSING;\n                var self1 = this;\n                this._closeTimer = setTimeout(function() {\n                    self1._beginClose(\"\", 1006);\n                }, API.CLOSE_TIMEOUT);\n                this._driver.close(reason, code);\n            },\n            _configureStream: function() {\n                var self1 = this;\n                this._stream.setTimeout(0);\n                this._stream.setNoDelay(true);\n                [\n                    \"close\",\n                    \"end\"\n                ].forEach(function(event) {\n                    this._stream.on(event, function() {\n                        self1._finalizeClose();\n                    });\n                }, this);\n                this._stream.on(\"error\", function(error) {\n                    self1._emitError(\"Network error: \" + self1.url + \": \" + error.message);\n                    self1._finalizeClose();\n                });\n            },\n            _open: function() {\n                if (this.readyState !== API.CONNECTING) return;\n                this.readyState = API.OPEN;\n                this.protocol = this._driver.protocol || \"\";\n                var event = new Event(\"open\");\n                event.initEvent(\"open\", false, false);\n                this.dispatchEvent(event);\n            },\n            _receiveMessage: function(data) {\n                if (this.readyState > API.OPEN) return false;\n                if (this.readable) this.emit(\"data\", data);\n                var event = new Event(\"message\", {\n                    data: data\n                });\n                event.initEvent(\"message\", false, false);\n                this.dispatchEvent(event);\n            },\n            _emitError: function(message) {\n                if (this.readyState >= API.CLOSING) return;\n                var event = new Event(\"error\", {\n                    message: message\n                });\n                event.initEvent(\"error\", false, false);\n                this.dispatchEvent(event);\n            },\n            _beginClose: function(reason, code) {\n                if (this.readyState === API.CLOSED) return;\n                this.readyState = API.CLOSING;\n                this._closeParams = [\n                    reason,\n                    code\n                ];\n                if (this._stream) {\n                    this._stream.destroy();\n                    if (!this._stream.readable) this._finalizeClose();\n                }\n            },\n            _finalizeClose: function() {\n                if (this.readyState === API.CLOSED) return;\n                this.readyState = API.CLOSED;\n                if (this._closeTimer) clearTimeout(this._closeTimer);\n                if (this._pingTimer) clearInterval(this._pingTimer);\n                if (this._stream) this._stream.end();\n                if (this.readable) this.emit(\"end\");\n                this.readable = this.writable = false;\n                var reason = this._closeParams ? this._closeParams[0] : \"\", code = this._closeParams ? this._closeParams[1] : 1006;\n                var event = new Event(\"close\", {\n                    code: code,\n                    reason: reason\n                });\n                event.initEvent(\"close\", false, false);\n                this.dispatchEvent(event);\n            }\n        };\n        for(var method in instance)API.prototype[method] = instance[method];\n        for(var key in EventTarget)API.prototype[key] = EventTarget[key];\n        module1.exports = API;\n    /***/ },\n    /* 12 */ /***/ function(module1, exports, __nested_webpack_require_41116__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_41116__(1).Buffer, crypto = __nested_webpack_require_41116__(3), util = __nested_webpack_require_41116__(0), Extensions = __nested_webpack_require_41116__(29), Base = __nested_webpack_require_41116__(2), Frame = __nested_webpack_require_41116__(34), Message = __nested_webpack_require_41116__(35);\n        var Hybi = function(request, url, options) {\n            Base.apply(this, arguments);\n            this._extensions = new Extensions();\n            this._stage = 0;\n            this._masking = this._options.masking;\n            this._protocols = this._options.protocols || [];\n            this._requireMasking = this._options.requireMasking;\n            this._pingCallbacks = {};\n            if (typeof this._protocols === \"string\") this._protocols = this._protocols.split(/ *, */);\n            if (!this._request) return;\n            var protos = this._request.headers[\"sec-websocket-protocol\"], supported = this._protocols;\n            if (protos !== undefined) {\n                if (typeof protos === \"string\") protos = protos.split(/ *, */);\n                this.protocol = protos.filter(function(p) {\n                    return supported.indexOf(p) >= 0;\n                })[0];\n            }\n            this.version = \"hybi-\" + Hybi.VERSION;\n        };\n        util.inherits(Hybi, Base);\n        Hybi.VERSION = \"13\";\n        Hybi.mask = function(payload, mask, offset) {\n            if (!mask || mask.length === 0) return payload;\n            offset = offset || 0;\n            for(var i = 0, n = payload.length - offset; i < n; i++){\n                payload[offset + i] = payload[offset + i] ^ mask[i % 4];\n            }\n            return payload;\n        };\n        Hybi.generateAccept = function(key) {\n            var sha1 = crypto.createHash(\"sha1\");\n            sha1.update(key + Hybi.GUID);\n            return sha1.digest(\"base64\");\n        };\n        Hybi.GUID = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n        var instance = {\n            FIN: 0x80,\n            MASK: 0x80,\n            RSV1: 0x40,\n            RSV2: 0x20,\n            RSV3: 0x10,\n            OPCODE: 0x0F,\n            LENGTH: 0x7F,\n            OPCODES: {\n                continuation: 0,\n                text: 1,\n                binary: 2,\n                close: 8,\n                ping: 9,\n                pong: 10\n            },\n            OPCODE_CODES: [\n                0,\n                1,\n                2,\n                8,\n                9,\n                10\n            ],\n            MESSAGE_OPCODES: [\n                0,\n                1,\n                2\n            ],\n            OPENING_OPCODES: [\n                1,\n                2\n            ],\n            ERRORS: {\n                normal_closure: 1000,\n                going_away: 1001,\n                protocol_error: 1002,\n                unacceptable: 1003,\n                encoding_error: 1007,\n                policy_violation: 1008,\n                too_large: 1009,\n                extension_error: 1010,\n                unexpected_condition: 1011\n            },\n            ERROR_CODES: [\n                1000,\n                1001,\n                1002,\n                1003,\n                1007,\n                1008,\n                1009,\n                1010,\n                1011\n            ],\n            DEFAULT_ERROR_CODE: 1000,\n            MIN_RESERVED_ERROR: 3000,\n            MAX_RESERVED_ERROR: 4999,\n            // http://www.w3.org/International/questions/qa-forms-utf-8.en.php\n            UTF8_MATCH: /^([\\x00-\\x7F]|[\\xC2-\\xDF][\\x80-\\xBF]|\\xE0[\\xA0-\\xBF][\\x80-\\xBF]|[\\xE1-\\xEC\\xEE\\xEF][\\x80-\\xBF]{2}|\\xED[\\x80-\\x9F][\\x80-\\xBF]|\\xF0[\\x90-\\xBF][\\x80-\\xBF]{2}|[\\xF1-\\xF3][\\x80-\\xBF]{3}|\\xF4[\\x80-\\x8F][\\x80-\\xBF]{2})*$/,\n            addExtension: function(extension) {\n                this._extensions.add(extension);\n                return true;\n            },\n            parse: function(chunk) {\n                this._reader.put(chunk);\n                var buffer = true;\n                while(buffer){\n                    switch(this._stage){\n                        case 0:\n                            buffer = this._reader.read(1);\n                            if (buffer) this._parseOpcode(buffer[0]);\n                            break;\n                        case 1:\n                            buffer = this._reader.read(1);\n                            if (buffer) this._parseLength(buffer[0]);\n                            break;\n                        case 2:\n                            buffer = this._reader.read(this._frame.lengthBytes);\n                            if (buffer) this._parseExtendedLength(buffer);\n                            break;\n                        case 3:\n                            buffer = this._reader.read(4);\n                            if (buffer) {\n                                this._stage = 4;\n                                this._frame.maskingKey = buffer;\n                            }\n                            break;\n                        case 4:\n                            buffer = this._reader.read(this._frame.length);\n                            if (buffer) {\n                                this._stage = 0;\n                                this._emitFrame(buffer);\n                            }\n                            break;\n                        default:\n                            buffer = null;\n                    }\n                }\n            },\n            text: function(message) {\n                if (this.readyState > 1) return false;\n                return this.frame(message, \"text\");\n            },\n            binary: function(message) {\n                if (this.readyState > 1) return false;\n                return this.frame(message, \"binary\");\n            },\n            ping: function(message, callback) {\n                if (this.readyState > 1) return false;\n                message = message || \"\";\n                if (callback) this._pingCallbacks[message] = callback;\n                return this.frame(message, \"ping\");\n            },\n            pong: function(message) {\n                if (this.readyState > 1) return false;\n                message = message || \"\";\n                return this.frame(message, \"pong\");\n            },\n            close: function(reason, code) {\n                reason = reason || \"\";\n                code = code || this.ERRORS.normal_closure;\n                if (this.readyState <= 0) {\n                    this.readyState = 3;\n                    this.emit(\"close\", new Base.CloseEvent(code, reason));\n                    return true;\n                } else if (this.readyState === 1) {\n                    this.readyState = 2;\n                    this._extensions.close(function() {\n                        this.frame(reason, \"close\", code);\n                    }, this);\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n            frame: function(buffer, type, code) {\n                if (this.readyState <= 0) return this._queue([\n                    buffer,\n                    type,\n                    code\n                ]);\n                if (this.readyState > 2) return false;\n                if (buffer instanceof Array) buffer = Buffer1.from(buffer);\n                if (typeof buffer === \"number\") buffer = buffer.toString();\n                var message = new Message(), isText = typeof buffer === \"string\", payload, copy;\n                message.rsv1 = message.rsv2 = message.rsv3 = false;\n                message.opcode = this.OPCODES[type || (isText ? \"text\" : \"binary\")];\n                payload = isText ? Buffer1.from(buffer, \"utf8\") : buffer;\n                if (code) {\n                    copy = payload;\n                    payload = Buffer1.allocUnsafe(2 + copy.length);\n                    payload.writeUInt16BE(code, 0);\n                    copy.copy(payload, 2);\n                }\n                message.data = payload;\n                var onMessageReady = function(message) {\n                    var frame = new Frame();\n                    frame.final = true;\n                    frame.rsv1 = message.rsv1;\n                    frame.rsv2 = message.rsv2;\n                    frame.rsv3 = message.rsv3;\n                    frame.opcode = message.opcode;\n                    frame.masked = !!this._masking;\n                    frame.length = message.data.length;\n                    frame.payload = message.data;\n                    if (frame.masked) frame.maskingKey = crypto.randomBytes(4);\n                    this._sendFrame(frame);\n                };\n                if (this.MESSAGE_OPCODES.indexOf(message.opcode) >= 0) this._extensions.processOutgoingMessage(message, function(error, message) {\n                    if (error) return this._fail(\"extension_error\", error.message);\n                    onMessageReady.call(this, message);\n                }, this);\n                else onMessageReady.call(this, message);\n                return true;\n            },\n            _sendFrame: function(frame) {\n                var length = frame.length, header = length <= 125 ? 2 : length <= 65535 ? 4 : 10, offset = header + (frame.masked ? 4 : 0), buffer = Buffer1.allocUnsafe(offset + length), masked = frame.masked ? this.MASK : 0;\n                buffer[0] = (frame.final ? this.FIN : 0) | (frame.rsv1 ? this.RSV1 : 0) | (frame.rsv2 ? this.RSV2 : 0) | (frame.rsv3 ? this.RSV3 : 0) | frame.opcode;\n                if (length <= 125) {\n                    buffer[1] = masked | length;\n                } else if (length <= 65535) {\n                    buffer[1] = masked | 126;\n                    buffer.writeUInt16BE(length, 2);\n                } else {\n                    buffer[1] = masked | 127;\n                    buffer.writeUInt32BE(Math.floor(length / 0x100000000), 2);\n                    buffer.writeUInt32BE(length % 0x100000000, 6);\n                }\n                frame.payload.copy(buffer, offset);\n                if (frame.masked) {\n                    frame.maskingKey.copy(buffer, header);\n                    Hybi.mask(buffer, frame.maskingKey, offset);\n                }\n                this._write(buffer);\n            },\n            _handshakeResponse: function() {\n                var secKey = this._request.headers[\"sec-websocket-key\"], version = this._request.headers[\"sec-websocket-version\"];\n                if (version !== Hybi.VERSION) throw new Error(\"Unsupported WebSocket version: \" + version);\n                if (typeof secKey !== \"string\") throw new Error(\"Missing handshake request header: Sec-WebSocket-Key\");\n                this._headers.set(\"Upgrade\", \"websocket\");\n                this._headers.set(\"Connection\", \"Upgrade\");\n                this._headers.set(\"Sec-WebSocket-Accept\", Hybi.generateAccept(secKey));\n                if (this.protocol) this._headers.set(\"Sec-WebSocket-Protocol\", this.protocol);\n                var extensions = this._extensions.generateResponse(this._request.headers[\"sec-websocket-extensions\"]);\n                if (extensions) this._headers.set(\"Sec-WebSocket-Extensions\", extensions);\n                var start = \"HTTP/1.1 101 Switching Protocols\", headers = [\n                    start,\n                    this._headers.toString(),\n                    \"\"\n                ];\n                return Buffer1.from(headers.join(\"\\r\\n\"), \"utf8\");\n            },\n            _shutdown: function(code, reason, error) {\n                delete this._frame;\n                delete this._message;\n                this._stage = 5;\n                var sendCloseFrame = this.readyState === 1;\n                this.readyState = 2;\n                this._extensions.close(function() {\n                    if (sendCloseFrame) this.frame(reason, \"close\", code);\n                    this.readyState = 3;\n                    if (error) this.emit(\"error\", new Error(reason));\n                    this.emit(\"close\", new Base.CloseEvent(code, reason));\n                }, this);\n            },\n            _fail: function(type, message) {\n                if (this.readyState > 1) return;\n                this._shutdown(this.ERRORS[type], message, true);\n            },\n            _parseOpcode: function(octet) {\n                var rsvs = [\n                    this.RSV1,\n                    this.RSV2,\n                    this.RSV3\n                ].map(function(rsv) {\n                    return (octet & rsv) === rsv;\n                });\n                var frame = this._frame = new Frame();\n                frame.final = (octet & this.FIN) === this.FIN;\n                frame.rsv1 = rsvs[0];\n                frame.rsv2 = rsvs[1];\n                frame.rsv3 = rsvs[2];\n                frame.opcode = octet & this.OPCODE;\n                this._stage = 1;\n                if (!this._extensions.validFrameRsv(frame)) return this._fail(\"protocol_error\", \"One or more reserved bits are on: reserved1 = \" + (frame.rsv1 ? 1 : 0) + \", reserved2 = \" + (frame.rsv2 ? 1 : 0) + \", reserved3 = \" + (frame.rsv3 ? 1 : 0));\n                if (this.OPCODE_CODES.indexOf(frame.opcode) < 0) return this._fail(\"protocol_error\", \"Unrecognized frame opcode: \" + frame.opcode);\n                if (this.MESSAGE_OPCODES.indexOf(frame.opcode) < 0 && !frame.final) return this._fail(\"protocol_error\", \"Received fragmented control frame: opcode = \" + frame.opcode);\n                if (this._message && this.OPENING_OPCODES.indexOf(frame.opcode) >= 0) return this._fail(\"protocol_error\", \"Received new data frame but previous continuous frame is unfinished\");\n            },\n            _parseLength: function(octet) {\n                var frame = this._frame;\n                frame.masked = (octet & this.MASK) === this.MASK;\n                frame.length = octet & this.LENGTH;\n                if (frame.length >= 0 && frame.length <= 125) {\n                    this._stage = frame.masked ? 3 : 4;\n                    if (!this._checkFrameLength()) return;\n                } else {\n                    this._stage = 2;\n                    frame.lengthBytes = frame.length === 126 ? 2 : 8;\n                }\n                if (this._requireMasking && !frame.masked) return this._fail(\"unacceptable\", \"Received unmasked frame but masking is required\");\n            },\n            _parseExtendedLength: function(buffer) {\n                var frame = this._frame;\n                frame.length = this._readUInt(buffer);\n                this._stage = frame.masked ? 3 : 4;\n                if (this.MESSAGE_OPCODES.indexOf(frame.opcode) < 0 && frame.length > 125) return this._fail(\"protocol_error\", \"Received control frame having too long payload: \" + frame.length);\n                if (!this._checkFrameLength()) return;\n            },\n            _checkFrameLength: function() {\n                var length = this._message ? this._message.length : 0;\n                if (length + this._frame.length > this._maxLength) {\n                    this._fail(\"too_large\", \"WebSocket frame length too large\");\n                    return false;\n                } else {\n                    return true;\n                }\n            },\n            _emitFrame: function(buffer) {\n                var frame = this._frame, payload = frame.payload = Hybi.mask(buffer, frame.maskingKey), opcode = frame.opcode, message, code, reason, callbacks, callback;\n                delete this._frame;\n                if (opcode === this.OPCODES.continuation) {\n                    if (!this._message) return this._fail(\"protocol_error\", \"Received unexpected continuation frame\");\n                    this._message.pushFrame(frame);\n                }\n                if (opcode === this.OPCODES.text || opcode === this.OPCODES.binary) {\n                    this._message = new Message();\n                    this._message.pushFrame(frame);\n                }\n                if (frame.final && this.MESSAGE_OPCODES.indexOf(opcode) >= 0) return this._emitMessage(this._message);\n                if (opcode === this.OPCODES.close) {\n                    code = payload.length >= 2 ? payload.readUInt16BE(0) : null;\n                    reason = payload.length > 2 ? this._encode(payload.slice(2)) : null;\n                    if (!(payload.length === 0) && !(code !== null && code >= this.MIN_RESERVED_ERROR && code <= this.MAX_RESERVED_ERROR) && this.ERROR_CODES.indexOf(code) < 0) code = this.ERRORS.protocol_error;\n                    if (payload.length > 125 || payload.length > 2 && !reason) code = this.ERRORS.protocol_error;\n                    this._shutdown(code || this.DEFAULT_ERROR_CODE, reason || \"\");\n                }\n                if (opcode === this.OPCODES.ping) {\n                    this.frame(payload, \"pong\");\n                    this.emit(\"ping\", new Base.PingEvent(payload.toString()));\n                }\n                if (opcode === this.OPCODES.pong) {\n                    callbacks = this._pingCallbacks;\n                    message = this._encode(payload);\n                    callback = callbacks[message];\n                    delete callbacks[message];\n                    if (callback) callback();\n                    this.emit(\"pong\", new Base.PongEvent(payload.toString()));\n                }\n            },\n            _emitMessage: function(message) {\n                var message = this._message;\n                message.read();\n                delete this._message;\n                this._extensions.processIncomingMessage(message, function(error, message) {\n                    if (error) return this._fail(\"extension_error\", error.message);\n                    var payload = message.data;\n                    if (message.opcode === this.OPCODES.text) payload = this._encode(payload);\n                    if (payload === null) return this._fail(\"encoding_error\", \"Could not decode a text frame as UTF-8\");\n                    else this.emit(\"message\", new Base.MessageEvent(payload));\n                }, this);\n            },\n            _encode: function(buffer) {\n                try {\n                    var string = buffer.toString(\"binary\", 0, buffer.length);\n                    if (!this.UTF8_MATCH.test(string)) return null;\n                } catch (e) {}\n                return buffer.toString(\"utf8\", 0, buffer.length);\n            },\n            _readUInt: function(buffer) {\n                if (buffer.length === 2) return buffer.readUInt16BE(0);\n                return buffer.readUInt32BE(0) * 0x100000000 + buffer.readUInt32BE(4);\n            }\n        };\n        for(var key in instance)Hybi.prototype[key] = instance[key];\n        module1.exports = Hybi;\n    /***/ },\n    /* 13 */ /***/ function(module1, exports, __webpack_require__) {\n        \"use strict\";\n        var RingBuffer = function(bufferSize) {\n            this._bufferSize = bufferSize;\n            this.clear();\n        };\n        RingBuffer.prototype.clear = function() {\n            this._buffer = new Array(this._bufferSize);\n            this._ringOffset = 0;\n            this._ringSize = this._bufferSize;\n            this._head = 0;\n            this._tail = 0;\n            this.length = 0;\n        };\n        RingBuffer.prototype.push = function(value) {\n            var expandBuffer = false, expandRing = false;\n            if (this._ringSize < this._bufferSize) {\n                expandBuffer = this._tail === 0;\n            } else if (this._ringOffset === this._ringSize) {\n                expandBuffer = true;\n                expandRing = this._tail === 0;\n            }\n            if (expandBuffer) {\n                this._tail = this._bufferSize;\n                this._buffer = this._buffer.concat(new Array(this._bufferSize));\n                this._bufferSize = this._buffer.length;\n                if (expandRing) this._ringSize = this._bufferSize;\n            }\n            this._buffer[this._tail] = value;\n            this.length += 1;\n            if (this._tail < this._ringSize) this._ringOffset += 1;\n            this._tail = (this._tail + 1) % this._bufferSize;\n        };\n        RingBuffer.prototype.peek = function() {\n            if (this.length === 0) return void 0;\n            return this._buffer[this._head];\n        };\n        RingBuffer.prototype.shift = function() {\n            if (this.length === 0) return void 0;\n            var value = this._buffer[this._head];\n            this._buffer[this._head] = void 0;\n            this.length -= 1;\n            this._ringOffset -= 1;\n            if (this._ringOffset === 0 && this.length > 0) {\n                this._head = this._ringSize;\n                this._ringOffset = this.length;\n                this._ringSize = this._bufferSize;\n            } else {\n                this._head = (this._head + 1) % this._ringSize;\n            }\n            return value;\n        };\n        module1.exports = RingBuffer;\n    /***/ },\n    /* 14 */ /***/ function(module1, exports, __nested_webpack_require_61915__) {\n        \"use strict\";\n        var RingBuffer = __nested_webpack_require_61915__(13);\n        var Pledge = function() {\n            this._complete = false;\n            this._callbacks = new RingBuffer(Pledge.QUEUE_SIZE);\n        };\n        Pledge.QUEUE_SIZE = 4;\n        Pledge.all = function(list) {\n            var pledge = new Pledge(), pending = list.length, n = pending;\n            if (pending === 0) pledge.done();\n            while(n--)list[n].then(function() {\n                pending -= 1;\n                if (pending === 0) pledge.done();\n            });\n            return pledge;\n        };\n        Pledge.prototype.then = function(callback) {\n            if (this._complete) callback();\n            else this._callbacks.push(callback);\n        };\n        Pledge.prototype.done = function() {\n            this._complete = true;\n            var callbacks = this._callbacks, callback;\n            while(callback = callbacks.shift())callback();\n        };\n        module1.exports = Pledge;\n    /***/ },\n    /* 15 */ /***/ function(module1, exports, __nested_webpack_require_62983__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_62983__(1).Buffer, Base = __nested_webpack_require_62983__(2), util = __nested_webpack_require_62983__(0);\n        var Draft75 = function(request, url, options) {\n            Base.apply(this, arguments);\n            this._stage = 0;\n            this.version = \"hixie-75\";\n            this._headers.set(\"Upgrade\", \"WebSocket\");\n            this._headers.set(\"Connection\", \"Upgrade\");\n            this._headers.set(\"WebSocket-Origin\", this._request.headers.origin);\n            this._headers.set(\"WebSocket-Location\", this.url);\n        };\n        util.inherits(Draft75, Base);\n        var instance = {\n            close: function() {\n                if (this.readyState === 3) return false;\n                this.readyState = 3;\n                this.emit(\"close\", new Base.CloseEvent(null, null));\n                return true;\n            },\n            parse: function(chunk) {\n                if (this.readyState > 1) return;\n                this._reader.put(chunk);\n                this._reader.eachByte(function(octet) {\n                    var message;\n                    switch(this._stage){\n                        case -1:\n                            this._body.push(octet);\n                            this._sendHandshakeBody();\n                            break;\n                        case 0:\n                            this._parseLeadingByte(octet);\n                            break;\n                        case 1:\n                            this._length = (octet & 0x7F) + 128 * this._length;\n                            if (this._closing && this._length === 0) {\n                                return this.close();\n                            } else if ((octet & 0x80) !== 0x80) {\n                                if (this._length === 0) {\n                                    this._stage = 0;\n                                } else {\n                                    this._skipped = 0;\n                                    this._stage = 2;\n                                }\n                            }\n                            break;\n                        case 2:\n                            if (octet === 0xFF) {\n                                this._stage = 0;\n                                message = Buffer1.from(this._buffer).toString(\"utf8\", 0, this._buffer.length);\n                                this.emit(\"message\", new Base.MessageEvent(message));\n                            } else {\n                                if (this._length) {\n                                    this._skipped += 1;\n                                    if (this._skipped === this._length) this._stage = 0;\n                                } else {\n                                    this._buffer.push(octet);\n                                    if (this._buffer.length > this._maxLength) return this.close();\n                                }\n                            }\n                            break;\n                    }\n                }, this);\n            },\n            frame: function(buffer) {\n                if (this.readyState === 0) return this._queue([\n                    buffer\n                ]);\n                if (this.readyState > 1) return false;\n                if (typeof buffer !== \"string\") buffer = buffer.toString();\n                var length = Buffer1.byteLength(buffer), frame = Buffer1.allocUnsafe(length + 2);\n                frame[0] = 0x00;\n                frame.write(buffer, 1);\n                frame[frame.length - 1] = 0xFF;\n                this._write(frame);\n                return true;\n            },\n            _handshakeResponse: function() {\n                var start = \"HTTP/1.1 101 Web Socket Protocol Handshake\", headers = [\n                    start,\n                    this._headers.toString(),\n                    \"\"\n                ];\n                return Buffer1.from(headers.join(\"\\r\\n\"), \"utf8\");\n            },\n            _parseLeadingByte: function(octet) {\n                if ((octet & 0x80) === 0x80) {\n                    this._length = 0;\n                    this._stage = 1;\n                } else {\n                    delete this._length;\n                    delete this._skipped;\n                    this._buffer = [];\n                    this._stage = 2;\n                }\n            }\n        };\n        for(var key in instance)Draft75.prototype[key] = instance[key];\n        module1.exports = Draft75;\n    /***/ },\n    /* 16 */ /***/ function(module1, exports, __nested_webpack_require_67493__) {\n        \"use strict\";\n        var Event = __nested_webpack_require_67493__(7);\n        var EventTarget = {\n            onopen: null,\n            onmessage: null,\n            onerror: null,\n            onclose: null,\n            addEventListener: function(eventType, listener, useCapture) {\n                this.on(eventType, listener);\n            },\n            removeEventListener: function(eventType, listener, useCapture) {\n                this.removeListener(eventType, listener);\n            },\n            dispatchEvent: function(event) {\n                event.target = event.currentTarget = this;\n                event.eventPhase = Event.AT_TARGET;\n                if (this[\"on\" + event.type]) this[\"on\" + event.type](event);\n                this.emit(event.type, event);\n            }\n        };\n        module1.exports = EventTarget;\n    /***/ },\n    /* 17 */ /***/ function(module1, exports, __webpack_require__) {\n        \"use strict\";\n        // Copyright (C) 2016 Dmitry Chestnykh\n        // MIT License. See LICENSE file for details.\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        /**\n * Package utf8 implements UTF-8 encoding and decoding.\n */ var INVALID_UTF16 = \"utf8: invalid string\";\n        var INVALID_UTF8 = \"utf8: invalid source encoding\";\n        /**\n * Encodes the given string into UTF-8 byte array.\n * Throws if the source string has invalid UTF-16 encoding.\n */ function encode(s) {\n            // Calculate result length and allocate output array.\n            // encodedLength() also validates string and throws errors,\n            // so we don't need repeat validation here.\n            var arr = new Uint8Array(encodedLength(s));\n            var pos = 0;\n            for(var i = 0; i < s.length; i++){\n                var c = s.charCodeAt(i);\n                if (c < 0x80) {\n                    arr[pos++] = c;\n                } else if (c < 0x800) {\n                    arr[pos++] = 0xc0 | c >> 6;\n                    arr[pos++] = 0x80 | c & 0x3f;\n                } else if (c < 0xd800) {\n                    arr[pos++] = 0xe0 | c >> 12;\n                    arr[pos++] = 0x80 | c >> 6 & 0x3f;\n                    arr[pos++] = 0x80 | c & 0x3f;\n                } else {\n                    i++; // get one more character\n                    c = (c & 0x3ff) << 10;\n                    c |= s.charCodeAt(i) & 0x3ff;\n                    c += 0x10000;\n                    arr[pos++] = 0xf0 | c >> 18;\n                    arr[pos++] = 0x80 | c >> 12 & 0x3f;\n                    arr[pos++] = 0x80 | c >> 6 & 0x3f;\n                    arr[pos++] = 0x80 | c & 0x3f;\n                }\n            }\n            return arr;\n        }\n        exports.encode = encode;\n        /**\n * Returns the number of bytes required to encode the given string into UTF-8.\n * Throws if the source string has invalid UTF-16 encoding.\n */ function encodedLength(s) {\n            var result = 0;\n            for(var i = 0; i < s.length; i++){\n                var c = s.charCodeAt(i);\n                if (c < 0x80) {\n                    result += 1;\n                } else if (c < 0x800) {\n                    result += 2;\n                } else if (c < 0xd800) {\n                    result += 3;\n                } else if (c <= 0xdfff) {\n                    if (i >= s.length - 1) {\n                        throw new Error(INVALID_UTF16);\n                    }\n                    i++; // \"eat\" next character\n                    result += 4;\n                } else {\n                    throw new Error(INVALID_UTF16);\n                }\n            }\n            return result;\n        }\n        exports.encodedLength = encodedLength;\n        /**\n * Decodes the given byte array from UTF-8 into a string.\n * Throws if encoding is invalid.\n */ function decode(arr) {\n            var chars = [];\n            for(var i = 0; i < arr.length; i++){\n                var b = arr[i];\n                if (b & 0x80) {\n                    var min = void 0;\n                    if (b < 0xe0) {\n                        // Need 1 more byte.\n                        if (i >= arr.length) {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        var n1 = arr[++i];\n                        if ((n1 & 0xc0) !== 0x80) {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        b = (b & 0x1f) << 6 | n1 & 0x3f;\n                        min = 0x80;\n                    } else if (b < 0xf0) {\n                        // Need 2 more bytes.\n                        if (i >= arr.length - 1) {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        var n1 = arr[++i];\n                        var n2 = arr[++i];\n                        if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80) {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        b = (b & 0x0f) << 12 | (n1 & 0x3f) << 6 | n2 & 0x3f;\n                        min = 0x800;\n                    } else if (b < 0xf8) {\n                        // Need 3 more bytes.\n                        if (i >= arr.length - 2) {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        var n1 = arr[++i];\n                        var n2 = arr[++i];\n                        var n3 = arr[++i];\n                        if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80 || (n3 & 0xc0) !== 0x80) {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        b = (b & 0x0f) << 18 | (n1 & 0x3f) << 12 | (n2 & 0x3f) << 6 | n3 & 0x3f;\n                        min = 0x10000;\n                    } else {\n                        throw new Error(INVALID_UTF8);\n                    }\n                    if (b < min || b >= 0xd800 && b <= 0xdfff) {\n                        throw new Error(INVALID_UTF8);\n                    }\n                    if (b >= 0x10000) {\n                        // Surrogate pair.\n                        if (b > 0x10ffff) {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        b -= 0x10000;\n                        chars.push(String.fromCharCode(0xd800 | b >> 10));\n                        b = 0xdc00 | b & 0x3ff;\n                    }\n                }\n                chars.push(String.fromCharCode(b));\n            }\n            return chars.join(\"\");\n        }\n        exports.decode = decode;\n    /***/ },\n    /* 18 */ /***/ function(module1, exports, __nested_webpack_require_74115__) {\n        \"use strict\";\n        // API references:\n        //\n        // * https://html.spec.whatwg.org/multipage/comms.html#network\n        // * https://dom.spec.whatwg.org/#interface-eventtarget\n        // * https://dom.spec.whatwg.org/#interface-event\n        var util = __nested_webpack_require_74115__(0), driver = __nested_webpack_require_74115__(4), API = __nested_webpack_require_74115__(11);\n        var WebSocket = function(request, socket, body, protocols, options) {\n            options = options || {};\n            this._stream = socket;\n            this._driver = driver.http(request, {\n                maxLength: options.maxLength,\n                protocols: protocols\n            });\n            var self1 = this;\n            if (!this._stream || !this._stream.writable) return;\n            if (!this._stream.readable) return this._stream.end();\n            var catchup = function() {\n                self1._stream.removeListener(\"data\", catchup);\n            };\n            this._stream.on(\"data\", catchup);\n            API.call(this, options);\n            process.nextTick(function() {\n                self1._driver.start();\n                self1._driver.io.write(body);\n            });\n        };\n        util.inherits(WebSocket, API);\n        WebSocket.isWebSocket = function(request) {\n            return driver.isWebSocket(request);\n        };\n        WebSocket.validateOptions = function(options, validKeys) {\n            driver.validateOptions(options, validKeys);\n        };\n        WebSocket.WebSocket = WebSocket;\n        WebSocket.Client = __nested_webpack_require_74115__(39);\n        WebSocket.EventSource = __nested_webpack_require_74115__(42);\n        module1.exports = WebSocket;\n    /***/ },\n    /* 19 */ /***/ function(module1, exports, __nested_webpack_require_75843__) {\n        /**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @license MIT\n */ var Url = __nested_webpack_require_75843__(6);\n        var spawn = __nested_webpack_require_75843__(43).spawn;\n        var fs = __nested_webpack_require_75843__(44);\n        exports.XMLHttpRequest = function() {\n            \"use strict\";\n            /**\n   * Private variables\n   */ var self1 = this;\n            var http = __nested_webpack_require_75843__(45);\n            var https = __nested_webpack_require_75843__(46);\n            // Holds http.js objects\n            var request;\n            var response;\n            // Request settings\n            var settings = {};\n            // Disable header blacklist.\n            // Not part of XHR specs.\n            var disableHeaderCheck = false;\n            // Set some default headers\n            var defaultHeaders = {\n                \"User-Agent\": \"node-XMLHttpRequest\",\n                \"Accept\": \"*/*\"\n            };\n            var headers = {};\n            var headersCase = {};\n            // These headers are not user setable.\n            // The following are allowed but banned in the spec:\n            // * user-agent\n            var forbiddenRequestHeaders = [\n                \"accept-charset\",\n                \"accept-encoding\",\n                \"access-control-request-headers\",\n                \"access-control-request-method\",\n                \"connection\",\n                \"content-length\",\n                \"content-transfer-encoding\",\n                \"cookie\",\n                \"cookie2\",\n                \"date\",\n                \"expect\",\n                \"host\",\n                \"keep-alive\",\n                \"origin\",\n                \"referer\",\n                \"te\",\n                \"trailer\",\n                \"transfer-encoding\",\n                \"upgrade\",\n                \"via\"\n            ];\n            // These request methods are not allowed\n            var forbiddenRequestMethods = [\n                \"TRACE\",\n                \"TRACK\",\n                \"CONNECT\"\n            ];\n            // Send flag\n            var sendFlag = false;\n            // Error flag, used when errors occur or abort is called\n            var errorFlag = false;\n            // Event listeners\n            var listeners = {};\n            /**\n   * Constants\n   */ this.UNSENT = 0;\n            this.OPENED = 1;\n            this.HEADERS_RECEIVED = 2;\n            this.LOADING = 3;\n            this.DONE = 4;\n            /**\n   * Public vars\n   */ // Current state\n            this.readyState = this.UNSENT;\n            // default ready state change handler in case one is not set or is set late\n            this.onreadystatechange = null;\n            // Result & response\n            this.responseText = \"\";\n            this.responseXML = \"\";\n            this.status = null;\n            this.statusText = null;\n            // Whether cross-site Access-Control requests should be made using\n            // credentials such as cookies or authorization headers\n            this.withCredentials = false;\n            /**\n   * Private methods\n   */ /**\n   * Check if the specified header is allowed.\n   *\n   * @param string header Header to validate\n   * @return boolean False if not allowed, otherwise true\n   */ var isAllowedHttpHeader = function(header) {\n                return disableHeaderCheck || header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1;\n            };\n            /**\n   * Check if the specified method is allowed.\n   *\n   * @param string method Request method to validate\n   * @return boolean False if not allowed, otherwise true\n   */ var isAllowedHttpMethod = function(method) {\n                return method && forbiddenRequestMethods.indexOf(method) === -1;\n            };\n            /**\n   * Public methods\n   */ /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param string method Connection method (eg GET, POST)\n   * @param string url URL for the connection.\n   * @param boolean async Asynchronous connection. Default is true.\n   * @param string user Username for basic authentication (optional)\n   * @param string password Password for basic authentication (optional)\n   */ this.open = function(method, url, async, user, password) {\n                this.abort();\n                errorFlag = false;\n                // Check for valid request method\n                if (!isAllowedHttpMethod(method)) {\n                    throw new Error(\"SecurityError: Request method not allowed\");\n                }\n                settings = {\n                    \"method\": method,\n                    \"url\": url.toString(),\n                    \"async\": typeof async !== \"boolean\" ? true : async,\n                    \"user\": user || null,\n                    \"password\": password || null\n                };\n                setState(this.OPENED);\n            };\n            /**\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\n   * This does not conform to the W3C spec.\n   *\n   * @param boolean state Enable or disable header checking.\n   */ this.setDisableHeaderCheck = function(state) {\n                disableHeaderCheck = state;\n            };\n            /**\n   * Sets a header for the request or appends the value if one is already set.\n   *\n   * @param string header Header name\n   * @param string value Header value\n   */ this.setRequestHeader = function(header, value) {\n                if (this.readyState !== this.OPENED) {\n                    throw new Error(\"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\");\n                }\n                if (!isAllowedHttpHeader(header)) {\n                    console.warn('Refused to set unsafe header \"' + header + '\"');\n                    return;\n                }\n                if (sendFlag) {\n                    throw new Error(\"INVALID_STATE_ERR: send flag is true\");\n                }\n                header = headersCase[header.toLowerCase()] || header;\n                headersCase[header.toLowerCase()] = header;\n                headers[header] = headers[header] ? headers[header] + \", \" + value : value;\n            };\n            /**\n   * Gets a header from the server response.\n   *\n   * @param string header Name of header to get.\n   * @return string Text of the header or null if it doesn't exist.\n   */ this.getResponseHeader = function(header) {\n                if (typeof header === \"string\" && this.readyState > this.OPENED && response && response.headers && response.headers[header.toLowerCase()] && !errorFlag) {\n                    return response.headers[header.toLowerCase()];\n                }\n                return null;\n            };\n            /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */ this.getAllResponseHeaders = function() {\n                if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n                    return \"\";\n                }\n                var result = \"\";\n                for(var i in response.headers){\n                    // Cookie headers are excluded\n                    if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\n                        result += i + \": \" + response.headers[i] + \"\\r\\n\";\n                    }\n                }\n                return result.substr(0, result.length - 2);\n            };\n            /**\n   * Gets a request header\n   *\n   * @param string name Name of header to get\n   * @return string Returns the request header or empty string if not set\n   */ this.getRequestHeader = function(name) {\n                if (typeof name === \"string\" && headersCase[name.toLowerCase()]) {\n                    return headers[headersCase[name.toLowerCase()]];\n                }\n                return \"\";\n            };\n            /**\n   * Sends the request to the server.\n   *\n   * @param string data Optional data to send as request body.\n   */ this.send = function(data) {\n                if (this.readyState !== this.OPENED) {\n                    throw new Error(\"INVALID_STATE_ERR: connection must be opened before send() is called\");\n                }\n                if (sendFlag) {\n                    throw new Error(\"INVALID_STATE_ERR: send has already been called\");\n                }\n                var ssl = false, local = false;\n                var url = Url.parse(settings.url);\n                var host;\n                // Determine the server\n                switch(url.protocol){\n                    case \"https:\":\n                        ssl = true;\n                    // SSL & non-SSL both need host, no break here.\n                    case \"http:\":\n                        host = url.hostname;\n                        break;\n                    case \"file:\":\n                        local = true;\n                        break;\n                    case undefined:\n                    case null:\n                    case \"\":\n                        host = \"localhost\";\n                        break;\n                    default:\n                        throw new Error(\"Protocol not supported.\");\n                }\n                // Load files off the local filesystem (file://)\n                if (local) {\n                    if (settings.method !== \"GET\") {\n                        throw new Error(\"XMLHttpRequest: Only GET method is supported\");\n                    }\n                    if (settings.async) {\n                        fs.readFile(url.pathname, \"utf8\", function(error, data) {\n                            if (error) {\n                                self1.handleError(error);\n                            } else {\n                                self1.status = 200;\n                                self1.responseText = data;\n                                setState(self1.DONE);\n                            }\n                        });\n                    } else {\n                        try {\n                            this.responseText = fs.readFileSync(url.pathname, \"utf8\");\n                            this.status = 200;\n                            setState(self1.DONE);\n                        } catch (e) {\n                            this.handleError(e);\n                        }\n                    }\n                    return;\n                }\n                // Default to port 80. If accessing localhost on another port be sure\n                // to use http://localhost:port/path\n                var port = url.port || (ssl ? 443 : 80);\n                // Add query string if one is used\n                var uri = url.pathname + (url.search ? url.search : \"\");\n                // Set the defaults if they haven't been set\n                for(var name in defaultHeaders){\n                    if (!headersCase[name.toLowerCase()]) {\n                        headers[name] = defaultHeaders[name];\n                    }\n                }\n                // Set the Host header or the server may reject the request\n                headers.Host = host;\n                if (!(ssl && port === 443 || port === 80)) {\n                    headers.Host += \":\" + url.port;\n                }\n                // Set Basic Auth if necessary\n                if (settings.user) {\n                    if (typeof settings.password === \"undefined\") {\n                        settings.password = \"\";\n                    }\n                    var authBuf = new Buffer(settings.user + \":\" + settings.password);\n                    headers.Authorization = \"Basic \" + authBuf.toString(\"base64\");\n                }\n                // Set content length header\n                if (settings.method === \"GET\" || settings.method === \"HEAD\") {\n                    data = null;\n                } else if (data) {\n                    headers[\"Content-Length\"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\n                    if (!headers[\"Content-Type\"]) {\n                        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n                    }\n                } else if (settings.method === \"POST\") {\n                    // For a post with no data set Content-Length: 0.\n                    // This is required by buggy servers that don't meet the specs.\n                    headers[\"Content-Length\"] = 0;\n                }\n                var options = {\n                    host: host,\n                    port: port,\n                    path: uri,\n                    method: settings.method,\n                    headers: headers,\n                    agent: false,\n                    withCredentials: self1.withCredentials\n                };\n                // Reset error flag\n                errorFlag = false;\n                // Handle async requests\n                if (settings.async) {\n                    // Use the proper protocol\n                    var doRequest = ssl ? https.request : http.request;\n                    // Request is being sent, set send flag\n                    sendFlag = true;\n                    // As per spec, this is called here for historical reasons.\n                    self1.dispatchEvent(\"readystatechange\");\n                    // Handler for the response\n                    var responseHandler = function responseHandler(resp) {\n                        // Set response var to the response we got back\n                        // This is so it remains accessable outside this scope\n                        response = resp;\n                        // Check for redirect\n                        // @TODO Prevent looped redirects\n                        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\n                            // Change URL to the redirect location\n                            settings.url = response.headers.location;\n                            var url = Url.parse(settings.url);\n                            // Set host var in case it's used later\n                            host = url.hostname;\n                            // Options for the new request\n                            var newOptions = {\n                                hostname: url.hostname,\n                                port: url.port,\n                                path: url.path,\n                                method: response.statusCode === 303 ? \"GET\" : settings.method,\n                                headers: headers,\n                                withCredentials: self1.withCredentials\n                            };\n                            // Issue the new request\n                            request = doRequest(newOptions, responseHandler).on(\"error\", errorHandler);\n                            request.end();\n                            // @TODO Check if an XHR event needs to be fired here\n                            return;\n                        }\n                        response.setEncoding(\"utf8\");\n                        setState(self1.HEADERS_RECEIVED);\n                        self1.status = response.statusCode;\n                        response.on(\"data\", function(chunk) {\n                            // Make sure there's some data\n                            if (chunk) {\n                                self1.responseText += chunk;\n                            }\n                            // Don't emit state changes if the connection has been aborted.\n                            if (sendFlag) {\n                                setState(self1.LOADING);\n                            }\n                        });\n                        response.on(\"end\", function() {\n                            if (sendFlag) {\n                                // Discard the end event if the connection has been aborted\n                                setState(self1.DONE);\n                                sendFlag = false;\n                            }\n                        });\n                        response.on(\"error\", function(error) {\n                            self1.handleError(error);\n                        });\n                    };\n                    // Error handler for the request\n                    var errorHandler = function errorHandler(error) {\n                        self1.handleError(error);\n                    };\n                    // Create the request\n                    request = doRequest(options, responseHandler).on(\"error\", errorHandler);\n                    // Node 0.4 and later won't accept empty data. Make sure it's needed.\n                    if (data) {\n                        request.write(data);\n                    }\n                    request.end();\n                    self1.dispatchEvent(\"loadstart\");\n                } else {\n                    // Create a temporary file for communication with the other Node process\n                    var contentFile = \".node-xmlhttprequest-content-\" + process.pid;\n                    var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\n                    fs.writeFileSync(syncFile, \"\", \"utf8\");\n                    // The async request the other Node process executes\n                    var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\" + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\" + \"var options = \" + JSON.stringify(options) + \";\" + \"var responseText = '';\" + \"var req = doRequest(options, function(response) {\" + \"response.setEncoding('utf8');\" + \"response.on('data', function(chunk) {\" + \"  responseText += chunk;\" + \"});\" + \"response.on('end', function() {\" + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + \"response.on('error', function(error) {\" + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: error}), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + \"}).on('error', function(error) {\" + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: error}), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + (data ? \"req.write('\" + JSON.stringify(data).slice(1, -1).replace(/'/g, \"\\\\'\") + \"');\" : \"\") + \"req.end();\";\n                    // Start the other Node Process, executing this string\n                    var syncProc = spawn(process.argv[0], [\n                        \"-e\",\n                        execString\n                    ]);\n                    while(fs.existsSync(syncFile)){\n                    // Wait while the sync file is empty\n                    }\n                    var resp = JSON.parse(fs.readFileSync(contentFile, \"utf8\"));\n                    // Kill the child process once the file has data\n                    syncProc.stdin.end();\n                    // Remove the temporary file\n                    fs.unlinkSync(contentFile);\n                    if (resp.err) {\n                        self1.handleError(resp.err);\n                    } else {\n                        response = resp.data;\n                        self1.status = resp.data.statusCode;\n                        self1.responseText = resp.data.text;\n                        setState(self1.DONE);\n                    }\n                }\n            };\n            /**\n   * Called when an error is encountered to deal with it.\n   */ this.handleError = function(error) {\n                this.status = 0;\n                this.statusText = error;\n                this.responseText = error.stack;\n                errorFlag = true;\n                setState(this.DONE);\n                this.dispatchEvent(\"error\");\n            };\n            /**\n   * Aborts a request.\n   */ this.abort = function() {\n                if (request) {\n                    request.abort();\n                    request = null;\n                }\n                headers = defaultHeaders;\n                this.status = 0;\n                this.responseText = \"\";\n                this.responseXML = \"\";\n                errorFlag = true;\n                if (this.readyState !== this.UNSENT && (this.readyState !== this.OPENED || sendFlag) && this.readyState !== this.DONE) {\n                    sendFlag = false;\n                    setState(this.DONE);\n                }\n                this.readyState = this.UNSENT;\n                this.dispatchEvent(\"abort\");\n            };\n            /**\n   * Adds an event listener. Preferred method of binding to events.\n   */ this.addEventListener = function(event, callback) {\n                if (!(event in listeners)) {\n                    listeners[event] = [];\n                }\n                // Currently allows duplicate callbacks. Should it?\n                listeners[event].push(callback);\n            };\n            /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */ this.removeEventListener = function(event, callback) {\n                if (event in listeners) {\n                    // Filter will return a new array with the callback removed\n                    listeners[event] = listeners[event].filter(function(ev) {\n                        return ev !== callback;\n                    });\n                }\n            };\n            /**\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\n   */ this.dispatchEvent = function(event) {\n                if (typeof self1[\"on\" + event] === \"function\") {\n                    self1[\"on\" + event]();\n                }\n                if (event in listeners) {\n                    for(var i = 0, len = listeners[event].length; i < len; i++){\n                        listeners[event][i].call(self1);\n                    }\n                }\n            };\n            /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param int state New state\n   */ var setState = function(state) {\n                if (state == self1.LOADING || self1.readyState !== state) {\n                    self1.readyState = state;\n                    if (settings.async || self1.readyState < self1.OPENED || self1.readyState === self1.DONE) {\n                        self1.dispatchEvent(\"readystatechange\");\n                    }\n                    if (self1.readyState === self1.DONE && !errorFlag) {\n                        self1.dispatchEvent(\"load\");\n                        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n                        self1.dispatchEvent(\"loadend\");\n                    }\n                }\n            };\n        };\n    /***/ },\n    /* 20 */ /***/ function(module1, exports, __nested_webpack_require_98684__) {\n        (function(nacl) {\n            \"use strict\";\n            // Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.\n            // Public domain.\n            //\n            // Implementation derived from TweetNaCl version 20140427.\n            // See for details: http://tweetnacl.cr.yp.to/\n            var gf = function(init) {\n                var i, r = new Float64Array(16);\n                if (init) for(i = 0; i < init.length; i++)r[i] = init[i];\n                return r;\n            };\n            //  Pluggable, initialized in high-level API below.\n            var randombytes = function() {\n                throw new Error(\"no PRNG\");\n            };\n            var _0 = new Uint8Array(16);\n            var _9 = new Uint8Array(32);\n            _9[0] = 9;\n            var gf0 = gf(), gf1 = gf([\n                1\n            ]), _121665 = gf([\n                0xdb41,\n                1\n            ]), D = gf([\n                0x78a3,\n                0x1359,\n                0x4dca,\n                0x75eb,\n                0xd8ab,\n                0x4141,\n                0x0a4d,\n                0x0070,\n                0xe898,\n                0x7779,\n                0x4079,\n                0x8cc7,\n                0xfe73,\n                0x2b6f,\n                0x6cee,\n                0x5203\n            ]), D2 = gf([\n                0xf159,\n                0x26b2,\n                0x9b94,\n                0xebd6,\n                0xb156,\n                0x8283,\n                0x149a,\n                0x00e0,\n                0xd130,\n                0xeef3,\n                0x80f2,\n                0x198e,\n                0xfce7,\n                0x56df,\n                0xd9dc,\n                0x2406\n            ]), X = gf([\n                0xd51a,\n                0x8f25,\n                0x2d60,\n                0xc956,\n                0xa7b2,\n                0x9525,\n                0xc760,\n                0x692c,\n                0xdc5c,\n                0xfdd6,\n                0xe231,\n                0xc0a4,\n                0x53fe,\n                0xcd6e,\n                0x36d3,\n                0x2169\n            ]), Y = gf([\n                0x6658,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666\n            ]), I = gf([\n                0xa0b0,\n                0x4a0e,\n                0x1b27,\n                0xc4ee,\n                0xe478,\n                0xad2f,\n                0x1806,\n                0x2f43,\n                0xd7a7,\n                0x3dfb,\n                0x0099,\n                0x2b4d,\n                0xdf0b,\n                0x4fc1,\n                0x2480,\n                0x2b83\n            ]);\n            function ts64(x, i, h, l) {\n                x[i] = h >> 24 & 0xff;\n                x[i + 1] = h >> 16 & 0xff;\n                x[i + 2] = h >> 8 & 0xff;\n                x[i + 3] = h & 0xff;\n                x[i + 4] = l >> 24 & 0xff;\n                x[i + 5] = l >> 16 & 0xff;\n                x[i + 6] = l >> 8 & 0xff;\n                x[i + 7] = l & 0xff;\n            }\n            function vn(x, xi, y, yi, n) {\n                var i, d = 0;\n                for(i = 0; i < n; i++)d |= x[xi + i] ^ y[yi + i];\n                return (1 & d - 1 >>> 8) - 1;\n            }\n            function crypto_verify_16(x, xi, y, yi) {\n                return vn(x, xi, y, yi, 16);\n            }\n            function crypto_verify_32(x, xi, y, yi) {\n                return vn(x, xi, y, yi, 32);\n            }\n            function core_salsa20(o, p, k, c) {\n                var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24, j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24, j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24, j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24, j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24, j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24, j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24, j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24, j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24, j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24, j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24, j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24, j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24, j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24, j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24, j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;\n                var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;\n                for(var i = 0; i < 20; i += 2){\n                    u = x0 + x12 | 0;\n                    x4 ^= u << 7 | u >>> 32 - 7;\n                    u = x4 + x0 | 0;\n                    x8 ^= u << 9 | u >>> 32 - 9;\n                    u = x8 + x4 | 0;\n                    x12 ^= u << 13 | u >>> 32 - 13;\n                    u = x12 + x8 | 0;\n                    x0 ^= u << 18 | u >>> 32 - 18;\n                    u = x5 + x1 | 0;\n                    x9 ^= u << 7 | u >>> 32 - 7;\n                    u = x9 + x5 | 0;\n                    x13 ^= u << 9 | u >>> 32 - 9;\n                    u = x13 + x9 | 0;\n                    x1 ^= u << 13 | u >>> 32 - 13;\n                    u = x1 + x13 | 0;\n                    x5 ^= u << 18 | u >>> 32 - 18;\n                    u = x10 + x6 | 0;\n                    x14 ^= u << 7 | u >>> 32 - 7;\n                    u = x14 + x10 | 0;\n                    x2 ^= u << 9 | u >>> 32 - 9;\n                    u = x2 + x14 | 0;\n                    x6 ^= u << 13 | u >>> 32 - 13;\n                    u = x6 + x2 | 0;\n                    x10 ^= u << 18 | u >>> 32 - 18;\n                    u = x15 + x11 | 0;\n                    x3 ^= u << 7 | u >>> 32 - 7;\n                    u = x3 + x15 | 0;\n                    x7 ^= u << 9 | u >>> 32 - 9;\n                    u = x7 + x3 | 0;\n                    x11 ^= u << 13 | u >>> 32 - 13;\n                    u = x11 + x7 | 0;\n                    x15 ^= u << 18 | u >>> 32 - 18;\n                    u = x0 + x3 | 0;\n                    x1 ^= u << 7 | u >>> 32 - 7;\n                    u = x1 + x0 | 0;\n                    x2 ^= u << 9 | u >>> 32 - 9;\n                    u = x2 + x1 | 0;\n                    x3 ^= u << 13 | u >>> 32 - 13;\n                    u = x3 + x2 | 0;\n                    x0 ^= u << 18 | u >>> 32 - 18;\n                    u = x5 + x4 | 0;\n                    x6 ^= u << 7 | u >>> 32 - 7;\n                    u = x6 + x5 | 0;\n                    x7 ^= u << 9 | u >>> 32 - 9;\n                    u = x7 + x6 | 0;\n                    x4 ^= u << 13 | u >>> 32 - 13;\n                    u = x4 + x7 | 0;\n                    x5 ^= u << 18 | u >>> 32 - 18;\n                    u = x10 + x9 | 0;\n                    x11 ^= u << 7 | u >>> 32 - 7;\n                    u = x11 + x10 | 0;\n                    x8 ^= u << 9 | u >>> 32 - 9;\n                    u = x8 + x11 | 0;\n                    x9 ^= u << 13 | u >>> 32 - 13;\n                    u = x9 + x8 | 0;\n                    x10 ^= u << 18 | u >>> 32 - 18;\n                    u = x15 + x14 | 0;\n                    x12 ^= u << 7 | u >>> 32 - 7;\n                    u = x12 + x15 | 0;\n                    x13 ^= u << 9 | u >>> 32 - 9;\n                    u = x13 + x12 | 0;\n                    x14 ^= u << 13 | u >>> 32 - 13;\n                    u = x14 + x13 | 0;\n                    x15 ^= u << 18 | u >>> 32 - 18;\n                }\n                x0 = x0 + j0 | 0;\n                x1 = x1 + j1 | 0;\n                x2 = x2 + j2 | 0;\n                x3 = x3 + j3 | 0;\n                x4 = x4 + j4 | 0;\n                x5 = x5 + j5 | 0;\n                x6 = x6 + j6 | 0;\n                x7 = x7 + j7 | 0;\n                x8 = x8 + j8 | 0;\n                x9 = x9 + j9 | 0;\n                x10 = x10 + j10 | 0;\n                x11 = x11 + j11 | 0;\n                x12 = x12 + j12 | 0;\n                x13 = x13 + j13 | 0;\n                x14 = x14 + j14 | 0;\n                x15 = x15 + j15 | 0;\n                o[0] = x0 >>> 0 & 0xff;\n                o[1] = x0 >>> 8 & 0xff;\n                o[2] = x0 >>> 16 & 0xff;\n                o[3] = x0 >>> 24 & 0xff;\n                o[4] = x1 >>> 0 & 0xff;\n                o[5] = x1 >>> 8 & 0xff;\n                o[6] = x1 >>> 16 & 0xff;\n                o[7] = x1 >>> 24 & 0xff;\n                o[8] = x2 >>> 0 & 0xff;\n                o[9] = x2 >>> 8 & 0xff;\n                o[10] = x2 >>> 16 & 0xff;\n                o[11] = x2 >>> 24 & 0xff;\n                o[12] = x3 >>> 0 & 0xff;\n                o[13] = x3 >>> 8 & 0xff;\n                o[14] = x3 >>> 16 & 0xff;\n                o[15] = x3 >>> 24 & 0xff;\n                o[16] = x4 >>> 0 & 0xff;\n                o[17] = x4 >>> 8 & 0xff;\n                o[18] = x4 >>> 16 & 0xff;\n                o[19] = x4 >>> 24 & 0xff;\n                o[20] = x5 >>> 0 & 0xff;\n                o[21] = x5 >>> 8 & 0xff;\n                o[22] = x5 >>> 16 & 0xff;\n                o[23] = x5 >>> 24 & 0xff;\n                o[24] = x6 >>> 0 & 0xff;\n                o[25] = x6 >>> 8 & 0xff;\n                o[26] = x6 >>> 16 & 0xff;\n                o[27] = x6 >>> 24 & 0xff;\n                o[28] = x7 >>> 0 & 0xff;\n                o[29] = x7 >>> 8 & 0xff;\n                o[30] = x7 >>> 16 & 0xff;\n                o[31] = x7 >>> 24 & 0xff;\n                o[32] = x8 >>> 0 & 0xff;\n                o[33] = x8 >>> 8 & 0xff;\n                o[34] = x8 >>> 16 & 0xff;\n                o[35] = x8 >>> 24 & 0xff;\n                o[36] = x9 >>> 0 & 0xff;\n                o[37] = x9 >>> 8 & 0xff;\n                o[38] = x9 >>> 16 & 0xff;\n                o[39] = x9 >>> 24 & 0xff;\n                o[40] = x10 >>> 0 & 0xff;\n                o[41] = x10 >>> 8 & 0xff;\n                o[42] = x10 >>> 16 & 0xff;\n                o[43] = x10 >>> 24 & 0xff;\n                o[44] = x11 >>> 0 & 0xff;\n                o[45] = x11 >>> 8 & 0xff;\n                o[46] = x11 >>> 16 & 0xff;\n                o[47] = x11 >>> 24 & 0xff;\n                o[48] = x12 >>> 0 & 0xff;\n                o[49] = x12 >>> 8 & 0xff;\n                o[50] = x12 >>> 16 & 0xff;\n                o[51] = x12 >>> 24 & 0xff;\n                o[52] = x13 >>> 0 & 0xff;\n                o[53] = x13 >>> 8 & 0xff;\n                o[54] = x13 >>> 16 & 0xff;\n                o[55] = x13 >>> 24 & 0xff;\n                o[56] = x14 >>> 0 & 0xff;\n                o[57] = x14 >>> 8 & 0xff;\n                o[58] = x14 >>> 16 & 0xff;\n                o[59] = x14 >>> 24 & 0xff;\n                o[60] = x15 >>> 0 & 0xff;\n                o[61] = x15 >>> 8 & 0xff;\n                o[62] = x15 >>> 16 & 0xff;\n                o[63] = x15 >>> 24 & 0xff;\n            }\n            function core_hsalsa20(o, p, k, c) {\n                var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24, j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24, j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24, j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24, j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24, j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24, j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24, j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24, j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24, j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24, j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24, j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24, j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24, j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24, j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24, j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;\n                var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;\n                for(var i = 0; i < 20; i += 2){\n                    u = x0 + x12 | 0;\n                    x4 ^= u << 7 | u >>> 32 - 7;\n                    u = x4 + x0 | 0;\n                    x8 ^= u << 9 | u >>> 32 - 9;\n                    u = x8 + x4 | 0;\n                    x12 ^= u << 13 | u >>> 32 - 13;\n                    u = x12 + x8 | 0;\n                    x0 ^= u << 18 | u >>> 32 - 18;\n                    u = x5 + x1 | 0;\n                    x9 ^= u << 7 | u >>> 32 - 7;\n                    u = x9 + x5 | 0;\n                    x13 ^= u << 9 | u >>> 32 - 9;\n                    u = x13 + x9 | 0;\n                    x1 ^= u << 13 | u >>> 32 - 13;\n                    u = x1 + x13 | 0;\n                    x5 ^= u << 18 | u >>> 32 - 18;\n                    u = x10 + x6 | 0;\n                    x14 ^= u << 7 | u >>> 32 - 7;\n                    u = x14 + x10 | 0;\n                    x2 ^= u << 9 | u >>> 32 - 9;\n                    u = x2 + x14 | 0;\n                    x6 ^= u << 13 | u >>> 32 - 13;\n                    u = x6 + x2 | 0;\n                    x10 ^= u << 18 | u >>> 32 - 18;\n                    u = x15 + x11 | 0;\n                    x3 ^= u << 7 | u >>> 32 - 7;\n                    u = x3 + x15 | 0;\n                    x7 ^= u << 9 | u >>> 32 - 9;\n                    u = x7 + x3 | 0;\n                    x11 ^= u << 13 | u >>> 32 - 13;\n                    u = x11 + x7 | 0;\n                    x15 ^= u << 18 | u >>> 32 - 18;\n                    u = x0 + x3 | 0;\n                    x1 ^= u << 7 | u >>> 32 - 7;\n                    u = x1 + x0 | 0;\n                    x2 ^= u << 9 | u >>> 32 - 9;\n                    u = x2 + x1 | 0;\n                    x3 ^= u << 13 | u >>> 32 - 13;\n                    u = x3 + x2 | 0;\n                    x0 ^= u << 18 | u >>> 32 - 18;\n                    u = x5 + x4 | 0;\n                    x6 ^= u << 7 | u >>> 32 - 7;\n                    u = x6 + x5 | 0;\n                    x7 ^= u << 9 | u >>> 32 - 9;\n                    u = x7 + x6 | 0;\n                    x4 ^= u << 13 | u >>> 32 - 13;\n                    u = x4 + x7 | 0;\n                    x5 ^= u << 18 | u >>> 32 - 18;\n                    u = x10 + x9 | 0;\n                    x11 ^= u << 7 | u >>> 32 - 7;\n                    u = x11 + x10 | 0;\n                    x8 ^= u << 9 | u >>> 32 - 9;\n                    u = x8 + x11 | 0;\n                    x9 ^= u << 13 | u >>> 32 - 13;\n                    u = x9 + x8 | 0;\n                    x10 ^= u << 18 | u >>> 32 - 18;\n                    u = x15 + x14 | 0;\n                    x12 ^= u << 7 | u >>> 32 - 7;\n                    u = x12 + x15 | 0;\n                    x13 ^= u << 9 | u >>> 32 - 9;\n                    u = x13 + x12 | 0;\n                    x14 ^= u << 13 | u >>> 32 - 13;\n                    u = x14 + x13 | 0;\n                    x15 ^= u << 18 | u >>> 32 - 18;\n                }\n                o[0] = x0 >>> 0 & 0xff;\n                o[1] = x0 >>> 8 & 0xff;\n                o[2] = x0 >>> 16 & 0xff;\n                o[3] = x0 >>> 24 & 0xff;\n                o[4] = x5 >>> 0 & 0xff;\n                o[5] = x5 >>> 8 & 0xff;\n                o[6] = x5 >>> 16 & 0xff;\n                o[7] = x5 >>> 24 & 0xff;\n                o[8] = x10 >>> 0 & 0xff;\n                o[9] = x10 >>> 8 & 0xff;\n                o[10] = x10 >>> 16 & 0xff;\n                o[11] = x10 >>> 24 & 0xff;\n                o[12] = x15 >>> 0 & 0xff;\n                o[13] = x15 >>> 8 & 0xff;\n                o[14] = x15 >>> 16 & 0xff;\n                o[15] = x15 >>> 24 & 0xff;\n                o[16] = x6 >>> 0 & 0xff;\n                o[17] = x6 >>> 8 & 0xff;\n                o[18] = x6 >>> 16 & 0xff;\n                o[19] = x6 >>> 24 & 0xff;\n                o[20] = x7 >>> 0 & 0xff;\n                o[21] = x7 >>> 8 & 0xff;\n                o[22] = x7 >>> 16 & 0xff;\n                o[23] = x7 >>> 24 & 0xff;\n                o[24] = x8 >>> 0 & 0xff;\n                o[25] = x8 >>> 8 & 0xff;\n                o[26] = x8 >>> 16 & 0xff;\n                o[27] = x8 >>> 24 & 0xff;\n                o[28] = x9 >>> 0 & 0xff;\n                o[29] = x9 >>> 8 & 0xff;\n                o[30] = x9 >>> 16 & 0xff;\n                o[31] = x9 >>> 24 & 0xff;\n            }\n            function crypto_core_salsa20(out, inp, k, c) {\n                core_salsa20(out, inp, k, c);\n            }\n            function crypto_core_hsalsa20(out, inp, k, c) {\n                core_hsalsa20(out, inp, k, c);\n            }\n            var sigma = new Uint8Array([\n                101,\n                120,\n                112,\n                97,\n                110,\n                100,\n                32,\n                51,\n                50,\n                45,\n                98,\n                121,\n                116,\n                101,\n                32,\n                107\n            ]);\n            // \"expand 32-byte k\"\n            function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {\n                var z = new Uint8Array(16), x = new Uint8Array(64);\n                var u, i;\n                for(i = 0; i < 16; i++)z[i] = 0;\n                for(i = 0; i < 8; i++)z[i] = n[i];\n                while(b >= 64){\n                    crypto_core_salsa20(x, z, k, sigma);\n                    for(i = 0; i < 64; i++)c[cpos + i] = m[mpos + i] ^ x[i];\n                    u = 1;\n                    for(i = 8; i < 16; i++){\n                        u = u + (z[i] & 0xff) | 0;\n                        z[i] = u & 0xff;\n                        u >>>= 8;\n                    }\n                    b -= 64;\n                    cpos += 64;\n                    mpos += 64;\n                }\n                if (b > 0) {\n                    crypto_core_salsa20(x, z, k, sigma);\n                    for(i = 0; i < b; i++)c[cpos + i] = m[mpos + i] ^ x[i];\n                }\n                return 0;\n            }\n            function crypto_stream_salsa20(c, cpos, b, n, k) {\n                var z = new Uint8Array(16), x = new Uint8Array(64);\n                var u, i;\n                for(i = 0; i < 16; i++)z[i] = 0;\n                for(i = 0; i < 8; i++)z[i] = n[i];\n                while(b >= 64){\n                    crypto_core_salsa20(x, z, k, sigma);\n                    for(i = 0; i < 64; i++)c[cpos + i] = x[i];\n                    u = 1;\n                    for(i = 8; i < 16; i++){\n                        u = u + (z[i] & 0xff) | 0;\n                        z[i] = u & 0xff;\n                        u >>>= 8;\n                    }\n                    b -= 64;\n                    cpos += 64;\n                }\n                if (b > 0) {\n                    crypto_core_salsa20(x, z, k, sigma);\n                    for(i = 0; i < b; i++)c[cpos + i] = x[i];\n                }\n                return 0;\n            }\n            function crypto_stream(c, cpos, d, n, k) {\n                var s = new Uint8Array(32);\n                crypto_core_hsalsa20(s, n, k, sigma);\n                var sn = new Uint8Array(8);\n                for(var i = 0; i < 8; i++)sn[i] = n[i + 16];\n                return crypto_stream_salsa20(c, cpos, d, sn, s);\n            }\n            function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {\n                var s = new Uint8Array(32);\n                crypto_core_hsalsa20(s, n, k, sigma);\n                var sn = new Uint8Array(8);\n                for(var i = 0; i < 8; i++)sn[i] = n[i + 16];\n                return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);\n            }\n            /*\n* Port of Andrew Moon's Poly1305-donna-16. Public domain.\n* https://github.com/floodyberry/poly1305-donna\n*/ var poly1305 = function(key) {\n                this.buffer = new Uint8Array(16);\n                this.r = new Uint16Array(10);\n                this.h = new Uint16Array(10);\n                this.pad = new Uint16Array(8);\n                this.leftover = 0;\n                this.fin = 0;\n                var t0, t1, t2, t3, t4, t5, t6, t7;\n                t0 = key[0] & 0xff | (key[1] & 0xff) << 8;\n                this.r[0] = t0 & 0x1fff;\n                t1 = key[2] & 0xff | (key[3] & 0xff) << 8;\n                this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;\n                t2 = key[4] & 0xff | (key[5] & 0xff) << 8;\n                this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;\n                t3 = key[6] & 0xff | (key[7] & 0xff) << 8;\n                this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;\n                t4 = key[8] & 0xff | (key[9] & 0xff) << 8;\n                this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;\n                this.r[5] = t4 >>> 1 & 0x1ffe;\n                t5 = key[10] & 0xff | (key[11] & 0xff) << 8;\n                this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;\n                t6 = key[12] & 0xff | (key[13] & 0xff) << 8;\n                this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;\n                t7 = key[14] & 0xff | (key[15] & 0xff) << 8;\n                this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;\n                this.r[9] = t7 >>> 5 & 0x007f;\n                this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;\n                this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;\n                this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;\n                this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;\n                this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;\n                this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;\n                this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;\n                this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;\n            };\n            poly1305.prototype.blocks = function(m, mpos, bytes) {\n                var hibit = this.fin ? 0 : 1 << 11;\n                var t0, t1, t2, t3, t4, t5, t6, t7, c;\n                var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;\n                var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];\n                var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];\n                while(bytes >= 16){\n                    t0 = m[mpos + 0] & 0xff | (m[mpos + 1] & 0xff) << 8;\n                    h0 += t0 & 0x1fff;\n                    t1 = m[mpos + 2] & 0xff | (m[mpos + 3] & 0xff) << 8;\n                    h1 += (t0 >>> 13 | t1 << 3) & 0x1fff;\n                    t2 = m[mpos + 4] & 0xff | (m[mpos + 5] & 0xff) << 8;\n                    h2 += (t1 >>> 10 | t2 << 6) & 0x1fff;\n                    t3 = m[mpos + 6] & 0xff | (m[mpos + 7] & 0xff) << 8;\n                    h3 += (t2 >>> 7 | t3 << 9) & 0x1fff;\n                    t4 = m[mpos + 8] & 0xff | (m[mpos + 9] & 0xff) << 8;\n                    h4 += (t3 >>> 4 | t4 << 12) & 0x1fff;\n                    h5 += t4 >>> 1 & 0x1fff;\n                    t5 = m[mpos + 10] & 0xff | (m[mpos + 11] & 0xff) << 8;\n                    h6 += (t4 >>> 14 | t5 << 2) & 0x1fff;\n                    t6 = m[mpos + 12] & 0xff | (m[mpos + 13] & 0xff) << 8;\n                    h7 += (t5 >>> 11 | t6 << 5) & 0x1fff;\n                    t7 = m[mpos + 14] & 0xff | (m[mpos + 15] & 0xff) << 8;\n                    h8 += (t6 >>> 8 | t7 << 8) & 0x1fff;\n                    h9 += t7 >>> 5 | hibit;\n                    c = 0;\n                    d0 = c;\n                    d0 += h0 * r0;\n                    d0 += h1 * (5 * r9);\n                    d0 += h2 * (5 * r8);\n                    d0 += h3 * (5 * r7);\n                    d0 += h4 * (5 * r6);\n                    c = d0 >>> 13;\n                    d0 &= 0x1fff;\n                    d0 += h5 * (5 * r5);\n                    d0 += h6 * (5 * r4);\n                    d0 += h7 * (5 * r3);\n                    d0 += h8 * (5 * r2);\n                    d0 += h9 * (5 * r1);\n                    c += d0 >>> 13;\n                    d0 &= 0x1fff;\n                    d1 = c;\n                    d1 += h0 * r1;\n                    d1 += h1 * r0;\n                    d1 += h2 * (5 * r9);\n                    d1 += h3 * (5 * r8);\n                    d1 += h4 * (5 * r7);\n                    c = d1 >>> 13;\n                    d1 &= 0x1fff;\n                    d1 += h5 * (5 * r6);\n                    d1 += h6 * (5 * r5);\n                    d1 += h7 * (5 * r4);\n                    d1 += h8 * (5 * r3);\n                    d1 += h9 * (5 * r2);\n                    c += d1 >>> 13;\n                    d1 &= 0x1fff;\n                    d2 = c;\n                    d2 += h0 * r2;\n                    d2 += h1 * r1;\n                    d2 += h2 * r0;\n                    d2 += h3 * (5 * r9);\n                    d2 += h4 * (5 * r8);\n                    c = d2 >>> 13;\n                    d2 &= 0x1fff;\n                    d2 += h5 * (5 * r7);\n                    d2 += h6 * (5 * r6);\n                    d2 += h7 * (5 * r5);\n                    d2 += h8 * (5 * r4);\n                    d2 += h9 * (5 * r3);\n                    c += d2 >>> 13;\n                    d2 &= 0x1fff;\n                    d3 = c;\n                    d3 += h0 * r3;\n                    d3 += h1 * r2;\n                    d3 += h2 * r1;\n                    d3 += h3 * r0;\n                    d3 += h4 * (5 * r9);\n                    c = d3 >>> 13;\n                    d3 &= 0x1fff;\n                    d3 += h5 * (5 * r8);\n                    d3 += h6 * (5 * r7);\n                    d3 += h7 * (5 * r6);\n                    d3 += h8 * (5 * r5);\n                    d3 += h9 * (5 * r4);\n                    c += d3 >>> 13;\n                    d3 &= 0x1fff;\n                    d4 = c;\n                    d4 += h0 * r4;\n                    d4 += h1 * r3;\n                    d4 += h2 * r2;\n                    d4 += h3 * r1;\n                    d4 += h4 * r0;\n                    c = d4 >>> 13;\n                    d4 &= 0x1fff;\n                    d4 += h5 * (5 * r9);\n                    d4 += h6 * (5 * r8);\n                    d4 += h7 * (5 * r7);\n                    d4 += h8 * (5 * r6);\n                    d4 += h9 * (5 * r5);\n                    c += d4 >>> 13;\n                    d4 &= 0x1fff;\n                    d5 = c;\n                    d5 += h0 * r5;\n                    d5 += h1 * r4;\n                    d5 += h2 * r3;\n                    d5 += h3 * r2;\n                    d5 += h4 * r1;\n                    c = d5 >>> 13;\n                    d5 &= 0x1fff;\n                    d5 += h5 * r0;\n                    d5 += h6 * (5 * r9);\n                    d5 += h7 * (5 * r8);\n                    d5 += h8 * (5 * r7);\n                    d5 += h9 * (5 * r6);\n                    c += d5 >>> 13;\n                    d5 &= 0x1fff;\n                    d6 = c;\n                    d6 += h0 * r6;\n                    d6 += h1 * r5;\n                    d6 += h2 * r4;\n                    d6 += h3 * r3;\n                    d6 += h4 * r2;\n                    c = d6 >>> 13;\n                    d6 &= 0x1fff;\n                    d6 += h5 * r1;\n                    d6 += h6 * r0;\n                    d6 += h7 * (5 * r9);\n                    d6 += h8 * (5 * r8);\n                    d6 += h9 * (5 * r7);\n                    c += d6 >>> 13;\n                    d6 &= 0x1fff;\n                    d7 = c;\n                    d7 += h0 * r7;\n                    d7 += h1 * r6;\n                    d7 += h2 * r5;\n                    d7 += h3 * r4;\n                    d7 += h4 * r3;\n                    c = d7 >>> 13;\n                    d7 &= 0x1fff;\n                    d7 += h5 * r2;\n                    d7 += h6 * r1;\n                    d7 += h7 * r0;\n                    d7 += h8 * (5 * r9);\n                    d7 += h9 * (5 * r8);\n                    c += d7 >>> 13;\n                    d7 &= 0x1fff;\n                    d8 = c;\n                    d8 += h0 * r8;\n                    d8 += h1 * r7;\n                    d8 += h2 * r6;\n                    d8 += h3 * r5;\n                    d8 += h4 * r4;\n                    c = d8 >>> 13;\n                    d8 &= 0x1fff;\n                    d8 += h5 * r3;\n                    d8 += h6 * r2;\n                    d8 += h7 * r1;\n                    d8 += h8 * r0;\n                    d8 += h9 * (5 * r9);\n                    c += d8 >>> 13;\n                    d8 &= 0x1fff;\n                    d9 = c;\n                    d9 += h0 * r9;\n                    d9 += h1 * r8;\n                    d9 += h2 * r7;\n                    d9 += h3 * r6;\n                    d9 += h4 * r5;\n                    c = d9 >>> 13;\n                    d9 &= 0x1fff;\n                    d9 += h5 * r4;\n                    d9 += h6 * r3;\n                    d9 += h7 * r2;\n                    d9 += h8 * r1;\n                    d9 += h9 * r0;\n                    c += d9 >>> 13;\n                    d9 &= 0x1fff;\n                    c = (c << 2) + c | 0;\n                    c = c + d0 | 0;\n                    d0 = c & 0x1fff;\n                    c = c >>> 13;\n                    d1 += c;\n                    h0 = d0;\n                    h1 = d1;\n                    h2 = d2;\n                    h3 = d3;\n                    h4 = d4;\n                    h5 = d5;\n                    h6 = d6;\n                    h7 = d7;\n                    h8 = d8;\n                    h9 = d9;\n                    mpos += 16;\n                    bytes -= 16;\n                }\n                this.h[0] = h0;\n                this.h[1] = h1;\n                this.h[2] = h2;\n                this.h[3] = h3;\n                this.h[4] = h4;\n                this.h[5] = h5;\n                this.h[6] = h6;\n                this.h[7] = h7;\n                this.h[8] = h8;\n                this.h[9] = h9;\n            };\n            poly1305.prototype.finish = function(mac, macpos) {\n                var g = new Uint16Array(10);\n                var c, mask, f, i;\n                if (this.leftover) {\n                    i = this.leftover;\n                    this.buffer[i++] = 1;\n                    for(; i < 16; i++)this.buffer[i] = 0;\n                    this.fin = 1;\n                    this.blocks(this.buffer, 0, 16);\n                }\n                c = this.h[1] >>> 13;\n                this.h[1] &= 0x1fff;\n                for(i = 2; i < 10; i++){\n                    this.h[i] += c;\n                    c = this.h[i] >>> 13;\n                    this.h[i] &= 0x1fff;\n                }\n                this.h[0] += c * 5;\n                c = this.h[0] >>> 13;\n                this.h[0] &= 0x1fff;\n                this.h[1] += c;\n                c = this.h[1] >>> 13;\n                this.h[1] &= 0x1fff;\n                this.h[2] += c;\n                g[0] = this.h[0] + 5;\n                c = g[0] >>> 13;\n                g[0] &= 0x1fff;\n                for(i = 1; i < 10; i++){\n                    g[i] = this.h[i] + c;\n                    c = g[i] >>> 13;\n                    g[i] &= 0x1fff;\n                }\n                g[9] -= 1 << 13;\n                mask = (c ^ 1) - 1;\n                for(i = 0; i < 10; i++)g[i] &= mask;\n                mask = ~mask;\n                for(i = 0; i < 10; i++)this.h[i] = this.h[i] & mask | g[i];\n                this.h[0] = (this.h[0] | this.h[1] << 13) & 0xffff;\n                this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 0xffff;\n                this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 0xffff;\n                this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 0xffff;\n                this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 0xffff;\n                this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 0xffff;\n                this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 0xffff;\n                this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 0xffff;\n                f = this.h[0] + this.pad[0];\n                this.h[0] = f & 0xffff;\n                for(i = 1; i < 8; i++){\n                    f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;\n                    this.h[i] = f & 0xffff;\n                }\n                mac[macpos + 0] = this.h[0] >>> 0 & 0xff;\n                mac[macpos + 1] = this.h[0] >>> 8 & 0xff;\n                mac[macpos + 2] = this.h[1] >>> 0 & 0xff;\n                mac[macpos + 3] = this.h[1] >>> 8 & 0xff;\n                mac[macpos + 4] = this.h[2] >>> 0 & 0xff;\n                mac[macpos + 5] = this.h[2] >>> 8 & 0xff;\n                mac[macpos + 6] = this.h[3] >>> 0 & 0xff;\n                mac[macpos + 7] = this.h[3] >>> 8 & 0xff;\n                mac[macpos + 8] = this.h[4] >>> 0 & 0xff;\n                mac[macpos + 9] = this.h[4] >>> 8 & 0xff;\n                mac[macpos + 10] = this.h[5] >>> 0 & 0xff;\n                mac[macpos + 11] = this.h[5] >>> 8 & 0xff;\n                mac[macpos + 12] = this.h[6] >>> 0 & 0xff;\n                mac[macpos + 13] = this.h[6] >>> 8 & 0xff;\n                mac[macpos + 14] = this.h[7] >>> 0 & 0xff;\n                mac[macpos + 15] = this.h[7] >>> 8 & 0xff;\n            };\n            poly1305.prototype.update = function(m, mpos, bytes) {\n                var i, want;\n                if (this.leftover) {\n                    want = 16 - this.leftover;\n                    if (want > bytes) want = bytes;\n                    for(i = 0; i < want; i++)this.buffer[this.leftover + i] = m[mpos + i];\n                    bytes -= want;\n                    mpos += want;\n                    this.leftover += want;\n                    if (this.leftover < 16) return;\n                    this.blocks(this.buffer, 0, 16);\n                    this.leftover = 0;\n                }\n                if (bytes >= 16) {\n                    want = bytes - bytes % 16;\n                    this.blocks(m, mpos, want);\n                    mpos += want;\n                    bytes -= want;\n                }\n                if (bytes) {\n                    for(i = 0; i < bytes; i++)this.buffer[this.leftover + i] = m[mpos + i];\n                    this.leftover += bytes;\n                }\n            };\n            function crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n                var s = new poly1305(k);\n                s.update(m, mpos, n);\n                s.finish(out, outpos);\n                return 0;\n            }\n            function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n                var x = new Uint8Array(16);\n                crypto_onetimeauth(x, 0, m, mpos, n, k);\n                return crypto_verify_16(h, hpos, x, 0);\n            }\n            function crypto_secretbox(c, m, d, n, k) {\n                var i;\n                if (d < 32) return -1;\n                crypto_stream_xor(c, 0, m, 0, d, n, k);\n                crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n                for(i = 0; i < 16; i++)c[i] = 0;\n                return 0;\n            }\n            function crypto_secretbox_open(m, c, d, n, k) {\n                var i;\n                var x = new Uint8Array(32);\n                if (d < 32) return -1;\n                crypto_stream(x, 0, 32, n, k);\n                if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;\n                crypto_stream_xor(m, 0, c, 0, d, n, k);\n                for(i = 0; i < 32; i++)m[i] = 0;\n                return 0;\n            }\n            function set25519(r, a) {\n                var i;\n                for(i = 0; i < 16; i++)r[i] = a[i] | 0;\n            }\n            function car25519(o) {\n                var i, v, c = 1;\n                for(i = 0; i < 16; i++){\n                    v = o[i] + c + 65535;\n                    c = Math.floor(v / 65536);\n                    o[i] = v - c * 65536;\n                }\n                o[0] += c - 1 + 37 * (c - 1);\n            }\n            function sel25519(p, q, b) {\n                var t, c = ~(b - 1);\n                for(var i = 0; i < 16; i++){\n                    t = c & (p[i] ^ q[i]);\n                    p[i] ^= t;\n                    q[i] ^= t;\n                }\n            }\n            function pack25519(o, n) {\n                var i, j, b;\n                var m = gf(), t = gf();\n                for(i = 0; i < 16; i++)t[i] = n[i];\n                car25519(t);\n                car25519(t);\n                car25519(t);\n                for(j = 0; j < 2; j++){\n                    m[0] = t[0] - 0xffed;\n                    for(i = 1; i < 15; i++){\n                        m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);\n                        m[i - 1] &= 0xffff;\n                    }\n                    m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);\n                    b = m[15] >> 16 & 1;\n                    m[14] &= 0xffff;\n                    sel25519(t, m, 1 - b);\n                }\n                for(i = 0; i < 16; i++){\n                    o[2 * i] = t[i] & 0xff;\n                    o[2 * i + 1] = t[i] >> 8;\n                }\n            }\n            function neq25519(a, b) {\n                var c = new Uint8Array(32), d = new Uint8Array(32);\n                pack25519(c, a);\n                pack25519(d, b);\n                return crypto_verify_32(c, 0, d, 0);\n            }\n            function par25519(a) {\n                var d = new Uint8Array(32);\n                pack25519(d, a);\n                return d[0] & 1;\n            }\n            function unpack25519(o, n) {\n                var i;\n                for(i = 0; i < 16; i++)o[i] = n[2 * i] + (n[2 * i + 1] << 8);\n                o[15] &= 0x7fff;\n            }\n            function A(o, a, b) {\n                for(var i = 0; i < 16; i++)o[i] = a[i] + b[i];\n            }\n            function Z(o, a, b) {\n                for(var i = 0; i < 16; i++)o[i] = a[i] - b[i];\n            }\n            function M(o, a, b) {\n                var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];\n                v = a[0];\n                t0 += v * b0;\n                t1 += v * b1;\n                t2 += v * b2;\n                t3 += v * b3;\n                t4 += v * b4;\n                t5 += v * b5;\n                t6 += v * b6;\n                t7 += v * b7;\n                t8 += v * b8;\n                t9 += v * b9;\n                t10 += v * b10;\n                t11 += v * b11;\n                t12 += v * b12;\n                t13 += v * b13;\n                t14 += v * b14;\n                t15 += v * b15;\n                v = a[1];\n                t1 += v * b0;\n                t2 += v * b1;\n                t3 += v * b2;\n                t4 += v * b3;\n                t5 += v * b4;\n                t6 += v * b5;\n                t7 += v * b6;\n                t8 += v * b7;\n                t9 += v * b8;\n                t10 += v * b9;\n                t11 += v * b10;\n                t12 += v * b11;\n                t13 += v * b12;\n                t14 += v * b13;\n                t15 += v * b14;\n                t16 += v * b15;\n                v = a[2];\n                t2 += v * b0;\n                t3 += v * b1;\n                t4 += v * b2;\n                t5 += v * b3;\n                t6 += v * b4;\n                t7 += v * b5;\n                t8 += v * b6;\n                t9 += v * b7;\n                t10 += v * b8;\n                t11 += v * b9;\n                t12 += v * b10;\n                t13 += v * b11;\n                t14 += v * b12;\n                t15 += v * b13;\n                t16 += v * b14;\n                t17 += v * b15;\n                v = a[3];\n                t3 += v * b0;\n                t4 += v * b1;\n                t5 += v * b2;\n                t6 += v * b3;\n                t7 += v * b4;\n                t8 += v * b5;\n                t9 += v * b6;\n                t10 += v * b7;\n                t11 += v * b8;\n                t12 += v * b9;\n                t13 += v * b10;\n                t14 += v * b11;\n                t15 += v * b12;\n                t16 += v * b13;\n                t17 += v * b14;\n                t18 += v * b15;\n                v = a[4];\n                t4 += v * b0;\n                t5 += v * b1;\n                t6 += v * b2;\n                t7 += v * b3;\n                t8 += v * b4;\n                t9 += v * b5;\n                t10 += v * b6;\n                t11 += v * b7;\n                t12 += v * b8;\n                t13 += v * b9;\n                t14 += v * b10;\n                t15 += v * b11;\n                t16 += v * b12;\n                t17 += v * b13;\n                t18 += v * b14;\n                t19 += v * b15;\n                v = a[5];\n                t5 += v * b0;\n                t6 += v * b1;\n                t7 += v * b2;\n                t8 += v * b3;\n                t9 += v * b4;\n                t10 += v * b5;\n                t11 += v * b6;\n                t12 += v * b7;\n                t13 += v * b8;\n                t14 += v * b9;\n                t15 += v * b10;\n                t16 += v * b11;\n                t17 += v * b12;\n                t18 += v * b13;\n                t19 += v * b14;\n                t20 += v * b15;\n                v = a[6];\n                t6 += v * b0;\n                t7 += v * b1;\n                t8 += v * b2;\n                t9 += v * b3;\n                t10 += v * b4;\n                t11 += v * b5;\n                t12 += v * b6;\n                t13 += v * b7;\n                t14 += v * b8;\n                t15 += v * b9;\n                t16 += v * b10;\n                t17 += v * b11;\n                t18 += v * b12;\n                t19 += v * b13;\n                t20 += v * b14;\n                t21 += v * b15;\n                v = a[7];\n                t7 += v * b0;\n                t8 += v * b1;\n                t9 += v * b2;\n                t10 += v * b3;\n                t11 += v * b4;\n                t12 += v * b5;\n                t13 += v * b6;\n                t14 += v * b7;\n                t15 += v * b8;\n                t16 += v * b9;\n                t17 += v * b10;\n                t18 += v * b11;\n                t19 += v * b12;\n                t20 += v * b13;\n                t21 += v * b14;\n                t22 += v * b15;\n                v = a[8];\n                t8 += v * b0;\n                t9 += v * b1;\n                t10 += v * b2;\n                t11 += v * b3;\n                t12 += v * b4;\n                t13 += v * b5;\n                t14 += v * b6;\n                t15 += v * b7;\n                t16 += v * b8;\n                t17 += v * b9;\n                t18 += v * b10;\n                t19 += v * b11;\n                t20 += v * b12;\n                t21 += v * b13;\n                t22 += v * b14;\n                t23 += v * b15;\n                v = a[9];\n                t9 += v * b0;\n                t10 += v * b1;\n                t11 += v * b2;\n                t12 += v * b3;\n                t13 += v * b4;\n                t14 += v * b5;\n                t15 += v * b6;\n                t16 += v * b7;\n                t17 += v * b8;\n                t18 += v * b9;\n                t19 += v * b10;\n                t20 += v * b11;\n                t21 += v * b12;\n                t22 += v * b13;\n                t23 += v * b14;\n                t24 += v * b15;\n                v = a[10];\n                t10 += v * b0;\n                t11 += v * b1;\n                t12 += v * b2;\n                t13 += v * b3;\n                t14 += v * b4;\n                t15 += v * b5;\n                t16 += v * b6;\n                t17 += v * b7;\n                t18 += v * b8;\n                t19 += v * b9;\n                t20 += v * b10;\n                t21 += v * b11;\n                t22 += v * b12;\n                t23 += v * b13;\n                t24 += v * b14;\n                t25 += v * b15;\n                v = a[11];\n                t11 += v * b0;\n                t12 += v * b1;\n                t13 += v * b2;\n                t14 += v * b3;\n                t15 += v * b4;\n                t16 += v * b5;\n                t17 += v * b6;\n                t18 += v * b7;\n                t19 += v * b8;\n                t20 += v * b9;\n                t21 += v * b10;\n                t22 += v * b11;\n                t23 += v * b12;\n                t24 += v * b13;\n                t25 += v * b14;\n                t26 += v * b15;\n                v = a[12];\n                t12 += v * b0;\n                t13 += v * b1;\n                t14 += v * b2;\n                t15 += v * b3;\n                t16 += v * b4;\n                t17 += v * b5;\n                t18 += v * b6;\n                t19 += v * b7;\n                t20 += v * b8;\n                t21 += v * b9;\n                t22 += v * b10;\n                t23 += v * b11;\n                t24 += v * b12;\n                t25 += v * b13;\n                t26 += v * b14;\n                t27 += v * b15;\n                v = a[13];\n                t13 += v * b0;\n                t14 += v * b1;\n                t15 += v * b2;\n                t16 += v * b3;\n                t17 += v * b4;\n                t18 += v * b5;\n                t19 += v * b6;\n                t20 += v * b7;\n                t21 += v * b8;\n                t22 += v * b9;\n                t23 += v * b10;\n                t24 += v * b11;\n                t25 += v * b12;\n                t26 += v * b13;\n                t27 += v * b14;\n                t28 += v * b15;\n                v = a[14];\n                t14 += v * b0;\n                t15 += v * b1;\n                t16 += v * b2;\n                t17 += v * b3;\n                t18 += v * b4;\n                t19 += v * b5;\n                t20 += v * b6;\n                t21 += v * b7;\n                t22 += v * b8;\n                t23 += v * b9;\n                t24 += v * b10;\n                t25 += v * b11;\n                t26 += v * b12;\n                t27 += v * b13;\n                t28 += v * b14;\n                t29 += v * b15;\n                v = a[15];\n                t15 += v * b0;\n                t16 += v * b1;\n                t17 += v * b2;\n                t18 += v * b3;\n                t19 += v * b4;\n                t20 += v * b5;\n                t21 += v * b6;\n                t22 += v * b7;\n                t23 += v * b8;\n                t24 += v * b9;\n                t25 += v * b10;\n                t26 += v * b11;\n                t27 += v * b12;\n                t28 += v * b13;\n                t29 += v * b14;\n                t30 += v * b15;\n                t0 += 38 * t16;\n                t1 += 38 * t17;\n                t2 += 38 * t18;\n                t3 += 38 * t19;\n                t4 += 38 * t20;\n                t5 += 38 * t21;\n                t6 += 38 * t22;\n                t7 += 38 * t23;\n                t8 += 38 * t24;\n                t9 += 38 * t25;\n                t10 += 38 * t26;\n                t11 += 38 * t27;\n                t12 += 38 * t28;\n                t13 += 38 * t29;\n                t14 += 38 * t30;\n                // t15 left as is\n                // first car\n                c = 1;\n                v = t0 + c + 65535;\n                c = Math.floor(v / 65536);\n                t0 = v - c * 65536;\n                v = t1 + c + 65535;\n                c = Math.floor(v / 65536);\n                t1 = v - c * 65536;\n                v = t2 + c + 65535;\n                c = Math.floor(v / 65536);\n                t2 = v - c * 65536;\n                v = t3 + c + 65535;\n                c = Math.floor(v / 65536);\n                t3 = v - c * 65536;\n                v = t4 + c + 65535;\n                c = Math.floor(v / 65536);\n                t4 = v - c * 65536;\n                v = t5 + c + 65535;\n                c = Math.floor(v / 65536);\n                t5 = v - c * 65536;\n                v = t6 + c + 65535;\n                c = Math.floor(v / 65536);\n                t6 = v - c * 65536;\n                v = t7 + c + 65535;\n                c = Math.floor(v / 65536);\n                t7 = v - c * 65536;\n                v = t8 + c + 65535;\n                c = Math.floor(v / 65536);\n                t8 = v - c * 65536;\n                v = t9 + c + 65535;\n                c = Math.floor(v / 65536);\n                t9 = v - c * 65536;\n                v = t10 + c + 65535;\n                c = Math.floor(v / 65536);\n                t10 = v - c * 65536;\n                v = t11 + c + 65535;\n                c = Math.floor(v / 65536);\n                t11 = v - c * 65536;\n                v = t12 + c + 65535;\n                c = Math.floor(v / 65536);\n                t12 = v - c * 65536;\n                v = t13 + c + 65535;\n                c = Math.floor(v / 65536);\n                t13 = v - c * 65536;\n                v = t14 + c + 65535;\n                c = Math.floor(v / 65536);\n                t14 = v - c * 65536;\n                v = t15 + c + 65535;\n                c = Math.floor(v / 65536);\n                t15 = v - c * 65536;\n                t0 += c - 1 + 37 * (c - 1);\n                // second car\n                c = 1;\n                v = t0 + c + 65535;\n                c = Math.floor(v / 65536);\n                t0 = v - c * 65536;\n                v = t1 + c + 65535;\n                c = Math.floor(v / 65536);\n                t1 = v - c * 65536;\n                v = t2 + c + 65535;\n                c = Math.floor(v / 65536);\n                t2 = v - c * 65536;\n                v = t3 + c + 65535;\n                c = Math.floor(v / 65536);\n                t3 = v - c * 65536;\n                v = t4 + c + 65535;\n                c = Math.floor(v / 65536);\n                t4 = v - c * 65536;\n                v = t5 + c + 65535;\n                c = Math.floor(v / 65536);\n                t5 = v - c * 65536;\n                v = t6 + c + 65535;\n                c = Math.floor(v / 65536);\n                t6 = v - c * 65536;\n                v = t7 + c + 65535;\n                c = Math.floor(v / 65536);\n                t7 = v - c * 65536;\n                v = t8 + c + 65535;\n                c = Math.floor(v / 65536);\n                t8 = v - c * 65536;\n                v = t9 + c + 65535;\n                c = Math.floor(v / 65536);\n                t9 = v - c * 65536;\n                v = t10 + c + 65535;\n                c = Math.floor(v / 65536);\n                t10 = v - c * 65536;\n                v = t11 + c + 65535;\n                c = Math.floor(v / 65536);\n                t11 = v - c * 65536;\n                v = t12 + c + 65535;\n                c = Math.floor(v / 65536);\n                t12 = v - c * 65536;\n                v = t13 + c + 65535;\n                c = Math.floor(v / 65536);\n                t13 = v - c * 65536;\n                v = t14 + c + 65535;\n                c = Math.floor(v / 65536);\n                t14 = v - c * 65536;\n                v = t15 + c + 65535;\n                c = Math.floor(v / 65536);\n                t15 = v - c * 65536;\n                t0 += c - 1 + 37 * (c - 1);\n                o[0] = t0;\n                o[1] = t1;\n                o[2] = t2;\n                o[3] = t3;\n                o[4] = t4;\n                o[5] = t5;\n                o[6] = t6;\n                o[7] = t7;\n                o[8] = t8;\n                o[9] = t9;\n                o[10] = t10;\n                o[11] = t11;\n                o[12] = t12;\n                o[13] = t13;\n                o[14] = t14;\n                o[15] = t15;\n            }\n            function S(o, a) {\n                M(o, a, a);\n            }\n            function inv25519(o, i) {\n                var c = gf();\n                var a;\n                for(a = 0; a < 16; a++)c[a] = i[a];\n                for(a = 253; a >= 0; a--){\n                    S(c, c);\n                    if (a !== 2 && a !== 4) M(c, c, i);\n                }\n                for(a = 0; a < 16; a++)o[a] = c[a];\n            }\n            function pow2523(o, i) {\n                var c = gf();\n                var a;\n                for(a = 0; a < 16; a++)c[a] = i[a];\n                for(a = 250; a >= 0; a--){\n                    S(c, c);\n                    if (a !== 1) M(c, c, i);\n                }\n                for(a = 0; a < 16; a++)o[a] = c[a];\n            }\n            function crypto_scalarmult(q, n, p) {\n                var z = new Uint8Array(32);\n                var x = new Float64Array(80), r, i;\n                var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();\n                for(i = 0; i < 31; i++)z[i] = n[i];\n                z[31] = n[31] & 127 | 64;\n                z[0] &= 248;\n                unpack25519(x, p);\n                for(i = 0; i < 16; i++){\n                    b[i] = x[i];\n                    d[i] = a[i] = c[i] = 0;\n                }\n                a[0] = d[0] = 1;\n                for(i = 254; i >= 0; --i){\n                    r = z[i >>> 3] >>> (i & 7) & 1;\n                    sel25519(a, b, r);\n                    sel25519(c, d, r);\n                    A(e, a, c);\n                    Z(a, a, c);\n                    A(c, b, d);\n                    Z(b, b, d);\n                    S(d, e);\n                    S(f, a);\n                    M(a, c, a);\n                    M(c, b, e);\n                    A(e, a, c);\n                    Z(a, a, c);\n                    S(b, a);\n                    Z(c, d, f);\n                    M(a, c, _121665);\n                    A(a, a, d);\n                    M(c, c, a);\n                    M(a, d, f);\n                    M(d, b, x);\n                    S(b, e);\n                    sel25519(a, b, r);\n                    sel25519(c, d, r);\n                }\n                for(i = 0; i < 16; i++){\n                    x[i + 16] = a[i];\n                    x[i + 32] = c[i];\n                    x[i + 48] = b[i];\n                    x[i + 64] = d[i];\n                }\n                var x32 = x.subarray(32);\n                var x16 = x.subarray(16);\n                inv25519(x32, x32);\n                M(x16, x16, x32);\n                pack25519(q, x16);\n                return 0;\n            }\n            function crypto_scalarmult_base(q, n) {\n                return crypto_scalarmult(q, n, _9);\n            }\n            function crypto_box_keypair(y, x) {\n                randombytes(x, 32);\n                return crypto_scalarmult_base(y, x);\n            }\n            function crypto_box_beforenm(k, y, x) {\n                var s = new Uint8Array(32);\n                crypto_scalarmult(s, x, y);\n                return crypto_core_hsalsa20(k, _0, s, sigma);\n            }\n            var crypto_box_afternm = crypto_secretbox;\n            var crypto_box_open_afternm = crypto_secretbox_open;\n            function crypto_box(c, m, d, n, y, x) {\n                var k = new Uint8Array(32);\n                crypto_box_beforenm(k, y, x);\n                return crypto_box_afternm(c, m, d, n, k);\n            }\n            function crypto_box_open(m, c, d, n, y, x) {\n                var k = new Uint8Array(32);\n                crypto_box_beforenm(k, y, x);\n                return crypto_box_open_afternm(m, c, d, n, k);\n            }\n            var K = [\n                0x428a2f98,\n                0xd728ae22,\n                0x71374491,\n                0x23ef65cd,\n                0xb5c0fbcf,\n                0xec4d3b2f,\n                0xe9b5dba5,\n                0x8189dbbc,\n                0x3956c25b,\n                0xf348b538,\n                0x59f111f1,\n                0xb605d019,\n                0x923f82a4,\n                0xaf194f9b,\n                0xab1c5ed5,\n                0xda6d8118,\n                0xd807aa98,\n                0xa3030242,\n                0x12835b01,\n                0x45706fbe,\n                0x243185be,\n                0x4ee4b28c,\n                0x550c7dc3,\n                0xd5ffb4e2,\n                0x72be5d74,\n                0xf27b896f,\n                0x80deb1fe,\n                0x3b1696b1,\n                0x9bdc06a7,\n                0x25c71235,\n                0xc19bf174,\n                0xcf692694,\n                0xe49b69c1,\n                0x9ef14ad2,\n                0xefbe4786,\n                0x384f25e3,\n                0x0fc19dc6,\n                0x8b8cd5b5,\n                0x240ca1cc,\n                0x77ac9c65,\n                0x2de92c6f,\n                0x592b0275,\n                0x4a7484aa,\n                0x6ea6e483,\n                0x5cb0a9dc,\n                0xbd41fbd4,\n                0x76f988da,\n                0x831153b5,\n                0x983e5152,\n                0xee66dfab,\n                0xa831c66d,\n                0x2db43210,\n                0xb00327c8,\n                0x98fb213f,\n                0xbf597fc7,\n                0xbeef0ee4,\n                0xc6e00bf3,\n                0x3da88fc2,\n                0xd5a79147,\n                0x930aa725,\n                0x06ca6351,\n                0xe003826f,\n                0x14292967,\n                0x0a0e6e70,\n                0x27b70a85,\n                0x46d22ffc,\n                0x2e1b2138,\n                0x5c26c926,\n                0x4d2c6dfc,\n                0x5ac42aed,\n                0x53380d13,\n                0x9d95b3df,\n                0x650a7354,\n                0x8baf63de,\n                0x766a0abb,\n                0x3c77b2a8,\n                0x81c2c92e,\n                0x47edaee6,\n                0x92722c85,\n                0x1482353b,\n                0xa2bfe8a1,\n                0x4cf10364,\n                0xa81a664b,\n                0xbc423001,\n                0xc24b8b70,\n                0xd0f89791,\n                0xc76c51a3,\n                0x0654be30,\n                0xd192e819,\n                0xd6ef5218,\n                0xd6990624,\n                0x5565a910,\n                0xf40e3585,\n                0x5771202a,\n                0x106aa070,\n                0x32bbd1b8,\n                0x19a4c116,\n                0xb8d2d0c8,\n                0x1e376c08,\n                0x5141ab53,\n                0x2748774c,\n                0xdf8eeb99,\n                0x34b0bcb5,\n                0xe19b48a8,\n                0x391c0cb3,\n                0xc5c95a63,\n                0x4ed8aa4a,\n                0xe3418acb,\n                0x5b9cca4f,\n                0x7763e373,\n                0x682e6ff3,\n                0xd6b2b8a3,\n                0x748f82ee,\n                0x5defb2fc,\n                0x78a5636f,\n                0x43172f60,\n                0x84c87814,\n                0xa1f0ab72,\n                0x8cc70208,\n                0x1a6439ec,\n                0x90befffa,\n                0x23631e28,\n                0xa4506ceb,\n                0xde82bde9,\n                0xbef9a3f7,\n                0xb2c67915,\n                0xc67178f2,\n                0xe372532b,\n                0xca273ece,\n                0xea26619c,\n                0xd186b8c7,\n                0x21c0c207,\n                0xeada7dd6,\n                0xcde0eb1e,\n                0xf57d4f7f,\n                0xee6ed178,\n                0x06f067aa,\n                0x72176fba,\n                0x0a637dc5,\n                0xa2c898a6,\n                0x113f9804,\n                0xbef90dae,\n                0x1b710b35,\n                0x131c471b,\n                0x28db77f5,\n                0x23047d84,\n                0x32caab7b,\n                0x40c72493,\n                0x3c9ebe0a,\n                0x15c9bebc,\n                0x431d67c4,\n                0x9c100d4c,\n                0x4cc5d4be,\n                0xcb3e42b6,\n                0x597f299c,\n                0xfc657e2a,\n                0x5fcb6fab,\n                0x3ad6faec,\n                0x6c44198c,\n                0x4a475817\n            ];\n            function crypto_hashblocks_hl(hh, hl, m, n) {\n                var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;\n                var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];\n                var pos = 0;\n                while(n >= 128){\n                    for(i = 0; i < 16; i++){\n                        j = 8 * i + pos;\n                        wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];\n                        wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];\n                    }\n                    for(i = 0; i < 80; i++){\n                        bh0 = ah0;\n                        bh1 = ah1;\n                        bh2 = ah2;\n                        bh3 = ah3;\n                        bh4 = ah4;\n                        bh5 = ah5;\n                        bh6 = ah6;\n                        bh7 = ah7;\n                        bl0 = al0;\n                        bl1 = al1;\n                        bl2 = al2;\n                        bl3 = al3;\n                        bl4 = al4;\n                        bl5 = al5;\n                        bl6 = al6;\n                        bl7 = al7;\n                        // add\n                        h = ah7;\n                        l = al7;\n                        a = l & 0xffff;\n                        b = l >>> 16;\n                        c = h & 0xffff;\n                        d = h >>> 16;\n                        // Sigma1\n                        h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));\n                        l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));\n                        a += l & 0xffff;\n                        b += l >>> 16;\n                        c += h & 0xffff;\n                        d += h >>> 16;\n                        // Ch\n                        h = ah4 & ah5 ^ ~ah4 & ah6;\n                        l = al4 & al5 ^ ~al4 & al6;\n                        a += l & 0xffff;\n                        b += l >>> 16;\n                        c += h & 0xffff;\n                        d += h >>> 16;\n                        // K\n                        h = K[i * 2];\n                        l = K[i * 2 + 1];\n                        a += l & 0xffff;\n                        b += l >>> 16;\n                        c += h & 0xffff;\n                        d += h >>> 16;\n                        // w\n                        h = wh[i % 16];\n                        l = wl[i % 16];\n                        a += l & 0xffff;\n                        b += l >>> 16;\n                        c += h & 0xffff;\n                        d += h >>> 16;\n                        b += a >>> 16;\n                        c += b >>> 16;\n                        d += c >>> 16;\n                        th = c & 0xffff | d << 16;\n                        tl = a & 0xffff | b << 16;\n                        // add\n                        h = th;\n                        l = tl;\n                        a = l & 0xffff;\n                        b = l >>> 16;\n                        c = h & 0xffff;\n                        d = h >>> 16;\n                        // Sigma0\n                        h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));\n                        l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));\n                        a += l & 0xffff;\n                        b += l >>> 16;\n                        c += h & 0xffff;\n                        d += h >>> 16;\n                        // Maj\n                        h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;\n                        l = al0 & al1 ^ al0 & al2 ^ al1 & al2;\n                        a += l & 0xffff;\n                        b += l >>> 16;\n                        c += h & 0xffff;\n                        d += h >>> 16;\n                        b += a >>> 16;\n                        c += b >>> 16;\n                        d += c >>> 16;\n                        bh7 = c & 0xffff | d << 16;\n                        bl7 = a & 0xffff | b << 16;\n                        // add\n                        h = bh3;\n                        l = bl3;\n                        a = l & 0xffff;\n                        b = l >>> 16;\n                        c = h & 0xffff;\n                        d = h >>> 16;\n                        h = th;\n                        l = tl;\n                        a += l & 0xffff;\n                        b += l >>> 16;\n                        c += h & 0xffff;\n                        d += h >>> 16;\n                        b += a >>> 16;\n                        c += b >>> 16;\n                        d += c >>> 16;\n                        bh3 = c & 0xffff | d << 16;\n                        bl3 = a & 0xffff | b << 16;\n                        ah1 = bh0;\n                        ah2 = bh1;\n                        ah3 = bh2;\n                        ah4 = bh3;\n                        ah5 = bh4;\n                        ah6 = bh5;\n                        ah7 = bh6;\n                        ah0 = bh7;\n                        al1 = bl0;\n                        al2 = bl1;\n                        al3 = bl2;\n                        al4 = bl3;\n                        al5 = bl4;\n                        al6 = bl5;\n                        al7 = bl6;\n                        al0 = bl7;\n                        if (i % 16 === 15) {\n                            for(j = 0; j < 16; j++){\n                                // add\n                                h = wh[j];\n                                l = wl[j];\n                                a = l & 0xffff;\n                                b = l >>> 16;\n                                c = h & 0xffff;\n                                d = h >>> 16;\n                                h = wh[(j + 9) % 16];\n                                l = wl[(j + 9) % 16];\n                                a += l & 0xffff;\n                                b += l >>> 16;\n                                c += h & 0xffff;\n                                d += h >>> 16;\n                                // sigma0\n                                th = wh[(j + 1) % 16];\n                                tl = wl[(j + 1) % 16];\n                                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;\n                                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);\n                                a += l & 0xffff;\n                                b += l >>> 16;\n                                c += h & 0xffff;\n                                d += h >>> 16;\n                                // sigma1\n                                th = wh[(j + 14) % 16];\n                                tl = wl[(j + 14) % 16];\n                                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;\n                                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);\n                                a += l & 0xffff;\n                                b += l >>> 16;\n                                c += h & 0xffff;\n                                d += h >>> 16;\n                                b += a >>> 16;\n                                c += b >>> 16;\n                                d += c >>> 16;\n                                wh[j] = c & 0xffff | d << 16;\n                                wl[j] = a & 0xffff | b << 16;\n                            }\n                        }\n                    }\n                    // add\n                    h = ah0;\n                    l = al0;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[0];\n                    l = hl[0];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[0] = ah0 = c & 0xffff | d << 16;\n                    hl[0] = al0 = a & 0xffff | b << 16;\n                    h = ah1;\n                    l = al1;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[1];\n                    l = hl[1];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[1] = ah1 = c & 0xffff | d << 16;\n                    hl[1] = al1 = a & 0xffff | b << 16;\n                    h = ah2;\n                    l = al2;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[2];\n                    l = hl[2];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[2] = ah2 = c & 0xffff | d << 16;\n                    hl[2] = al2 = a & 0xffff | b << 16;\n                    h = ah3;\n                    l = al3;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[3];\n                    l = hl[3];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[3] = ah3 = c & 0xffff | d << 16;\n                    hl[3] = al3 = a & 0xffff | b << 16;\n                    h = ah4;\n                    l = al4;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[4];\n                    l = hl[4];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[4] = ah4 = c & 0xffff | d << 16;\n                    hl[4] = al4 = a & 0xffff | b << 16;\n                    h = ah5;\n                    l = al5;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[5];\n                    l = hl[5];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[5] = ah5 = c & 0xffff | d << 16;\n                    hl[5] = al5 = a & 0xffff | b << 16;\n                    h = ah6;\n                    l = al6;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[6];\n                    l = hl[6];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[6] = ah6 = c & 0xffff | d << 16;\n                    hl[6] = al6 = a & 0xffff | b << 16;\n                    h = ah7;\n                    l = al7;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[7];\n                    l = hl[7];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[7] = ah7 = c & 0xffff | d << 16;\n                    hl[7] = al7 = a & 0xffff | b << 16;\n                    pos += 128;\n                    n -= 128;\n                }\n                return n;\n            }\n            function crypto_hash(out, m, n) {\n                var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;\n                hh[0] = 0x6a09e667;\n                hh[1] = 0xbb67ae85;\n                hh[2] = 0x3c6ef372;\n                hh[3] = 0xa54ff53a;\n                hh[4] = 0x510e527f;\n                hh[5] = 0x9b05688c;\n                hh[6] = 0x1f83d9ab;\n                hh[7] = 0x5be0cd19;\n                hl[0] = 0xf3bcc908;\n                hl[1] = 0x84caa73b;\n                hl[2] = 0xfe94f82b;\n                hl[3] = 0x5f1d36f1;\n                hl[4] = 0xade682d1;\n                hl[5] = 0x2b3e6c1f;\n                hl[6] = 0xfb41bd6b;\n                hl[7] = 0x137e2179;\n                crypto_hashblocks_hl(hh, hl, m, n);\n                n %= 128;\n                for(i = 0; i < n; i++)x[i] = m[b - n + i];\n                x[n] = 128;\n                n = 256 - 128 * (n < 112 ? 1 : 0);\n                x[n - 9] = 0;\n                ts64(x, n - 8, b / 0x20000000 | 0, b << 3);\n                crypto_hashblocks_hl(hh, hl, x, n);\n                for(i = 0; i < 8; i++)ts64(out, 8 * i, hh[i], hl[i]);\n                return 0;\n            }\n            function add(p, q) {\n                var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();\n                Z(a, p[1], p[0]);\n                Z(t, q[1], q[0]);\n                M(a, a, t);\n                A(b, p[0], p[1]);\n                A(t, q[0], q[1]);\n                M(b, b, t);\n                M(c, p[3], q[3]);\n                M(c, c, D2);\n                M(d, p[2], q[2]);\n                A(d, d, d);\n                Z(e, b, a);\n                Z(f, d, c);\n                A(g, d, c);\n                A(h, b, a);\n                M(p[0], e, f);\n                M(p[1], h, g);\n                M(p[2], g, f);\n                M(p[3], e, h);\n            }\n            function cswap(p, q, b) {\n                var i;\n                for(i = 0; i < 4; i++){\n                    sel25519(p[i], q[i], b);\n                }\n            }\n            function pack(r, p) {\n                var tx = gf(), ty = gf(), zi = gf();\n                inv25519(zi, p[2]);\n                M(tx, p[0], zi);\n                M(ty, p[1], zi);\n                pack25519(r, ty);\n                r[31] ^= par25519(tx) << 7;\n            }\n            function scalarmult(p, q, s) {\n                var b, i;\n                set25519(p[0], gf0);\n                set25519(p[1], gf1);\n                set25519(p[2], gf1);\n                set25519(p[3], gf0);\n                for(i = 255; i >= 0; --i){\n                    b = s[i / 8 | 0] >> (i & 7) & 1;\n                    cswap(p, q, b);\n                    add(q, p);\n                    add(p, p);\n                    cswap(p, q, b);\n                }\n            }\n            function scalarbase(p, s) {\n                var q = [\n                    gf(),\n                    gf(),\n                    gf(),\n                    gf()\n                ];\n                set25519(q[0], X);\n                set25519(q[1], Y);\n                set25519(q[2], gf1);\n                M(q[3], X, Y);\n                scalarmult(p, q, s);\n            }\n            function crypto_sign_keypair(pk, sk, seeded) {\n                var d = new Uint8Array(64);\n                var p = [\n                    gf(),\n                    gf(),\n                    gf(),\n                    gf()\n                ];\n                var i;\n                if (!seeded) randombytes(sk, 32);\n                crypto_hash(d, sk, 32);\n                d[0] &= 248;\n                d[31] &= 127;\n                d[31] |= 64;\n                scalarbase(p, d);\n                pack(pk, p);\n                for(i = 0; i < 32; i++)sk[i + 32] = pk[i];\n                return 0;\n            }\n            var L = new Float64Array([\n                0xed,\n                0xd3,\n                0xf5,\n                0x5c,\n                0x1a,\n                0x63,\n                0x12,\n                0x58,\n                0xd6,\n                0x9c,\n                0xf7,\n                0xa2,\n                0xde,\n                0xf9,\n                0xde,\n                0x14,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0x10\n            ]);\n            function modL(r, x) {\n                var carry, i, j, k;\n                for(i = 63; i >= 32; --i){\n                    carry = 0;\n                    for(j = i - 32, k = i - 12; j < k; ++j){\n                        x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n                        carry = Math.floor((x[j] + 128) / 256);\n                        x[j] -= carry * 256;\n                    }\n                    x[j] += carry;\n                    x[i] = 0;\n                }\n                carry = 0;\n                for(j = 0; j < 32; j++){\n                    x[j] += carry - (x[31] >> 4) * L[j];\n                    carry = x[j] >> 8;\n                    x[j] &= 255;\n                }\n                for(j = 0; j < 32; j++)x[j] -= carry * L[j];\n                for(i = 0; i < 32; i++){\n                    x[i + 1] += x[i] >> 8;\n                    r[i] = x[i] & 255;\n                }\n            }\n            function reduce(r) {\n                var x = new Float64Array(64), i;\n                for(i = 0; i < 64; i++)x[i] = r[i];\n                for(i = 0; i < 64; i++)r[i] = 0;\n                modL(r, x);\n            }\n            // Note: difference from C - smlen returned, not passed as argument.\n            function crypto_sign(sm, m, n, sk) {\n                var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n                var i, j, x = new Float64Array(64);\n                var p = [\n                    gf(),\n                    gf(),\n                    gf(),\n                    gf()\n                ];\n                crypto_hash(d, sk, 32);\n                d[0] &= 248;\n                d[31] &= 127;\n                d[31] |= 64;\n                var smlen = n + 64;\n                for(i = 0; i < n; i++)sm[64 + i] = m[i];\n                for(i = 0; i < 32; i++)sm[32 + i] = d[32 + i];\n                crypto_hash(r, sm.subarray(32), n + 32);\n                reduce(r);\n                scalarbase(p, r);\n                pack(sm, p);\n                for(i = 32; i < 64; i++)sm[i] = sk[i];\n                crypto_hash(h, sm, n + 64);\n                reduce(h);\n                for(i = 0; i < 64; i++)x[i] = 0;\n                for(i = 0; i < 32; i++)x[i] = r[i];\n                for(i = 0; i < 32; i++){\n                    for(j = 0; j < 32; j++){\n                        x[i + j] += h[i] * d[j];\n                    }\n                }\n                modL(sm.subarray(32), x);\n                return smlen;\n            }\n            function unpackneg(r, p) {\n                var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();\n                set25519(r[2], gf1);\n                unpack25519(r[1], p);\n                S(num, r[1]);\n                M(den, num, D);\n                Z(num, num, r[2]);\n                A(den, r[2], den);\n                S(den2, den);\n                S(den4, den2);\n                M(den6, den4, den2);\n                M(t, den6, num);\n                M(t, t, den);\n                pow2523(t, t);\n                M(t, t, num);\n                M(t, t, den);\n                M(t, t, den);\n                M(r[0], t, den);\n                S(chk, r[0]);\n                M(chk, chk, den);\n                if (neq25519(chk, num)) M(r[0], r[0], I);\n                S(chk, r[0]);\n                M(chk, chk, den);\n                if (neq25519(chk, num)) return -1;\n                if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);\n                M(r[3], r[0], r[1]);\n                return 0;\n            }\n            function crypto_sign_open(m, sm, n, pk) {\n                var i;\n                var t = new Uint8Array(32), h = new Uint8Array(64);\n                var p = [\n                    gf(),\n                    gf(),\n                    gf(),\n                    gf()\n                ], q = [\n                    gf(),\n                    gf(),\n                    gf(),\n                    gf()\n                ];\n                if (n < 64) return -1;\n                if (unpackneg(q, pk)) return -1;\n                for(i = 0; i < n; i++)m[i] = sm[i];\n                for(i = 0; i < 32; i++)m[i + 32] = pk[i];\n                crypto_hash(h, m, n);\n                reduce(h);\n                scalarmult(p, q, h);\n                scalarbase(q, sm.subarray(32));\n                add(p, q);\n                pack(t, p);\n                n -= 64;\n                if (crypto_verify_32(sm, 0, t, 0)) {\n                    for(i = 0; i < n; i++)m[i] = 0;\n                    return -1;\n                }\n                for(i = 0; i < n; i++)m[i] = sm[i + 64];\n                return n;\n            }\n            var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;\n            nacl.lowlevel = {\n                crypto_core_hsalsa20: crypto_core_hsalsa20,\n                crypto_stream_xor: crypto_stream_xor,\n                crypto_stream: crypto_stream,\n                crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,\n                crypto_stream_salsa20: crypto_stream_salsa20,\n                crypto_onetimeauth: crypto_onetimeauth,\n                crypto_onetimeauth_verify: crypto_onetimeauth_verify,\n                crypto_verify_16: crypto_verify_16,\n                crypto_verify_32: crypto_verify_32,\n                crypto_secretbox: crypto_secretbox,\n                crypto_secretbox_open: crypto_secretbox_open,\n                crypto_scalarmult: crypto_scalarmult,\n                crypto_scalarmult_base: crypto_scalarmult_base,\n                crypto_box_beforenm: crypto_box_beforenm,\n                crypto_box_afternm: crypto_box_afternm,\n                crypto_box: crypto_box,\n                crypto_box_open: crypto_box_open,\n                crypto_box_keypair: crypto_box_keypair,\n                crypto_hash: crypto_hash,\n                crypto_sign: crypto_sign,\n                crypto_sign_keypair: crypto_sign_keypair,\n                crypto_sign_open: crypto_sign_open,\n                crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,\n                crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,\n                crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,\n                crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,\n                crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,\n                crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,\n                crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,\n                crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,\n                crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,\n                crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,\n                crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,\n                crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,\n                crypto_sign_BYTES: crypto_sign_BYTES,\n                crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,\n                crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,\n                crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n                crypto_hash_BYTES: crypto_hash_BYTES,\n                gf: gf,\n                D: D,\n                L: L,\n                pack25519: pack25519,\n                unpack25519: unpack25519,\n                M: M,\n                A: A,\n                S: S,\n                Z: Z,\n                pow2523: pow2523,\n                add: add,\n                set25519: set25519,\n                modL: modL,\n                scalarmult: scalarmult,\n                scalarbase: scalarbase\n            };\n            /* High-level API */ function checkLengths(k, n) {\n                if (k.length !== crypto_secretbox_KEYBYTES) throw new Error(\"bad key size\");\n                if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error(\"bad nonce size\");\n            }\n            function checkBoxLengths(pk, sk) {\n                if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error(\"bad public key size\");\n                if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error(\"bad secret key size\");\n            }\n            function checkArrayTypes() {\n                for(var i = 0; i < arguments.length; i++){\n                    if (!(arguments[i] instanceof Uint8Array)) throw new TypeError(\"unexpected type, use Uint8Array\");\n                }\n            }\n            function cleanup(arr) {\n                for(var i = 0; i < arr.length; i++)arr[i] = 0;\n            }\n            nacl.randomBytes = function(n) {\n                var b = new Uint8Array(n);\n                randombytes(b, n);\n                return b;\n            };\n            nacl.secretbox = function(msg, nonce, key) {\n                checkArrayTypes(msg, nonce, key);\n                checkLengths(key, nonce);\n                var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n                var c = new Uint8Array(m.length);\n                for(var i = 0; i < msg.length; i++)m[i + crypto_secretbox_ZEROBYTES] = msg[i];\n                crypto_secretbox(c, m, m.length, nonce, key);\n                return c.subarray(crypto_secretbox_BOXZEROBYTES);\n            };\n            nacl.secretbox.open = function(box, nonce, key) {\n                checkArrayTypes(box, nonce, key);\n                checkLengths(key, nonce);\n                var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n                var m = new Uint8Array(c.length);\n                for(var i = 0; i < box.length; i++)c[i + crypto_secretbox_BOXZEROBYTES] = box[i];\n                if (c.length < 32) return null;\n                if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;\n                return m.subarray(crypto_secretbox_ZEROBYTES);\n            };\n            nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\n            nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\n            nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n            nacl.scalarMult = function(n, p) {\n                checkArrayTypes(n, p);\n                if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error(\"bad n size\");\n                if (p.length !== crypto_scalarmult_BYTES) throw new Error(\"bad p size\");\n                var q = new Uint8Array(crypto_scalarmult_BYTES);\n                crypto_scalarmult(q, n, p);\n                return q;\n            };\n            nacl.scalarMult.base = function(n) {\n                checkArrayTypes(n);\n                if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error(\"bad n size\");\n                var q = new Uint8Array(crypto_scalarmult_BYTES);\n                crypto_scalarmult_base(q, n);\n                return q;\n            };\n            nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\n            nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n            nacl.box = function(msg, nonce, publicKey, secretKey) {\n                var k = nacl.box.before(publicKey, secretKey);\n                return nacl.secretbox(msg, nonce, k);\n            };\n            nacl.box.before = function(publicKey, secretKey) {\n                checkArrayTypes(publicKey, secretKey);\n                checkBoxLengths(publicKey, secretKey);\n                var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n                crypto_box_beforenm(k, publicKey, secretKey);\n                return k;\n            };\n            nacl.box.after = nacl.secretbox;\n            nacl.box.open = function(msg, nonce, publicKey, secretKey) {\n                var k = nacl.box.before(publicKey, secretKey);\n                return nacl.secretbox.open(msg, nonce, k);\n            };\n            nacl.box.open.after = nacl.secretbox.open;\n            nacl.box.keyPair = function() {\n                var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n                var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n                crypto_box_keypair(pk, sk);\n                return {\n                    publicKey: pk,\n                    secretKey: sk\n                };\n            };\n            nacl.box.keyPair.fromSecretKey = function(secretKey) {\n                checkArrayTypes(secretKey);\n                if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error(\"bad secret key size\");\n                var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n                crypto_scalarmult_base(pk, secretKey);\n                return {\n                    publicKey: pk,\n                    secretKey: new Uint8Array(secretKey)\n                };\n            };\n            nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\n            nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\n            nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\n            nacl.box.nonceLength = crypto_box_NONCEBYTES;\n            nacl.box.overheadLength = nacl.secretbox.overheadLength;\n            nacl.sign = function(msg, secretKey) {\n                checkArrayTypes(msg, secretKey);\n                if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error(\"bad secret key size\");\n                var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);\n                crypto_sign(signedMsg, msg, msg.length, secretKey);\n                return signedMsg;\n            };\n            nacl.sign.open = function(signedMsg, publicKey) {\n                checkArrayTypes(signedMsg, publicKey);\n                if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error(\"bad public key size\");\n                var tmp = new Uint8Array(signedMsg.length);\n                var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n                if (mlen < 0) return null;\n                var m = new Uint8Array(mlen);\n                for(var i = 0; i < m.length; i++)m[i] = tmp[i];\n                return m;\n            };\n            nacl.sign.detached = function(msg, secretKey) {\n                var signedMsg = nacl.sign(msg, secretKey);\n                var sig = new Uint8Array(crypto_sign_BYTES);\n                for(var i = 0; i < sig.length; i++)sig[i] = signedMsg[i];\n                return sig;\n            };\n            nacl.sign.detached.verify = function(msg, sig, publicKey) {\n                checkArrayTypes(msg, sig, publicKey);\n                if (sig.length !== crypto_sign_BYTES) throw new Error(\"bad signature size\");\n                if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error(\"bad public key size\");\n                var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n                var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n                var i;\n                for(i = 0; i < crypto_sign_BYTES; i++)sm[i] = sig[i];\n                for(i = 0; i < msg.length; i++)sm[i + crypto_sign_BYTES] = msg[i];\n                return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;\n            };\n            nacl.sign.keyPair = function() {\n                var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n                var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n                crypto_sign_keypair(pk, sk);\n                return {\n                    publicKey: pk,\n                    secretKey: sk\n                };\n            };\n            nacl.sign.keyPair.fromSecretKey = function(secretKey) {\n                checkArrayTypes(secretKey);\n                if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error(\"bad secret key size\");\n                var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n                for(var i = 0; i < pk.length; i++)pk[i] = secretKey[32 + i];\n                return {\n                    publicKey: pk,\n                    secretKey: new Uint8Array(secretKey)\n                };\n            };\n            nacl.sign.keyPair.fromSeed = function(seed) {\n                checkArrayTypes(seed);\n                if (seed.length !== crypto_sign_SEEDBYTES) throw new Error(\"bad seed size\");\n                var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n                var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n                for(var i = 0; i < 32; i++)sk[i] = seed[i];\n                crypto_sign_keypair(pk, sk, true);\n                return {\n                    publicKey: pk,\n                    secretKey: sk\n                };\n            };\n            nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\n            nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\n            nacl.sign.seedLength = crypto_sign_SEEDBYTES;\n            nacl.sign.signatureLength = crypto_sign_BYTES;\n            nacl.hash = function(msg) {\n                checkArrayTypes(msg);\n                var h = new Uint8Array(crypto_hash_BYTES);\n                crypto_hash(h, msg, msg.length);\n                return h;\n            };\n            nacl.hash.hashLength = crypto_hash_BYTES;\n            nacl.verify = function(x, y) {\n                checkArrayTypes(x, y);\n                // Zero length arguments are considered not equal.\n                if (x.length === 0 || y.length === 0) return false;\n                if (x.length !== y.length) return false;\n                return vn(x, 0, y, 0, x.length) === 0 ? true : false;\n            };\n            nacl.setPRNG = function(fn) {\n                randombytes = fn;\n            };\n            (function() {\n                // Initialize PRNG if environment provides CSPRNG.\n                // If not, methods calling randombytes will throw.\n                var crypto = typeof self !== \"undefined\" ? self.crypto || self.msCrypto : null;\n                if (crypto && crypto.getRandomValues) {\n                    // Browsers.\n                    var QUOTA = 65536;\n                    nacl.setPRNG(function(x, n) {\n                        var i, v = new Uint8Array(n);\n                        for(i = 0; i < n; i += QUOTA){\n                            crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));\n                        }\n                        for(i = 0; i < n; i++)x[i] = v[i];\n                        cleanup(v);\n                    });\n                } else if (true) {\n                    // Node.js.\n                    crypto = __nested_webpack_require_98684__(3);\n                    if (crypto && crypto.randomBytes) {\n                        nacl.setPRNG(function(x, n) {\n                            var i, v = crypto.randomBytes(n);\n                            for(i = 0; i < n; i++)x[i] = v[i];\n                            cleanup(v);\n                        });\n                    }\n                }\n            })();\n        })( true && module1.exports ? module1.exports : self.nacl = self.nacl || {});\n    /***/ },\n    /* 21 */ /***/ function(module1, exports, __nested_webpack_require_196182__) {\n        module1.exports = __nested_webpack_require_196182__(47).default;\n    /***/ },\n    /* 22 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! buffer */ \"buffer\");\n    /***/ },\n    /* 23 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! events */ \"events\");\n    /***/ },\n    /* 24 */ /***/ function(module1, exports, __nested_webpack_require_196535__) {\n        \"use strict\";\n        /**\n\nStreams in a WebSocket connection\n---------------------------------\n\nWe model a WebSocket as two duplex streams: one stream is for the wire protocol\nover an I/O socket, and the other is for incoming/outgoing messages.\n\n\n                        +----------+      +---------+      +----------+\n    [1] write(chunk) -->| ~~~~~~~~ +----->| parse() +----->| ~~~~~~~~ +--> emit('data') [2]\n                        |          |      +----+----+      |          |\n                        |          |           |           |          |\n                        |    IO    |           | [5]       | Messages |\n                        |          |           V           |          |\n                        |          |      +---------+      |          |\n    [4] emit('data') <--+ ~~~~~~~~ |<-----+ frame() |<-----+ ~~~~~~~~ |<-- write(chunk) [3]\n                        +----------+      +---------+      +----------+\n\n\nMessage transfer in each direction is simple: IO receives a byte stream [1] and\nsends this stream for parsing. The parser will periodically emit a complete\nmessage text on the Messages stream [2]. Similarly, when messages are written\nto the Messages stream [3], they are framed using the WebSocket wire format and\nemitted via IO [4].\n\nThere is a feedback loop via [5] since some input from [1] will be things like\nping, pong and close frames. In these cases the protocol responds by emitting\nresponses directly back to [4] rather than emitting messages via [2].\n\nFor the purposes of flow control, we consider the sources of each Readable\nstream to be as follows:\n\n* [2] receives input from [1]\n* [4] receives input from [1] and [3]\n\nThe classes below express the relationships described above without prescribing\nanything about how parse() and frame() work, other than assuming they emit\n'data' events to the IO and Messages streams. They will work with any protocol\ndriver having these two methods.\n**/ var Stream = __nested_webpack_require_196535__(5).Stream, util = __nested_webpack_require_196535__(0);\n        var IO = function(driver) {\n            this.readable = this.writable = true;\n            this._paused = false;\n            this._driver = driver;\n        };\n        util.inherits(IO, Stream);\n        // The IO pause() and resume() methods will be called when the socket we are\n        // piping to gets backed up and drains. Since IO output [4] comes from IO input\n        // [1] and Messages input [3], we need to tell both of those to return false\n        // from write() when this stream is paused.\n        IO.prototype.pause = function() {\n            this._paused = true;\n            this._driver.messages._paused = true;\n        };\n        IO.prototype.resume = function() {\n            this._paused = false;\n            this.emit(\"drain\");\n            var messages = this._driver.messages;\n            messages._paused = false;\n            messages.emit(\"drain\");\n        };\n        // When we receive input from a socket, send it to the parser and tell the\n        // source whether to back off.\n        IO.prototype.write = function(chunk) {\n            if (!this.writable) return false;\n            this._driver.parse(chunk);\n            return !this._paused;\n        };\n        // The IO end() method will be called when the socket piping into it emits\n        // 'close' or 'end', i.e. the socket is closed. In this situation the Messages\n        // stream will not emit any more data so we emit 'end'.\n        IO.prototype.end = function(chunk) {\n            if (!this.writable) return;\n            if (chunk !== undefined) this.write(chunk);\n            this.writable = false;\n            var messages = this._driver.messages;\n            if (messages.readable) {\n                messages.readable = messages.writable = false;\n                messages.emit(\"end\");\n            }\n        };\n        IO.prototype.destroy = function() {\n            this.end();\n        };\n        var Messages = function(driver) {\n            this.readable = this.writable = true;\n            this._paused = false;\n            this._driver = driver;\n        };\n        util.inherits(Messages, Stream);\n        // The Messages pause() and resume() methods will be called when the app that's\n        // processing the messages gets backed up and drains. If we're emitting\n        // messages too fast we should tell the source to slow down. Message output [2]\n        // comes from IO input [1].\n        Messages.prototype.pause = function() {\n            this._driver.io._paused = true;\n        };\n        Messages.prototype.resume = function() {\n            this._driver.io._paused = false;\n            this._driver.io.emit(\"drain\");\n        };\n        // When we receive messages from the user, send them to the formatter and tell\n        // the source whether to back off.\n        Messages.prototype.write = function(message) {\n            if (!this.writable) return false;\n            if (typeof message === \"string\") this._driver.text(message);\n            else this._driver.binary(message);\n            return !this._paused;\n        };\n        // The Messages end() method will be called when a stream piping into it emits\n        // 'end'. Many streams may be piped into the WebSocket and one of them ending\n        // does not mean the whole socket is done, so just process the input and move\n        // on leaving the socket open.\n        Messages.prototype.end = function(message) {\n            if (message !== undefined) this.write(message);\n        };\n        Messages.prototype.destroy = function() {};\n        exports.IO = IO;\n        exports.Messages = Messages;\n    /***/ },\n    /* 25 */ /***/ function(module1, exports, __nested_webpack_require_202221__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_202221__(1).Buffer;\n        var StreamReader = function() {\n            this._queue = [];\n            this._queueSize = 0;\n            this._offset = 0;\n        };\n        StreamReader.prototype.put = function(buffer) {\n            if (!buffer || buffer.length === 0) return;\n            if (!Buffer1.isBuffer(buffer)) buffer = Buffer1.from(buffer);\n            this._queue.push(buffer);\n            this._queueSize += buffer.length;\n        };\n        StreamReader.prototype.read = function(length) {\n            if (length > this._queueSize) return null;\n            if (length === 0) return Buffer1.alloc(0);\n            this._queueSize -= length;\n            var queue = this._queue, remain = length, first = queue[0], buffers, buffer;\n            if (first.length >= length) {\n                if (first.length === length) {\n                    return queue.shift();\n                } else {\n                    buffer = first.slice(0, length);\n                    queue[0] = first.slice(length);\n                    return buffer;\n                }\n            }\n            for(var i = 0, n = queue.length; i < n; i++){\n                if (remain < queue[i].length) break;\n                remain -= queue[i].length;\n            }\n            buffers = queue.splice(0, i);\n            if (remain > 0 && queue.length > 0) {\n                buffers.push(queue[0].slice(0, remain));\n                queue[0] = queue[0].slice(remain);\n            }\n            return Buffer1.concat(buffers, length);\n        };\n        StreamReader.prototype.eachByte = function(callback, context) {\n            var buffer, n, index;\n            while(this._queue.length > 0){\n                buffer = this._queue[0];\n                n = buffer.length;\n                while(this._offset < n){\n                    index = this._offset;\n                    this._offset += 1;\n                    callback.call(context, buffer[index]);\n                }\n                this._offset = 0;\n                this._queue.shift();\n            }\n        };\n        module1.exports = StreamReader;\n    /***/ },\n    /* 26 */ /***/ function(module1, exports, __nested_webpack_require_204431__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_204431__(1).Buffer, crypto = __nested_webpack_require_204431__(3), url = __nested_webpack_require_204431__(6), util = __nested_webpack_require_204431__(0), HttpParser = __nested_webpack_require_204431__(10), Base = __nested_webpack_require_204431__(2), Hybi = __nested_webpack_require_204431__(12), Proxy = __nested_webpack_require_204431__(36);\n        var Client = function(_url, options) {\n            this.version = \"hybi-\" + Hybi.VERSION;\n            Hybi.call(this, null, _url, options);\n            this.readyState = -1;\n            this._key = Client.generateKey();\n            this._accept = Hybi.generateAccept(this._key);\n            this._http = new HttpParser(\"response\");\n            var uri = url.parse(this.url), auth = uri.auth && Buffer1.from(uri.auth, \"utf8\").toString(\"base64\");\n            if (this.VALID_PROTOCOLS.indexOf(uri.protocol) < 0) throw new Error(this.url + \" is not a valid WebSocket URL\");\n            this._pathname = (uri.pathname || \"/\") + (uri.search || \"\");\n            this._headers.set(\"Host\", uri.host);\n            this._headers.set(\"Upgrade\", \"websocket\");\n            this._headers.set(\"Connection\", \"Upgrade\");\n            this._headers.set(\"Sec-WebSocket-Key\", this._key);\n            this._headers.set(\"Sec-WebSocket-Version\", Hybi.VERSION);\n            if (this._protocols.length > 0) this._headers.set(\"Sec-WebSocket-Protocol\", this._protocols.join(\", \"));\n            if (auth) this._headers.set(\"Authorization\", \"Basic \" + auth);\n        };\n        util.inherits(Client, Hybi);\n        Client.generateKey = function() {\n            return crypto.randomBytes(16).toString(\"base64\");\n        };\n        var instance = {\n            VALID_PROTOCOLS: [\n                \"ws:\",\n                \"wss:\"\n            ],\n            proxy: function(origin, options) {\n                return new Proxy(this, origin, options);\n            },\n            start: function() {\n                if (this.readyState !== -1) return false;\n                this._write(this._handshakeRequest());\n                this.readyState = 0;\n                return true;\n            },\n            parse: function(chunk) {\n                if (this.readyState === 3) return;\n                if (this.readyState > 0) return Hybi.prototype.parse.call(this, chunk);\n                this._http.parse(chunk);\n                if (!this._http.isComplete()) return;\n                this._validateHandshake();\n                if (this.readyState === 3) return;\n                this._open();\n                this.parse(this._http.body);\n            },\n            _handshakeRequest: function() {\n                var extensions = this._extensions.generateOffer();\n                if (extensions) this._headers.set(\"Sec-WebSocket-Extensions\", extensions);\n                var start = \"GET \" + this._pathname + \" HTTP/1.1\", headers = [\n                    start,\n                    this._headers.toString(),\n                    \"\"\n                ];\n                return Buffer1.from(headers.join(\"\\r\\n\"), \"utf8\");\n            },\n            _failHandshake: function(message) {\n                message = \"Error during WebSocket handshake: \" + message;\n                this.readyState = 3;\n                this.emit(\"error\", new Error(message));\n                this.emit(\"close\", new Base.CloseEvent(this.ERRORS.protocol_error, message));\n            },\n            _validateHandshake: function() {\n                this.statusCode = this._http.statusCode;\n                this.headers = this._http.headers;\n                if (this._http.error) return this._failHandshake(this._http.error.message);\n                if (this._http.statusCode !== 101) return this._failHandshake(\"Unexpected response code: \" + this._http.statusCode);\n                var headers = this._http.headers, upgrade = headers[\"upgrade\"] || \"\", connection = headers[\"connection\"] || \"\", accept = headers[\"sec-websocket-accept\"] || \"\", protocol = headers[\"sec-websocket-protocol\"] || \"\";\n                if (upgrade === \"\") return this._failHandshake(\"'Upgrade' header is missing\");\n                if (upgrade.toLowerCase() !== \"websocket\") return this._failHandshake(\"'Upgrade' header value is not 'WebSocket'\");\n                if (connection === \"\") return this._failHandshake(\"'Connection' header is missing\");\n                if (connection.toLowerCase() !== \"upgrade\") return this._failHandshake(\"'Connection' header value is not 'Upgrade'\");\n                if (accept !== this._accept) return this._failHandshake(\"Sec-WebSocket-Accept mismatch\");\n                this.protocol = null;\n                if (protocol !== \"\") {\n                    if (this._protocols.indexOf(protocol) < 0) return this._failHandshake(\"Sec-WebSocket-Protocol mismatch\");\n                    else this.protocol = protocol;\n                }\n                try {\n                    this._extensions.activate(this.headers[\"sec-websocket-extensions\"]);\n                } catch (e) {\n                    return this._failHandshake(e.message);\n                }\n            }\n        };\n        for(var key in instance)Client.prototype[key] = instance[key];\n        module1.exports = Client;\n    /***/ },\n    /* 27 */ /***/ function(module1, exports, __nested_webpack_require_209628__) {\n        /*jshint node:true */ var assert = __nested_webpack_require_209628__(28);\n        exports.HTTPParser = HTTPParser;\n        function HTTPParser(type) {\n            assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE || type === undefined);\n            if (type === undefined) {\n            // Node v12+\n            } else {\n                this.initialize(type);\n            }\n            this.maxHeaderSize = HTTPParser.maxHeaderSize;\n        }\n        HTTPParser.prototype.initialize = function(type, async_resource) {\n            assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE);\n            this.type = type;\n            this.state = type + \"_LINE\";\n            this.info = {\n                headers: [],\n                upgrade: false\n            };\n            this.trailers = [];\n            this.line = \"\";\n            this.isChunked = false;\n            this.connection = \"\";\n            this.headerSize = 0; // for preventing too big headers\n            this.body_bytes = null;\n            this.isUserCall = false;\n            this.hadError = false;\n        };\n        HTTPParser.encoding = \"ascii\";\n        HTTPParser.maxHeaderSize = 80 * 1024; // maxHeaderSize (in bytes) is configurable, but 80kb by default;\n        HTTPParser.REQUEST = \"REQUEST\";\n        HTTPParser.RESPONSE = \"RESPONSE\";\n        // Note: *not* starting with kOnHeaders=0 line the Node parser, because any\n        //   newly added constants (kOnTimeout in Node v12.19.0) will overwrite 0!\n        var kOnHeaders = HTTPParser.kOnHeaders = 1;\n        var kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;\n        var kOnBody = HTTPParser.kOnBody = 3;\n        var kOnMessageComplete = HTTPParser.kOnMessageComplete = 4;\n        // Some handler stubs, needed for compatibility\n        HTTPParser.prototype[kOnHeaders] = HTTPParser.prototype[kOnHeadersComplete] = HTTPParser.prototype[kOnBody] = HTTPParser.prototype[kOnMessageComplete] = function() {};\n        var compatMode0_12 = true;\n        Object.defineProperty(HTTPParser, \"kOnExecute\", {\n            get: function() {\n                // hack for backward compatibility\n                compatMode0_12 = false;\n                return 99;\n            }\n        });\n        var methods = exports.methods = HTTPParser.methods = [\n            \"DELETE\",\n            \"GET\",\n            \"HEAD\",\n            \"POST\",\n            \"PUT\",\n            \"CONNECT\",\n            \"OPTIONS\",\n            \"TRACE\",\n            \"COPY\",\n            \"LOCK\",\n            \"MKCOL\",\n            \"MOVE\",\n            \"PROPFIND\",\n            \"PROPPATCH\",\n            \"SEARCH\",\n            \"UNLOCK\",\n            \"BIND\",\n            \"REBIND\",\n            \"UNBIND\",\n            \"ACL\",\n            \"REPORT\",\n            \"MKACTIVITY\",\n            \"CHECKOUT\",\n            \"MERGE\",\n            \"M-SEARCH\",\n            \"NOTIFY\",\n            \"SUBSCRIBE\",\n            \"UNSUBSCRIBE\",\n            \"PATCH\",\n            \"PURGE\",\n            \"MKCALENDAR\",\n            \"LINK\",\n            \"UNLINK\",\n            \"SOURCE\"\n        ];\n        var method_connect = methods.indexOf(\"CONNECT\");\n        HTTPParser.prototype.reinitialize = HTTPParser;\n        HTTPParser.prototype.close = HTTPParser.prototype.pause = HTTPParser.prototype.resume = HTTPParser.prototype.free = function() {};\n        HTTPParser.prototype._compatMode0_11 = false;\n        HTTPParser.prototype.getAsyncId = function() {\n            return 0;\n        };\n        var headerState = {\n            REQUEST_LINE: true,\n            RESPONSE_LINE: true,\n            HEADER: true\n        };\n        HTTPParser.prototype.execute = function(chunk, start, length) {\n            if (!(this instanceof HTTPParser)) {\n                throw new TypeError(\"not a HTTPParser\");\n            }\n            // backward compat to node < 0.11.4\n            // Note: the start and length params were removed in newer version\n            start = start || 0;\n            length = typeof length === \"number\" ? length : chunk.length;\n            this.chunk = chunk;\n            this.offset = start;\n            var end = this.end = start + length;\n            try {\n                while(this.offset < end){\n                    if (this[this.state]()) {\n                        break;\n                    }\n                }\n            } catch (err) {\n                if (this.isUserCall) {\n                    throw err;\n                }\n                this.hadError = true;\n                return err;\n            }\n            this.chunk = null;\n            length = this.offset - start;\n            if (headerState[this.state]) {\n                this.headerSize += length;\n                if (this.headerSize > (this.maxHeaderSize || HTTPParser.maxHeaderSize)) {\n                    return new Error(\"max header size exceeded\");\n                }\n            }\n            return length;\n        };\n        var stateFinishAllowed = {\n            REQUEST_LINE: true,\n            RESPONSE_LINE: true,\n            BODY_RAW: true\n        };\n        HTTPParser.prototype.finish = function() {\n            if (this.hadError) {\n                return;\n            }\n            if (!stateFinishAllowed[this.state]) {\n                return new Error(\"invalid state for EOF\");\n            }\n            if (this.state === \"BODY_RAW\") {\n                this.userCall()(this[kOnMessageComplete]());\n            }\n        };\n        // These three methods are used for an internal speed optimization, and it also\n        // works if theses are noops. Basically consume() asks us to read the bytes\n        // ourselves, but if we don't do it we get them through execute().\n        HTTPParser.prototype.consume = HTTPParser.prototype.unconsume = HTTPParser.prototype.getCurrentBuffer = function() {};\n        //For correct error handling - see HTTPParser#execute\n        //Usage: this.userCall()(userFunction('arg'));\n        HTTPParser.prototype.userCall = function() {\n            this.isUserCall = true;\n            var self1 = this;\n            return function(ret) {\n                self1.isUserCall = false;\n                return ret;\n            };\n        };\n        HTTPParser.prototype.nextRequest = function() {\n            this.userCall()(this[kOnMessageComplete]());\n            this.reinitialize(this.type);\n        };\n        HTTPParser.prototype.consumeLine = function() {\n            var end = this.end, chunk = this.chunk;\n            for(var i = this.offset; i < end; i++){\n                if (chunk[i] === 0x0a) {\n                    var line = this.line + chunk.toString(HTTPParser.encoding, this.offset, i);\n                    if (line.charAt(line.length - 1) === \"\\r\") {\n                        line = line.substr(0, line.length - 1);\n                    }\n                    this.line = \"\";\n                    this.offset = i + 1;\n                    return line;\n                }\n            }\n            //line split over multiple chunks\n            this.line += chunk.toString(HTTPParser.encoding, this.offset, this.end);\n            this.offset = this.end;\n        };\n        var headerExp = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\n        var headerContinueExp = /^[ \\t]+(.*[^ \\t])/;\n        HTTPParser.prototype.parseHeader = function(line, headers) {\n            if (line.indexOf(\"\\r\") !== -1) {\n                throw parseErrorCode(\"HPE_LF_EXPECTED\");\n            }\n            var match = headerExp.exec(line);\n            var k = match && match[1];\n            if (k) {\n                headers.push(k);\n                headers.push(match[2]);\n            } else {\n                var matchContinue = headerContinueExp.exec(line);\n                if (matchContinue && headers.length) {\n                    if (headers[headers.length - 1]) {\n                        headers[headers.length - 1] += \" \";\n                    }\n                    headers[headers.length - 1] += matchContinue[1];\n                }\n            }\n        };\n        var requestExp = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\n        HTTPParser.prototype.REQUEST_LINE = function() {\n            var line = this.consumeLine();\n            if (!line) {\n                return;\n            }\n            var match = requestExp.exec(line);\n            if (match === null) {\n                throw parseErrorCode(\"HPE_INVALID_CONSTANT\");\n            }\n            this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);\n            if (this.info.method === -1) {\n                throw new Error(\"invalid request method\");\n            }\n            this.info.url = match[2];\n            this.info.versionMajor = +match[3];\n            this.info.versionMinor = +match[4];\n            this.body_bytes = 0;\n            this.state = \"HEADER\";\n        };\n        var responseExp = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\n        HTTPParser.prototype.RESPONSE_LINE = function() {\n            var line = this.consumeLine();\n            if (!line) {\n                return;\n            }\n            var match = responseExp.exec(line);\n            if (match === null) {\n                throw parseErrorCode(\"HPE_INVALID_CONSTANT\");\n            }\n            this.info.versionMajor = +match[1];\n            this.info.versionMinor = +match[2];\n            var statusCode = this.info.statusCode = +match[3];\n            this.info.statusMessage = match[4];\n            // Implied zero length.\n            if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {\n                this.body_bytes = 0;\n            }\n            this.state = \"HEADER\";\n        };\n        HTTPParser.prototype.shouldKeepAlive = function() {\n            if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {\n                if (this.connection.indexOf(\"close\") !== -1) {\n                    return false;\n                }\n            } else if (this.connection.indexOf(\"keep-alive\") === -1) {\n                return false;\n            }\n            if (this.body_bytes !== null || this.isChunked) {\n                return true;\n            }\n            return false;\n        };\n        HTTPParser.prototype.HEADER = function() {\n            var line = this.consumeLine();\n            if (line === undefined) {\n                return;\n            }\n            var info = this.info;\n            if (line) {\n                this.parseHeader(line, info.headers);\n            } else {\n                var headers = info.headers;\n                var hasContentLength = false;\n                var currentContentLengthValue;\n                var hasUpgradeHeader = false;\n                for(var i = 0; i < headers.length; i += 2){\n                    switch(headers[i].toLowerCase()){\n                        case \"transfer-encoding\":\n                            this.isChunked = headers[i + 1].toLowerCase() === \"chunked\";\n                            break;\n                        case \"content-length\":\n                            currentContentLengthValue = +headers[i + 1];\n                            if (hasContentLength) {\n                                // Fix duplicate Content-Length header with same values.\n                                // Throw error only if values are different.\n                                // Known issues:\n                                // https://github.com/request/request/issues/2091#issuecomment-328715113\n                                // https://github.com/nodejs/node/issues/6517#issuecomment-216263771\n                                if (currentContentLengthValue !== this.body_bytes) {\n                                    throw parseErrorCode(\"HPE_UNEXPECTED_CONTENT_LENGTH\");\n                                }\n                            } else {\n                                hasContentLength = true;\n                                this.body_bytes = currentContentLengthValue;\n                            }\n                            break;\n                        case \"connection\":\n                            this.connection += headers[i + 1].toLowerCase();\n                            break;\n                        case \"upgrade\":\n                            hasUpgradeHeader = true;\n                            break;\n                    }\n                }\n                // if both isChunked and hasContentLength, isChunked wins\n                // This is required so the body is parsed using the chunked method, and matches\n                // Chrome's behavior.  We could, maybe, ignore them both (would get chunked\n                // encoding into the body), and/or disable shouldKeepAlive to be more\n                // resilient.\n                if (this.isChunked && hasContentLength) {\n                    hasContentLength = false;\n                    this.body_bytes = null;\n                }\n                // Logic from https://github.com/nodejs/http-parser/blob/921d5585515a153fa00e411cf144280c59b41f90/http_parser.c#L1727-L1737\n                // \"For responses, \"Upgrade: foo\" and \"Connection: upgrade\" are\n                //   mandatory only when it is a 101 Switching Protocols response,\n                //   otherwise it is purely informational, to announce support.\n                if (hasUpgradeHeader && this.connection.indexOf(\"upgrade\") != -1) {\n                    info.upgrade = this.type === HTTPParser.REQUEST || info.statusCode === 101;\n                } else {\n                    info.upgrade = info.method === method_connect;\n                }\n                if (this.isChunked && info.upgrade) {\n                    this.isChunked = false;\n                }\n                info.shouldKeepAlive = this.shouldKeepAlive();\n                //problem which also exists in original node: we should know skipBody before calling onHeadersComplete\n                var skipBody;\n                if (compatMode0_12) {\n                    skipBody = this.userCall()(this[kOnHeadersComplete](info));\n                } else {\n                    skipBody = this.userCall()(this[kOnHeadersComplete](info.versionMajor, info.versionMinor, info.headers, info.method, info.url, info.statusCode, info.statusMessage, info.upgrade, info.shouldKeepAlive));\n                }\n                if (skipBody === 2) {\n                    this.nextRequest();\n                    return true;\n                } else if (this.isChunked && !skipBody) {\n                    this.state = \"BODY_CHUNKHEAD\";\n                } else if (skipBody || this.body_bytes === 0) {\n                    this.nextRequest();\n                    // For older versions of node (v6.x and older?), that return skipBody=1 or skipBody=true,\n                    //   need this \"return true;\" if it's an upgrade request.\n                    return info.upgrade;\n                } else if (this.body_bytes === null) {\n                    this.state = \"BODY_RAW\";\n                } else {\n                    this.state = \"BODY_SIZED\";\n                }\n            }\n        };\n        HTTPParser.prototype.BODY_CHUNKHEAD = function() {\n            var line = this.consumeLine();\n            if (line === undefined) {\n                return;\n            }\n            this.body_bytes = parseInt(line, 16);\n            if (!this.body_bytes) {\n                this.state = \"BODY_CHUNKTRAILERS\";\n            } else {\n                this.state = \"BODY_CHUNK\";\n            }\n        };\n        HTTPParser.prototype.BODY_CHUNK = function() {\n            var length = Math.min(this.end - this.offset, this.body_bytes);\n            this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n            this.offset += length;\n            this.body_bytes -= length;\n            if (!this.body_bytes) {\n                this.state = \"BODY_CHUNKEMPTYLINE\";\n            }\n        };\n        HTTPParser.prototype.BODY_CHUNKEMPTYLINE = function() {\n            var line = this.consumeLine();\n            if (line === undefined) {\n                return;\n            }\n            assert.equal(line, \"\");\n            this.state = \"BODY_CHUNKHEAD\";\n        };\n        HTTPParser.prototype.BODY_CHUNKTRAILERS = function() {\n            var line = this.consumeLine();\n            if (line === undefined) {\n                return;\n            }\n            if (line) {\n                this.parseHeader(line, this.trailers);\n            } else {\n                if (this.trailers.length) {\n                    this.userCall()(this[kOnHeaders](this.trailers, \"\"));\n                }\n                this.nextRequest();\n            }\n        };\n        HTTPParser.prototype.BODY_RAW = function() {\n            var length = this.end - this.offset;\n            this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n            this.offset = this.end;\n        };\n        HTTPParser.prototype.BODY_SIZED = function() {\n            var length = Math.min(this.end - this.offset, this.body_bytes);\n            this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n            this.offset += length;\n            this.body_bytes -= length;\n            if (!this.body_bytes) {\n                this.nextRequest();\n            }\n        };\n        // backward compat to node < 0.11.6\n        [\n            \"Headers\",\n            \"HeadersComplete\",\n            \"Body\",\n            \"MessageComplete\"\n        ].forEach(function(name) {\n            var k = HTTPParser[\"kOn\" + name];\n            Object.defineProperty(HTTPParser.prototype, \"on\" + name, {\n                get: function() {\n                    return this[k];\n                },\n                set: function(to) {\n                    // hack for backward compatibility\n                    this._compatMode0_11 = true;\n                    method_connect = \"CONNECT\";\n                    return this[k] = to;\n                }\n            });\n        });\n        function parseErrorCode(code) {\n            var err = new Error(\"Parse Error\");\n            err.code = code;\n            return err;\n        }\n    /***/ },\n    /* 28 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! assert */ \"assert\");\n    /***/ },\n    /* 29 */ /***/ function(module1, exports, __nested_webpack_require_227694__) {\n        \"use strict\";\n        var Parser = __nested_webpack_require_227694__(30), Pipeline = __nested_webpack_require_227694__(31);\n        var Extensions = function() {\n            this._rsv1 = this._rsv2 = this._rsv3 = null;\n            this._byName = {};\n            this._inOrder = [];\n            this._sessions = [];\n            this._index = {};\n        };\n        Extensions.MESSAGE_OPCODES = [\n            1,\n            2\n        ];\n        var instance = {\n            add: function(ext) {\n                if (typeof ext.name !== \"string\") throw new TypeError(\"extension.name must be a string\");\n                if (ext.type !== \"permessage\") throw new TypeError('extension.type must be \"permessage\"');\n                if (typeof ext.rsv1 !== \"boolean\") throw new TypeError(\"extension.rsv1 must be true or false\");\n                if (typeof ext.rsv2 !== \"boolean\") throw new TypeError(\"extension.rsv2 must be true or false\");\n                if (typeof ext.rsv3 !== \"boolean\") throw new TypeError(\"extension.rsv3 must be true or false\");\n                if (this._byName.hasOwnProperty(ext.name)) throw new TypeError('An extension with name \"' + ext.name + '\" is already registered');\n                this._byName[ext.name] = ext;\n                this._inOrder.push(ext);\n            },\n            generateOffer: function() {\n                var sessions = [], offer = [], index = {};\n                this._inOrder.forEach(function(ext) {\n                    var session = ext.createClientSession();\n                    if (!session) return;\n                    var record = [\n                        ext,\n                        session\n                    ];\n                    sessions.push(record);\n                    index[ext.name] = record;\n                    var offers = session.generateOffer();\n                    offers = offers ? [].concat(offers) : [];\n                    offers.forEach(function(off) {\n                        offer.push(Parser.serializeParams(ext.name, off));\n                    }, this);\n                }, this);\n                this._sessions = sessions;\n                this._index = index;\n                return offer.length > 0 ? offer.join(\", \") : null;\n            },\n            activate: function(header) {\n                var responses = Parser.parseHeader(header), sessions = [];\n                responses.eachOffer(function(name, params) {\n                    var record = this._index[name];\n                    if (!record) throw new Error('Server sent an extension response for unknown extension \"' + name + '\"');\n                    var ext = record[0], session = record[1], reserved = this._reserved(ext);\n                    if (reserved) throw new Error(\"Server sent two extension responses that use the RSV\" + reserved[0] + ' bit: \"' + reserved[1] + '\" and \"' + ext.name + '\"');\n                    if (session.activate(params) !== true) throw new Error(\"Server sent unacceptable extension parameters: \" + Parser.serializeParams(name, params));\n                    this._reserve(ext);\n                    sessions.push(record);\n                }, this);\n                this._sessions = sessions;\n                this._pipeline = new Pipeline(sessions);\n            },\n            generateResponse: function(header) {\n                var sessions = [], response = [], offers = Parser.parseHeader(header);\n                this._inOrder.forEach(function(ext) {\n                    var offer = offers.byName(ext.name);\n                    if (offer.length === 0 || this._reserved(ext)) return;\n                    var session = ext.createServerSession(offer);\n                    if (!session) return;\n                    this._reserve(ext);\n                    sessions.push([\n                        ext,\n                        session\n                    ]);\n                    response.push(Parser.serializeParams(ext.name, session.generateResponse()));\n                }, this);\n                this._sessions = sessions;\n                this._pipeline = new Pipeline(sessions);\n                return response.length > 0 ? response.join(\", \") : null;\n            },\n            validFrameRsv: function(frame) {\n                var allowed = {\n                    rsv1: false,\n                    rsv2: false,\n                    rsv3: false\n                }, ext;\n                if (Extensions.MESSAGE_OPCODES.indexOf(frame.opcode) >= 0) {\n                    for(var i = 0, n = this._sessions.length; i < n; i++){\n                        ext = this._sessions[i][0];\n                        allowed.rsv1 = allowed.rsv1 || ext.rsv1;\n                        allowed.rsv2 = allowed.rsv2 || ext.rsv2;\n                        allowed.rsv3 = allowed.rsv3 || ext.rsv3;\n                    }\n                }\n                return (allowed.rsv1 || !frame.rsv1) && (allowed.rsv2 || !frame.rsv2) && (allowed.rsv3 || !frame.rsv3);\n            },\n            processIncomingMessage: function(message, callback, context) {\n                this._pipeline.processIncomingMessage(message, callback, context);\n            },\n            processOutgoingMessage: function(message, callback, context) {\n                this._pipeline.processOutgoingMessage(message, callback, context);\n            },\n            close: function(callback, context) {\n                if (!this._pipeline) return callback.call(context);\n                this._pipeline.close(callback, context);\n            },\n            _reserve: function(ext) {\n                this._rsv1 = this._rsv1 || ext.rsv1 && ext.name;\n                this._rsv2 = this._rsv2 || ext.rsv2 && ext.name;\n                this._rsv3 = this._rsv3 || ext.rsv3 && ext.name;\n            },\n            _reserved: function(ext) {\n                if (this._rsv1 && ext.rsv1) return [\n                    1,\n                    this._rsv1\n                ];\n                if (this._rsv2 && ext.rsv2) return [\n                    2,\n                    this._rsv2\n                ];\n                if (this._rsv3 && ext.rsv3) return [\n                    3,\n                    this._rsv3\n                ];\n                return false;\n            }\n        };\n        for(var key in instance)Extensions.prototype[key] = instance[key];\n        module1.exports = Extensions;\n    /***/ },\n    /* 30 */ /***/ function(module1, exports, __webpack_require__) {\n        \"use strict\";\n        var TOKEN = /([!#\\$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+)/, NOTOKEN = /([^!#\\$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z])/g, QUOTED = /\"((?:\\\\[\\x00-\\x7f]|[^\\x00-\\x08\\x0a-\\x1f\\x7f\"\\\\])*)\"/, PARAM = new RegExp(TOKEN.source + \"(?:=(?:\" + TOKEN.source + \"|\" + QUOTED.source + \"))?\"), EXT = new RegExp(TOKEN.source + \"(?: *; *\" + PARAM.source + \")*\", \"g\"), EXT_LIST = new RegExp(\"^\" + EXT.source + \"(?: *, *\" + EXT.source + \")*$\"), NUMBER = /^-?(0|[1-9][0-9]*)(\\.[0-9]+)?$/;\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var Parser = {\n            parseHeader: function(header) {\n                var offers = new Offers();\n                if (header === \"\" || header === undefined) return offers;\n                if (!EXT_LIST.test(header)) throw new SyntaxError(\"Invalid Sec-WebSocket-Extensions header: \" + header);\n                var values = header.match(EXT);\n                values.forEach(function(value) {\n                    var params = value.match(new RegExp(PARAM.source, \"g\")), name = params.shift(), offer = {};\n                    params.forEach(function(param) {\n                        var args = param.match(PARAM), key = args[1], data;\n                        if (args[2] !== undefined) {\n                            data = args[2];\n                        } else if (args[3] !== undefined) {\n                            data = args[3].replace(/\\\\/g, \"\");\n                        } else {\n                            data = true;\n                        }\n                        if (NUMBER.test(data)) data = parseFloat(data);\n                        if (hasOwnProperty.call(offer, key)) {\n                            offer[key] = [].concat(offer[key]);\n                            offer[key].push(data);\n                        } else {\n                            offer[key] = data;\n                        }\n                    }, this);\n                    offers.push(name, offer);\n                }, this);\n                return offers;\n            },\n            serializeParams: function(name, params) {\n                var values = [];\n                var print = function(key, value) {\n                    if (value instanceof Array) {\n                        value.forEach(function(v) {\n                            print(key, v);\n                        });\n                    } else if (value === true) {\n                        values.push(key);\n                    } else if (typeof value === \"number\") {\n                        values.push(key + \"=\" + value);\n                    } else if (NOTOKEN.test(value)) {\n                        values.push(key + '=\"' + value.replace(/\"/g, '\\\\\"') + '\"');\n                    } else {\n                        values.push(key + \"=\" + value);\n                    }\n                };\n                for(var key in params)print(key, params[key]);\n                return [\n                    name\n                ].concat(values).join(\"; \");\n            }\n        };\n        var Offers = function() {\n            this._byName = {};\n            this._inOrder = [];\n        };\n        Offers.prototype.push = function(name, params) {\n            if (!hasOwnProperty.call(this._byName, name)) this._byName[name] = [];\n            this._byName[name].push(params);\n            this._inOrder.push({\n                name: name,\n                params: params\n            });\n        };\n        Offers.prototype.eachOffer = function(callback, context) {\n            var list = this._inOrder;\n            for(var i = 0, n = list.length; i < n; i++)callback.call(context, list[i].name, list[i].params);\n        };\n        Offers.prototype.byName = function(name) {\n            return this._byName[name] || [];\n        };\n        Offers.prototype.toArray = function() {\n            return this._inOrder.slice();\n        };\n        module1.exports = Parser;\n    /***/ },\n    /* 31 */ /***/ function(module1, exports, __nested_webpack_require_237964__) {\n        \"use strict\";\n        var Cell = __nested_webpack_require_237964__(32), Pledge = __nested_webpack_require_237964__(14);\n        var Pipeline = function(sessions) {\n            this._cells = sessions.map(function(session) {\n                return new Cell(session);\n            });\n            this._stopped = {\n                incoming: false,\n                outgoing: false\n            };\n        };\n        Pipeline.prototype.processIncomingMessage = function(message, callback, context) {\n            if (this._stopped.incoming) return;\n            this._loop(\"incoming\", this._cells.length - 1, -1, -1, message, callback, context);\n        };\n        Pipeline.prototype.processOutgoingMessage = function(message, callback, context) {\n            if (this._stopped.outgoing) return;\n            this._loop(\"outgoing\", 0, this._cells.length, 1, message, callback, context);\n        };\n        Pipeline.prototype.close = function(callback, context) {\n            this._stopped = {\n                incoming: true,\n                outgoing: true\n            };\n            var closed = this._cells.map(function(a) {\n                return a.close();\n            });\n            if (callback) Pledge.all(closed).then(function() {\n                callback.call(context);\n            });\n        };\n        Pipeline.prototype._loop = function(direction, start, end, step, message, callback, context) {\n            var cells = this._cells, n = cells.length, self1 = this;\n            while(n--)cells[n].pending(direction);\n            var pipe = function(index, error, msg) {\n                if (index === end) return callback.call(context, error, msg);\n                cells[index][direction](error, msg, function(err, m) {\n                    if (err) self1._stopped[direction] = true;\n                    pipe(index + step, err, m);\n                });\n            };\n            pipe(start, null, message);\n        };\n        module1.exports = Pipeline;\n    /***/ },\n    /* 32 */ /***/ function(module1, exports, __nested_webpack_require_239980__) {\n        \"use strict\";\n        var Functor = __nested_webpack_require_239980__(33), Pledge = __nested_webpack_require_239980__(14);\n        var Cell = function(tuple) {\n            this._ext = tuple[0];\n            this._session = tuple[1];\n            this._functors = {\n                incoming: new Functor(this._session, \"processIncomingMessage\"),\n                outgoing: new Functor(this._session, \"processOutgoingMessage\")\n            };\n        };\n        Cell.prototype.pending = function(direction) {\n            var functor = this._functors[direction];\n            if (!functor._stopped) functor.pending += 1;\n        };\n        Cell.prototype.incoming = function(error, message, callback, context) {\n            this._exec(\"incoming\", error, message, callback, context);\n        };\n        Cell.prototype.outgoing = function(error, message, callback, context) {\n            this._exec(\"outgoing\", error, message, callback, context);\n        };\n        Cell.prototype.close = function() {\n            this._closed = this._closed || new Pledge();\n            this._doClose();\n            return this._closed;\n        };\n        Cell.prototype._exec = function(direction, error, message, callback, context) {\n            this._functors[direction].call(error, message, function(err, msg) {\n                if (err) err.message = this._ext.name + \": \" + err.message;\n                callback.call(context, err, msg);\n                this._doClose();\n            }, this);\n        };\n        Cell.prototype._doClose = function() {\n            var fin = this._functors.incoming, fout = this._functors.outgoing;\n            if (!this._closed || fin.pending + fout.pending !== 0) return;\n            if (this._session) this._session.close();\n            this._session = null;\n            this._closed.done();\n        };\n        module1.exports = Cell;\n    /***/ },\n    /* 33 */ /***/ function(module1, exports, __nested_webpack_require_241889__) {\n        \"use strict\";\n        var RingBuffer = __nested_webpack_require_241889__(13);\n        var Functor = function(session, method) {\n            this._session = session;\n            this._method = method;\n            this._queue = new RingBuffer(Functor.QUEUE_SIZE);\n            this._stopped = false;\n            this.pending = 0;\n        };\n        Functor.QUEUE_SIZE = 8;\n        Functor.prototype.call = function(error, message, callback, context) {\n            if (this._stopped) return;\n            var record = {\n                error: error,\n                message: message,\n                callback: callback,\n                context: context,\n                done: false\n            }, called = false, self1 = this;\n            this._queue.push(record);\n            if (record.error) {\n                record.done = true;\n                this._stop();\n                return this._flushQueue();\n            }\n            var handler = function(err, msg) {\n                if (!(called ^ (called = true))) return;\n                if (err) {\n                    self1._stop();\n                    record.error = err;\n                    record.message = null;\n                } else {\n                    record.message = msg;\n                }\n                record.done = true;\n                self1._flushQueue();\n            };\n            try {\n                this._session[this._method](message, handler);\n            } catch (err) {\n                handler(err);\n            }\n        };\n        Functor.prototype._stop = function() {\n            this.pending = this._queue.length;\n            this._stopped = true;\n        };\n        Functor.prototype._flushQueue = function() {\n            var queue = this._queue, record;\n            while(queue.length > 0 && queue.peek().done){\n                record = queue.shift();\n                if (record.error) {\n                    this.pending = 0;\n                    queue.clear();\n                } else {\n                    this.pending -= 1;\n                }\n                record.callback.call(record.context, record.error, record.message);\n            }\n        };\n        module1.exports = Functor;\n    /***/ },\n    /* 34 */ /***/ function(module1, exports, __webpack_require__) {\n        \"use strict\";\n        var Frame = function() {};\n        var instance = {\n            final: false,\n            rsv1: false,\n            rsv2: false,\n            rsv3: false,\n            opcode: null,\n            masked: false,\n            maskingKey: null,\n            lengthBytes: 1,\n            length: 0,\n            payload: null\n        };\n        for(var key in instance)Frame.prototype[key] = instance[key];\n        module1.exports = Frame;\n    /***/ },\n    /* 35 */ /***/ function(module1, exports, __nested_webpack_require_244675__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_244675__(1).Buffer;\n        var Message = function() {\n            this.rsv1 = false;\n            this.rsv2 = false;\n            this.rsv3 = false;\n            this.opcode = null;\n            this.length = 0;\n            this._chunks = [];\n        };\n        var instance = {\n            read: function() {\n                return this.data = this.data || Buffer1.concat(this._chunks, this.length);\n            },\n            pushFrame: function(frame) {\n                this.rsv1 = this.rsv1 || frame.rsv1;\n                this.rsv2 = this.rsv2 || frame.rsv2;\n                this.rsv3 = this.rsv3 || frame.rsv3;\n                if (this.opcode === null) this.opcode = frame.opcode;\n                this._chunks.push(frame.payload);\n                this.length += frame.length;\n            }\n        };\n        for(var key in instance)Message.prototype[key] = instance[key];\n        module1.exports = Message;\n    /***/ },\n    /* 36 */ /***/ function(module1, exports, __nested_webpack_require_245722__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_245722__(1).Buffer, Stream = __nested_webpack_require_245722__(5).Stream, url = __nested_webpack_require_245722__(6), util = __nested_webpack_require_245722__(0), Base = __nested_webpack_require_245722__(2), Headers = __nested_webpack_require_245722__(9), HttpParser = __nested_webpack_require_245722__(10);\n        var PORTS = {\n            \"ws:\": 80,\n            \"wss:\": 443\n        };\n        var Proxy = function(client, origin, options) {\n            this._client = client;\n            this._http = new HttpParser(\"response\");\n            this._origin = typeof client.url === \"object\" ? client.url : url.parse(client.url);\n            this._url = typeof origin === \"object\" ? origin : url.parse(origin);\n            this._options = options || {};\n            this._state = 0;\n            this.readable = this.writable = true;\n            this._paused = false;\n            this._headers = new Headers();\n            this._headers.set(\"Host\", this._origin.host);\n            this._headers.set(\"Connection\", \"keep-alive\");\n            this._headers.set(\"Proxy-Connection\", \"keep-alive\");\n            var auth = this._url.auth && Buffer1.from(this._url.auth, \"utf8\").toString(\"base64\");\n            if (auth) this._headers.set(\"Proxy-Authorization\", \"Basic \" + auth);\n        };\n        util.inherits(Proxy, Stream);\n        var instance = {\n            setHeader: function(name, value) {\n                if (this._state !== 0) return false;\n                this._headers.set(name, value);\n                return true;\n            },\n            start: function() {\n                if (this._state !== 0) return false;\n                this._state = 1;\n                var origin = this._origin, port = origin.port || PORTS[origin.protocol], start = \"CONNECT \" + origin.hostname + \":\" + port + \" HTTP/1.1\";\n                var headers = [\n                    start,\n                    this._headers.toString(),\n                    \"\"\n                ];\n                this.emit(\"data\", Buffer1.from(headers.join(\"\\r\\n\"), \"utf8\"));\n                return true;\n            },\n            pause: function() {\n                this._paused = true;\n            },\n            resume: function() {\n                this._paused = false;\n                this.emit(\"drain\");\n            },\n            write: function(chunk) {\n                if (!this.writable) return false;\n                this._http.parse(chunk);\n                if (!this._http.isComplete()) return !this._paused;\n                this.statusCode = this._http.statusCode;\n                this.headers = this._http.headers;\n                if (this.statusCode === 200) {\n                    this.emit(\"connect\", new Base.ConnectEvent());\n                } else {\n                    var message = \"Can't establish a connection to the server at \" + this._origin.href;\n                    this.emit(\"error\", new Error(message));\n                }\n                this.end();\n                return !this._paused;\n            },\n            end: function(chunk) {\n                if (!this.writable) return;\n                if (chunk !== undefined) this.write(chunk);\n                this.readable = this.writable = false;\n                this.emit(\"close\");\n                this.emit(\"end\");\n            },\n            destroy: function() {\n                this.end();\n            }\n        };\n        for(var key in instance)Proxy.prototype[key] = instance[key];\n        module1.exports = Proxy;\n    /***/ },\n    /* 37 */ /***/ function(module1, exports, __nested_webpack_require_249233__) {\n        \"use strict\";\n        var util = __nested_webpack_require_249233__(0), HttpParser = __nested_webpack_require_249233__(10), Base = __nested_webpack_require_249233__(2), Draft75 = __nested_webpack_require_249233__(15), Draft76 = __nested_webpack_require_249233__(38), Hybi = __nested_webpack_require_249233__(12);\n        var Server = function(options) {\n            Base.call(this, null, null, options);\n            this._http = new HttpParser(\"request\");\n        };\n        util.inherits(Server, Base);\n        var instance = {\n            EVENTS: [\n                \"open\",\n                \"message\",\n                \"error\",\n                \"close\",\n                \"ping\",\n                \"pong\"\n            ],\n            _bindEventListeners: function() {\n                this.messages.on(\"error\", function() {});\n                this.on(\"error\", function() {});\n            },\n            parse: function(chunk) {\n                if (this._delegate) return this._delegate.parse(chunk);\n                this._http.parse(chunk);\n                if (!this._http.isComplete()) return;\n                this.method = this._http.method;\n                this.url = this._http.url;\n                this.headers = this._http.headers;\n                this.body = this._http.body;\n                var self1 = this;\n                this._delegate = Server.http(this, this._options);\n                this._delegate.messages = this.messages;\n                this._delegate.io = this.io;\n                this._open();\n                this.EVENTS.forEach(function(event) {\n                    this._delegate.on(event, function(e) {\n                        self1.emit(event, e);\n                    });\n                }, this);\n                this.protocol = this._delegate.protocol;\n                this.version = this._delegate.version;\n                this.parse(this._http.body);\n                this.emit(\"connect\", new Base.ConnectEvent());\n            },\n            _open: function() {\n                this.__queue.forEach(function(msg) {\n                    this._delegate[msg[0]].apply(this._delegate, msg[1]);\n                }, this);\n                this.__queue = [];\n            }\n        };\n        [\n            \"addExtension\",\n            \"setHeader\",\n            \"start\",\n            \"frame\",\n            \"text\",\n            \"binary\",\n            \"ping\",\n            \"close\"\n        ].forEach(function(method) {\n            instance[method] = function() {\n                if (this._delegate) {\n                    return this._delegate[method].apply(this._delegate, arguments);\n                } else {\n                    this.__queue.push([\n                        method,\n                        arguments\n                    ]);\n                    return true;\n                }\n            };\n        });\n        for(var key in instance)Server.prototype[key] = instance[key];\n        Server.isSecureRequest = function(request) {\n            if (request.connection && request.connection.authorized !== undefined) return true;\n            if (request.socket && request.socket.secure) return true;\n            var headers = request.headers;\n            if (!headers) return false;\n            if (headers[\"https\"] === \"on\") return true;\n            if (headers[\"x-forwarded-ssl\"] === \"on\") return true;\n            if (headers[\"x-forwarded-scheme\"] === \"https\") return true;\n            if (headers[\"x-forwarded-proto\"] === \"https\") return true;\n            return false;\n        };\n        Server.determineUrl = function(request) {\n            var scheme = this.isSecureRequest(request) ? \"wss:\" : \"ws:\";\n            return scheme + \"//\" + request.headers.host + request.url;\n        };\n        Server.http = function(request, options) {\n            options = options || {};\n            if (options.requireMasking === undefined) options.requireMasking = true;\n            var headers = request.headers, version = headers[\"sec-websocket-version\"], key = headers[\"sec-websocket-key\"], key1 = headers[\"sec-websocket-key1\"], key2 = headers[\"sec-websocket-key2\"], url = this.determineUrl(request);\n            if (version || key) return new Hybi(request, url, options);\n            else if (key1 || key2) return new Draft76(request, url, options);\n            else return new Draft75(request, url, options);\n        };\n        module1.exports = Server;\n    /***/ },\n    /* 38 */ /***/ function(module1, exports, __nested_webpack_require_253598__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_253598__(1).Buffer, Base = __nested_webpack_require_253598__(2), Draft75 = __nested_webpack_require_253598__(15), crypto = __nested_webpack_require_253598__(3), util = __nested_webpack_require_253598__(0);\n        var numberFromKey = function(key) {\n            return parseInt((key.match(/[0-9]/g) || []).join(\"\"), 10);\n        };\n        var spacesInKey = function(key) {\n            return (key.match(/ /g) || []).length;\n        };\n        var Draft76 = function(request, url, options) {\n            Draft75.apply(this, arguments);\n            this._stage = -1;\n            this._body = [];\n            this.version = \"hixie-76\";\n            this._headers.clear();\n            this._headers.set(\"Upgrade\", \"WebSocket\");\n            this._headers.set(\"Connection\", \"Upgrade\");\n            this._headers.set(\"Sec-WebSocket-Origin\", this._request.headers.origin);\n            this._headers.set(\"Sec-WebSocket-Location\", this.url);\n        };\n        util.inherits(Draft76, Draft75);\n        var instance = {\n            BODY_SIZE: 8,\n            start: function() {\n                if (!Draft75.prototype.start.call(this)) return false;\n                this._started = true;\n                this._sendHandshakeBody();\n                return true;\n            },\n            close: function() {\n                if (this.readyState === 3) return false;\n                if (this.readyState === 1) this._write(Buffer1.from([\n                    0xFF,\n                    0x00\n                ]));\n                this.readyState = 3;\n                this.emit(\"close\", new Base.CloseEvent(null, null));\n                return true;\n            },\n            _handshakeResponse: function() {\n                var headers = this._request.headers, key1 = headers[\"sec-websocket-key1\"], key2 = headers[\"sec-websocket-key2\"];\n                if (!key1) throw new Error(\"Missing required header: Sec-WebSocket-Key1\");\n                if (!key2) throw new Error(\"Missing required header: Sec-WebSocket-Key2\");\n                var number1 = numberFromKey(key1), spaces1 = spacesInKey(key1), number2 = numberFromKey(key2), spaces2 = spacesInKey(key2);\n                if (number1 % spaces1 !== 0 || number2 % spaces2 !== 0) throw new Error(\"Client sent invalid Sec-WebSocket-Key headers\");\n                this._keyValues = [\n                    number1 / spaces1,\n                    number2 / spaces2\n                ];\n                var start = \"HTTP/1.1 101 WebSocket Protocol Handshake\", headers = [\n                    start,\n                    this._headers.toString(),\n                    \"\"\n                ];\n                return Buffer1.from(headers.join(\"\\r\\n\"), \"binary\");\n            },\n            _handshakeSignature: function() {\n                if (this._body.length < this.BODY_SIZE) return null;\n                var md5 = crypto.createHash(\"md5\"), buffer = Buffer1.allocUnsafe(8 + this.BODY_SIZE);\n                buffer.writeUInt32BE(this._keyValues[0], 0);\n                buffer.writeUInt32BE(this._keyValues[1], 4);\n                Buffer1.from(this._body).copy(buffer, 8, 0, this.BODY_SIZE);\n                md5.update(buffer);\n                return Buffer1.from(md5.digest(\"binary\"), \"binary\");\n            },\n            _sendHandshakeBody: function() {\n                if (!this._started) return;\n                var signature = this._handshakeSignature();\n                if (!signature) return;\n                this._write(signature);\n                this._stage = 0;\n                this._open();\n                if (this._body.length > this.BODY_SIZE) this.parse(this._body.slice(this.BODY_SIZE));\n            },\n            _parseLeadingByte: function(octet) {\n                if (octet !== 0xFF) return Draft75.prototype._parseLeadingByte.call(this, octet);\n                this._closing = true;\n                this._length = 0;\n                this._stage = 1;\n            }\n        };\n        for(var key in instance)Draft76.prototype[key] = instance[key];\n        module1.exports = Draft76;\n    /***/ },\n    /* 39 */ /***/ function(module1, exports, __nested_webpack_require_257702__) {\n        \"use strict\";\n        var util = __nested_webpack_require_257702__(0), net = __nested_webpack_require_257702__(40), tls = __nested_webpack_require_257702__(41), url = __nested_webpack_require_257702__(6), driver = __nested_webpack_require_257702__(4), API = __nested_webpack_require_257702__(11), Event = __nested_webpack_require_257702__(7);\n        var DEFAULT_PORTS = {\n            \"http:\": 80,\n            \"https:\": 443,\n            \"ws:\": 80,\n            \"wss:\": 443\n        }, SECURE_PROTOCOLS = [\n            \"https:\",\n            \"wss:\"\n        ];\n        var Client = function(_url, protocols, options) {\n            options = options || {};\n            this.url = _url;\n            this._driver = driver.client(this.url, {\n                maxLength: options.maxLength,\n                protocols: protocols\n            });\n            [\n                \"open\",\n                \"error\"\n            ].forEach(function(event) {\n                this._driver.on(event, function() {\n                    self1.headers = self1._driver.headers;\n                    self1.statusCode = self1._driver.statusCode;\n                });\n            }, this);\n            var proxy = options.proxy || {}, endpoint = url.parse(proxy.origin || this.url), port = endpoint.port || DEFAULT_PORTS[endpoint.protocol], secure = SECURE_PROTOCOLS.indexOf(endpoint.protocol) >= 0, onConnect = function() {\n                self1._onConnect();\n            }, netOptions = options.net || {}, originTLS = options.tls || {}, socketTLS = proxy.origin ? proxy.tls || {} : originTLS, self1 = this;\n            netOptions.host = socketTLS.host = endpoint.hostname;\n            netOptions.port = socketTLS.port = port;\n            originTLS.ca = originTLS.ca || options.ca;\n            socketTLS.servername = socketTLS.servername || endpoint.hostname;\n            this._stream = secure ? tls.connect(socketTLS, onConnect) : net.connect(netOptions, onConnect);\n            if (proxy.origin) this._configureProxy(proxy, originTLS);\n            API.call(this, options);\n        };\n        util.inherits(Client, API);\n        Client.prototype._onConnect = function() {\n            var worker = this._proxy || this._driver;\n            worker.start();\n        };\n        Client.prototype._configureProxy = function(proxy, originTLS) {\n            var uri = url.parse(this.url), secure = SECURE_PROTOCOLS.indexOf(uri.protocol) >= 0, self1 = this, name;\n            this._proxy = this._driver.proxy(proxy.origin);\n            if (proxy.headers) {\n                for(name in proxy.headers)this._proxy.setHeader(name, proxy.headers[name]);\n            }\n            this._proxy.pipe(this._stream, {\n                end: false\n            });\n            this._stream.pipe(this._proxy);\n            this._proxy.on(\"connect\", function() {\n                if (secure) {\n                    var options = {\n                        socket: self1._stream,\n                        servername: uri.hostname\n                    };\n                    for(name in originTLS)options[name] = originTLS[name];\n                    self1._stream = tls.connect(options);\n                    self1._configureStream();\n                }\n                self1._driver.io.pipe(self1._stream);\n                self1._stream.pipe(self1._driver.io);\n                self1._driver.start();\n            });\n            this._proxy.on(\"error\", function(error) {\n                self1._driver.emit(\"error\", error);\n            });\n        };\n        module1.exports = Client;\n    /***/ },\n    /* 40 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! net */ \"net\");\n    /***/ },\n    /* 41 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! tls */ \"tls\");\n    /***/ },\n    /* 42 */ /***/ function(module1, exports, __nested_webpack_require_261412__) {\n        \"use strict\";\n        var Stream = __nested_webpack_require_261412__(5).Stream, util = __nested_webpack_require_261412__(0), driver = __nested_webpack_require_261412__(4), Headers = __nested_webpack_require_261412__(9), API = __nested_webpack_require_261412__(11), EventTarget = __nested_webpack_require_261412__(16), Event = __nested_webpack_require_261412__(7);\n        var EventSource = function(request, response, options) {\n            this.writable = true;\n            options = options || {};\n            this._stream = response.socket;\n            this._ping = options.ping || this.DEFAULT_PING;\n            this._retry = options.retry || this.DEFAULT_RETRY;\n            var scheme = driver.isSecureRequest(request) ? \"https:\" : \"http:\";\n            this.url = scheme + \"//\" + request.headers.host + request.url;\n            this.lastEventId = request.headers[\"last-event-id\"] || \"\";\n            this.readyState = API.CONNECTING;\n            var headers = new Headers(), self1 = this;\n            if (options.headers) {\n                for(var key in options.headers)headers.set(key, options.headers[key]);\n            }\n            if (!this._stream || !this._stream.writable) return;\n            process.nextTick(function() {\n                self1._open();\n            });\n            this._stream.setTimeout(0);\n            this._stream.setNoDelay(true);\n            var handshake = \"HTTP/1.1 200 OK\\r\\n\" + \"Content-Type: text/event-stream\\r\\n\" + \"Cache-Control: no-cache, no-store\\r\\n\" + \"Connection: close\\r\\n\" + headers.toString() + \"\\r\\n\" + \"retry: \" + Math.floor(this._retry * 1000) + \"\\r\\n\\r\\n\";\n            this._write(handshake);\n            this._stream.on(\"drain\", function() {\n                self1.emit(\"drain\");\n            });\n            if (this._ping) this._pingTimer = setInterval(function() {\n                self1.ping();\n            }, this._ping * 1000);\n            [\n                \"error\",\n                \"end\"\n            ].forEach(function(event) {\n                self1._stream.on(event, function() {\n                    self1.close();\n                });\n            });\n        };\n        util.inherits(EventSource, Stream);\n        EventSource.isEventSource = function(request) {\n            if (request.method !== \"GET\") return false;\n            var accept = (request.headers.accept || \"\").split(/\\s*,\\s*/);\n            return accept.indexOf(\"text/event-stream\") >= 0;\n        };\n        var instance = {\n            DEFAULT_PING: 10,\n            DEFAULT_RETRY: 5,\n            _write: function(chunk) {\n                if (!this.writable) return false;\n                try {\n                    return this._stream.write(chunk, \"utf8\");\n                } catch (e) {\n                    return false;\n                }\n            },\n            _open: function() {\n                if (this.readyState !== API.CONNECTING) return;\n                this.readyState = API.OPEN;\n                var event = new Event(\"open\");\n                event.initEvent(\"open\", false, false);\n                this.dispatchEvent(event);\n            },\n            write: function(message) {\n                return this.send(message);\n            },\n            end: function(message) {\n                if (message !== undefined) this.write(message);\n                this.close();\n            },\n            send: function(message, options) {\n                if (this.readyState > API.OPEN) return false;\n                message = String(message).replace(/(\\r\\n|\\r|\\n)/g, \"$1data: \");\n                options = options || {};\n                var frame = \"\";\n                if (options.event) frame += \"event: \" + options.event + \"\\r\\n\";\n                if (options.id) frame += \"id: \" + options.id + \"\\r\\n\";\n                frame += \"data: \" + message + \"\\r\\n\\r\\n\";\n                return this._write(frame);\n            },\n            ping: function() {\n                return this._write(\":\\r\\n\\r\\n\");\n            },\n            close: function() {\n                if (this.readyState > API.OPEN) return false;\n                this.readyState = API.CLOSED;\n                this.writable = false;\n                if (this._pingTimer) clearInterval(this._pingTimer);\n                if (this._stream) this._stream.end();\n                var event = new Event(\"close\");\n                event.initEvent(\"close\", false, false);\n                this.dispatchEvent(event);\n                return true;\n            }\n        };\n        for(var method in instance)EventSource.prototype[method] = instance[method];\n        for(var key in EventTarget)EventSource.prototype[key] = EventTarget[key];\n        module1.exports = EventSource;\n    /***/ },\n    /* 43 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! child_process */ \"child_process\");\n    /***/ },\n    /* 44 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! fs */ \"fs\");\n    /***/ },\n    /* 45 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! http */ \"http\");\n    /***/ },\n    /* 46 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! https */ \"https\");\n    /***/ },\n    /* 47 */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_266496__) {\n        \"use strict\";\n        // ESM COMPAT FLAG\n        __nested_webpack_require_266496__.r(__nested_webpack_exports__);\n        // EXPORTS\n        __nested_webpack_require_266496__.d(__nested_webpack_exports__, \"default\", function() {\n            return /* binding */ pusher_with_encryption_PusherWithEncryption;\n        });\n        // CONCATENATED MODULE: ./src/core/base64.ts\n        function encode(s) {\n            return btoa(utob(s));\n        }\n        var fromCharCode = String.fromCharCode;\n        var b64chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n        var b64tab = {};\n        for(var base64_i = 0, l = b64chars.length; base64_i < l; base64_i++){\n            b64tab[b64chars.charAt(base64_i)] = base64_i;\n        }\n        var cb_utob = function(c) {\n            var cc = c.charCodeAt(0);\n            return cc < 0x80 ? c : cc < 0x800 ? fromCharCode(0xc0 | cc >>> 6) + fromCharCode(0x80 | cc & 0x3f) : fromCharCode(0xe0 | cc >>> 12 & 0x0f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);\n        };\n        var utob = function(u) {\n            return u.replace(/[^\\x00-\\x7F]/g, cb_utob);\n        };\n        var cb_encode = function(ccc) {\n            var padlen = [\n                0,\n                2,\n                1\n            ][ccc.length % 3];\n            var ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0);\n            var chars = [\n                b64chars.charAt(ord >>> 18),\n                b64chars.charAt(ord >>> 12 & 63),\n                padlen >= 2 ? \"=\" : b64chars.charAt(ord >>> 6 & 63),\n                padlen >= 1 ? \"=\" : b64chars.charAt(ord & 63)\n            ];\n            return chars.join(\"\");\n        };\n        var btoa = global.btoa || function(b) {\n            return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n        };\n        // CONCATENATED MODULE: ./src/core/utils/timers/abstract_timer.ts\n        class Timer {\n            constructor(set, clear, delay, callback){\n                this.clear = clear;\n                this.timer = set(()=>{\n                    if (this.timer) {\n                        this.timer = callback(this.timer);\n                    }\n                }, delay);\n            }\n            isRunning() {\n                return this.timer !== null;\n            }\n            ensureAborted() {\n                if (this.timer) {\n                    this.clear(this.timer);\n                    this.timer = null;\n                }\n            }\n        }\n        /* harmony default export */ var abstract_timer = Timer;\n        // CONCATENATED MODULE: ./src/core/utils/timers/index.ts\n        function timers_clearTimeout(timer) {\n            global.clearTimeout(timer);\n        }\n        function timers_clearInterval(timer) {\n            global.clearInterval(timer);\n        }\n        class timers_OneOffTimer extends abstract_timer {\n            constructor(delay, callback){\n                super(setTimeout, timers_clearTimeout, delay, function(timer) {\n                    callback();\n                    return null;\n                });\n            }\n        }\n        class timers_PeriodicTimer extends abstract_timer {\n            constructor(delay, callback){\n                super(setInterval, timers_clearInterval, delay, function(timer) {\n                    callback();\n                    return timer;\n                });\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/util.ts\n        var Util = {\n            now () {\n                if (Date.now) {\n                    return Date.now();\n                } else {\n                    return new Date().valueOf();\n                }\n            },\n            defer (callback) {\n                return new timers_OneOffTimer(0, callback);\n            },\n            method (name, ...args) {\n                var boundArguments = Array.prototype.slice.call(arguments, 1);\n                return function(object) {\n                    return object[name].apply(object, boundArguments.concat(arguments));\n                };\n            }\n        };\n        /* harmony default export */ var util = Util;\n        // CONCATENATED MODULE: ./src/core/utils/collections.ts\n        function extend(target, ...sources) {\n            for(var i = 0; i < sources.length; i++){\n                var extensions = sources[i];\n                for(var property in extensions){\n                    if (extensions[property] && extensions[property].constructor && extensions[property].constructor === Object) {\n                        target[property] = extend(target[property] || {}, extensions[property]);\n                    } else {\n                        target[property] = extensions[property];\n                    }\n                }\n            }\n            return target;\n        }\n        function stringify() {\n            var m = [\n                \"Pusher\"\n            ];\n            for(var i = 0; i < arguments.length; i++){\n                if (typeof arguments[i] === \"string\") {\n                    m.push(arguments[i]);\n                } else {\n                    m.push(safeJSONStringify(arguments[i]));\n                }\n            }\n            return m.join(\" : \");\n        }\n        function arrayIndexOf(array, item) {\n            var nativeIndexOf = Array.prototype.indexOf;\n            if (array === null) {\n                return -1;\n            }\n            if (nativeIndexOf && array.indexOf === nativeIndexOf) {\n                return array.indexOf(item);\n            }\n            for(var i = 0, l = array.length; i < l; i++){\n                if (array[i] === item) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n        function objectApply(object, f) {\n            for(var key in object){\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    f(object[key], key, object);\n                }\n            }\n        }\n        function keys(object) {\n            var keys = [];\n            objectApply(object, function(_, key) {\n                keys.push(key);\n            });\n            return keys;\n        }\n        function values(object) {\n            var values = [];\n            objectApply(object, function(value) {\n                values.push(value);\n            });\n            return values;\n        }\n        function apply(array, f, context) {\n            for(var i = 0; i < array.length; i++){\n                f.call(context || global, array[i], i, array);\n            }\n        }\n        function map(array, f) {\n            var result = [];\n            for(var i = 0; i < array.length; i++){\n                result.push(f(array[i], i, array, result));\n            }\n            return result;\n        }\n        function mapObject(object, f) {\n            var result = {};\n            objectApply(object, function(value, key) {\n                result[key] = f(value);\n            });\n            return result;\n        }\n        function filter(array, test) {\n            test = test || function(value) {\n                return !!value;\n            };\n            var result = [];\n            for(var i = 0; i < array.length; i++){\n                if (test(array[i], i, array, result)) {\n                    result.push(array[i]);\n                }\n            }\n            return result;\n        }\n        function filterObject(object, test) {\n            var result = {};\n            objectApply(object, function(value, key) {\n                if (test && test(value, key, object, result) || Boolean(value)) {\n                    result[key] = value;\n                }\n            });\n            return result;\n        }\n        function flatten(object) {\n            var result = [];\n            objectApply(object, function(value, key) {\n                result.push([\n                    key,\n                    value\n                ]);\n            });\n            return result;\n        }\n        function any(array, test) {\n            for(var i = 0; i < array.length; i++){\n                if (test(array[i], i, array)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function collections_all(array, test) {\n            for(var i = 0; i < array.length; i++){\n                if (!test(array[i], i, array)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        function encodeParamsObject(data) {\n            return mapObject(data, function(value) {\n                if (typeof value === \"object\") {\n                    value = safeJSONStringify(value);\n                }\n                return encodeURIComponent(encode(value.toString()));\n            });\n        }\n        function buildQueryString(data) {\n            var params = filterObject(data, function(value) {\n                return value !== undefined;\n            });\n            var query = map(flatten(encodeParamsObject(params)), util.method(\"join\", \"=\")).join(\"&\");\n            return query;\n        }\n        function decycleObject(object) {\n            var objects = [], paths = [];\n            return function derez(value, path) {\n                var i, name, nu;\n                switch(typeof value){\n                    case \"object\":\n                        if (!value) {\n                            return null;\n                        }\n                        for(i = 0; i < objects.length; i += 1){\n                            if (objects[i] === value) {\n                                return {\n                                    $ref: paths[i]\n                                };\n                            }\n                        }\n                        objects.push(value);\n                        paths.push(path);\n                        if (Object.prototype.toString.apply(value) === \"[object Array]\") {\n                            nu = [];\n                            for(i = 0; i < value.length; i += 1){\n                                nu[i] = derez(value[i], path + \"[\" + i + \"]\");\n                            }\n                        } else {\n                            nu = {};\n                            for(name in value){\n                                if (Object.prototype.hasOwnProperty.call(value, name)) {\n                                    nu[name] = derez(value[name], path + \"[\" + JSON.stringify(name) + \"]\");\n                                }\n                            }\n                        }\n                        return nu;\n                    case \"number\":\n                    case \"string\":\n                    case \"boolean\":\n                        return value;\n                }\n            }(object, \"$\");\n        }\n        function safeJSONStringify(source) {\n            try {\n                return JSON.stringify(source);\n            } catch (e) {\n                return JSON.stringify(decycleObject(source));\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/defaults.ts\n        var Defaults = {\n            VERSION: \"8.4.0-rc2\",\n            PROTOCOL: 7,\n            wsPort: 80,\n            wssPort: 443,\n            wsPath: \"\",\n            httpHost: \"sockjs.pusher.com\",\n            httpPort: 80,\n            httpsPort: 443,\n            httpPath: \"/pusher\",\n            stats_host: \"stats.pusher.com\",\n            authEndpoint: \"/pusher/auth\",\n            authTransport: \"ajax\",\n            activityTimeout: 120000,\n            pongTimeout: 30000,\n            unavailableTimeout: 10000,\n            userAuthentication: {\n                endpoint: \"/pusher/user-auth\",\n                transport: \"ajax\"\n            },\n            channelAuthorization: {\n                endpoint: \"/pusher/auth\",\n                transport: \"ajax\"\n            },\n            cdn_http: \"http://js.pusher.com\",\n            cdn_https: \"https://js.pusher.com\",\n            dependency_suffix: \"\"\n        };\n        /* harmony default export */ var defaults = Defaults;\n        // CONCATENATED MODULE: ./src/core/transports/url_schemes.ts\n        function getGenericURL(baseScheme, params, path) {\n            var scheme = baseScheme + (params.useTLS ? \"s\" : \"\");\n            var host = params.useTLS ? params.hostTLS : params.hostNonTLS;\n            return scheme + \"://\" + host + path;\n        }\n        function getGenericPath(key, queryString) {\n            var path = \"/app/\" + key;\n            var query = \"?protocol=\" + defaults.PROTOCOL + \"&client=js\" + \"&version=\" + defaults.VERSION + (queryString ? \"&\" + queryString : \"\");\n            return path + query;\n        }\n        var ws = {\n            getInitial: function(key, params) {\n                var path = (params.httpPath || \"\") + getGenericPath(key, \"flash=false\");\n                return getGenericURL(\"ws\", params, path);\n            }\n        };\n        var http = {\n            getInitial: function(key, params) {\n                var path = (params.httpPath || \"/pusher\") + getGenericPath(key);\n                return getGenericURL(\"http\", params, path);\n            }\n        };\n        var sockjs = {\n            getInitial: function(key, params) {\n                return getGenericURL(\"http\", params, params.httpPath || \"/pusher\");\n            },\n            getPath: function(key, params) {\n                return getGenericPath(key);\n            }\n        };\n        // CONCATENATED MODULE: ./src/core/events/callback_registry.ts\n        class callback_registry_CallbackRegistry {\n            constructor(){\n                this._callbacks = {};\n            }\n            get(name) {\n                return this._callbacks[prefix(name)];\n            }\n            add(name, callback, context) {\n                var prefixedEventName = prefix(name);\n                this._callbacks[prefixedEventName] = this._callbacks[prefixedEventName] || [];\n                this._callbacks[prefixedEventName].push({\n                    fn: callback,\n                    context: context\n                });\n            }\n            remove(name, callback, context) {\n                if (!name && !callback && !context) {\n                    this._callbacks = {};\n                    return;\n                }\n                var names = name ? [\n                    prefix(name)\n                ] : keys(this._callbacks);\n                if (callback || context) {\n                    this.removeCallback(names, callback, context);\n                } else {\n                    this.removeAllCallbacks(names);\n                }\n            }\n            removeCallback(names, callback, context) {\n                apply(names, function(name) {\n                    this._callbacks[name] = filter(this._callbacks[name] || [], function(binding) {\n                        return callback && callback !== binding.fn || context && context !== binding.context;\n                    });\n                    if (this._callbacks[name].length === 0) {\n                        delete this._callbacks[name];\n                    }\n                }, this);\n            }\n            removeAllCallbacks(names) {\n                apply(names, function(name) {\n                    delete this._callbacks[name];\n                }, this);\n            }\n        }\n        function prefix(name) {\n            return \"_\" + name;\n        }\n        // CONCATENATED MODULE: ./src/core/events/dispatcher.ts\n        class dispatcher_Dispatcher {\n            constructor(failThrough){\n                this.callbacks = new callback_registry_CallbackRegistry();\n                this.global_callbacks = [];\n                this.failThrough = failThrough;\n            }\n            bind(eventName, callback, context) {\n                this.callbacks.add(eventName, callback, context);\n                return this;\n            }\n            bind_global(callback) {\n                this.global_callbacks.push(callback);\n                return this;\n            }\n            unbind(eventName, callback, context) {\n                this.callbacks.remove(eventName, callback, context);\n                return this;\n            }\n            unbind_global(callback) {\n                if (!callback) {\n                    this.global_callbacks = [];\n                    return this;\n                }\n                this.global_callbacks = filter(this.global_callbacks || [], (c)=>c !== callback);\n                return this;\n            }\n            unbind_all() {\n                this.unbind();\n                this.unbind_global();\n                return this;\n            }\n            emit(eventName, data, metadata) {\n                for(var i = 0; i < this.global_callbacks.length; i++){\n                    this.global_callbacks[i](eventName, data);\n                }\n                var callbacks = this.callbacks.get(eventName);\n                var args = [];\n                if (metadata) {\n                    args.push(data, metadata);\n                } else if (data) {\n                    args.push(data);\n                }\n                if (callbacks && callbacks.length > 0) {\n                    for(var i = 0; i < callbacks.length; i++){\n                        callbacks[i].fn.apply(callbacks[i].context || global, args);\n                    }\n                } else if (this.failThrough) {\n                    this.failThrough(eventName, data);\n                }\n                return this;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/logger.ts\n        class logger_Logger {\n            constructor(){\n                this.globalLog = (message)=>{\n                    if (global.console && global.console.log) {\n                        global.console.log(message);\n                    }\n                };\n            }\n            debug(...args) {\n                this.log(this.globalLog, args);\n            }\n            warn(...args) {\n                this.log(this.globalLogWarn, args);\n            }\n            error(...args) {\n                this.log(this.globalLogError, args);\n            }\n            globalLogWarn(message) {\n                if (global.console && global.console.warn) {\n                    global.console.warn(message);\n                } else {\n                    this.globalLog(message);\n                }\n            }\n            globalLogError(message) {\n                if (global.console && global.console.error) {\n                    global.console.error(message);\n                } else {\n                    this.globalLogWarn(message);\n                }\n            }\n            log(defaultLoggingFunction, ...args) {\n                var message = stringify.apply(this, arguments);\n                if (core_pusher.log) {\n                    core_pusher.log(message);\n                } else if (core_pusher.logToConsole) {\n                    const log = defaultLoggingFunction.bind(this);\n                    log(message);\n                }\n            }\n        }\n        /* harmony default export */ var logger = new logger_Logger();\n        // CONCATENATED MODULE: ./src/core/transports/transport_connection.ts\n        class transport_connection_TransportConnection extends dispatcher_Dispatcher {\n            constructor(hooks, name, priority, key, options){\n                super();\n                this.initialize = node_runtime.transportConnectionInitializer;\n                this.hooks = hooks;\n                this.name = name;\n                this.priority = priority;\n                this.key = key;\n                this.options = options;\n                this.state = \"new\";\n                this.timeline = options.timeline;\n                this.activityTimeout = options.activityTimeout;\n                this.id = this.timeline.generateUniqueID();\n            }\n            handlesActivityChecks() {\n                return Boolean(this.hooks.handlesActivityChecks);\n            }\n            supportsPing() {\n                return Boolean(this.hooks.supportsPing);\n            }\n            connect() {\n                if (this.socket || this.state !== \"initialized\") {\n                    return false;\n                }\n                var url = this.hooks.urls.getInitial(this.key, this.options);\n                try {\n                    this.socket = this.hooks.getSocket(url, this.options);\n                } catch (e) {\n                    util.defer(()=>{\n                        this.onError(e);\n                        this.changeState(\"closed\");\n                    });\n                    return false;\n                }\n                this.bindListeners();\n                logger.debug(\"Connecting\", {\n                    transport: this.name,\n                    url\n                });\n                this.changeState(\"connecting\");\n                return true;\n            }\n            close() {\n                if (this.socket) {\n                    this.socket.close();\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n            send(data) {\n                if (this.state === \"open\") {\n                    util.defer(()=>{\n                        if (this.socket) {\n                            this.socket.send(data);\n                        }\n                    });\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n            ping() {\n                if (this.state === \"open\" && this.supportsPing()) {\n                    this.socket.ping();\n                }\n            }\n            onOpen() {\n                if (this.hooks.beforeOpen) {\n                    this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options));\n                }\n                this.changeState(\"open\");\n                this.socket.onopen = undefined;\n            }\n            onError(error) {\n                this.emit(\"error\", {\n                    type: \"WebSocketError\",\n                    error: error\n                });\n                this.timeline.error(this.buildTimelineMessage({\n                    error: error.toString()\n                }));\n            }\n            onClose(closeEvent) {\n                if (closeEvent) {\n                    this.changeState(\"closed\", {\n                        code: closeEvent.code,\n                        reason: closeEvent.reason,\n                        wasClean: closeEvent.wasClean\n                    });\n                } else {\n                    this.changeState(\"closed\");\n                }\n                this.unbindListeners();\n                this.socket = undefined;\n            }\n            onMessage(message) {\n                this.emit(\"message\", message);\n            }\n            onActivity() {\n                this.emit(\"activity\");\n            }\n            bindListeners() {\n                this.socket.onopen = ()=>{\n                    this.onOpen();\n                };\n                this.socket.onerror = (error)=>{\n                    this.onError(error);\n                };\n                this.socket.onclose = (closeEvent)=>{\n                    this.onClose(closeEvent);\n                };\n                this.socket.onmessage = (message)=>{\n                    this.onMessage(message);\n                };\n                if (this.supportsPing()) {\n                    this.socket.onactivity = ()=>{\n                        this.onActivity();\n                    };\n                }\n            }\n            unbindListeners() {\n                if (this.socket) {\n                    this.socket.onopen = undefined;\n                    this.socket.onerror = undefined;\n                    this.socket.onclose = undefined;\n                    this.socket.onmessage = undefined;\n                    if (this.supportsPing()) {\n                        this.socket.onactivity = undefined;\n                    }\n                }\n            }\n            changeState(state, params) {\n                this.state = state;\n                this.timeline.info(this.buildTimelineMessage({\n                    state: state,\n                    params: params\n                }));\n                this.emit(state, params);\n            }\n            buildTimelineMessage(message) {\n                return extend({\n                    cid: this.id\n                }, message);\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/transports/transport.ts\n        class transport_Transport {\n            constructor(hooks){\n                this.hooks = hooks;\n            }\n            isSupported(environment) {\n                return this.hooks.isSupported(environment);\n            }\n            createConnection(name, priority, key, options) {\n                return new transport_connection_TransportConnection(this.hooks, name, priority, key, options);\n            }\n        }\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/transports/transports.ts\n        var WSTransport = new transport_Transport({\n            urls: ws,\n            handlesActivityChecks: false,\n            supportsPing: false,\n            isInitialized: function() {\n                return Boolean(node_runtime.getWebSocketAPI());\n            },\n            isSupported: function() {\n                return Boolean(node_runtime.getWebSocketAPI());\n            },\n            getSocket: function(url) {\n                return node_runtime.createWebSocket(url);\n            }\n        });\n        var httpConfiguration = {\n            urls: http,\n            handlesActivityChecks: false,\n            supportsPing: true,\n            isInitialized: function() {\n                return true;\n            }\n        };\n        var streamingConfiguration = extend({\n            getSocket: function(url) {\n                return node_runtime.HTTPFactory.createStreamingSocket(url);\n            }\n        }, httpConfiguration);\n        var pollingConfiguration = extend({\n            getSocket: function(url) {\n                return node_runtime.HTTPFactory.createPollingSocket(url);\n            }\n        }, httpConfiguration);\n        var xhrConfiguration = {\n            isSupported: function() {\n                return node_runtime.isXHRSupported();\n            }\n        };\n        var XHRStreamingTransport = new transport_Transport(extend({}, streamingConfiguration, xhrConfiguration));\n        var XHRPollingTransport = new transport_Transport(extend({}, pollingConfiguration, xhrConfiguration));\n        var Transports = {\n            ws: WSTransport,\n            xhr_streaming: XHRStreamingTransport,\n            xhr_polling: XHRPollingTransport\n        };\n        /* harmony default export */ var transports = Transports;\n        // CONCATENATED MODULE: ./src/core/transports/assistant_to_the_transport_manager.ts\n        class assistant_to_the_transport_manager_AssistantToTheTransportManager {\n            constructor(manager, transport, options){\n                this.manager = manager;\n                this.transport = transport;\n                this.minPingDelay = options.minPingDelay;\n                this.maxPingDelay = options.maxPingDelay;\n                this.pingDelay = undefined;\n            }\n            createConnection(name, priority, key, options) {\n                options = extend({}, options, {\n                    activityTimeout: this.pingDelay\n                });\n                var connection = this.transport.createConnection(name, priority, key, options);\n                var openTimestamp = null;\n                var onOpen = function() {\n                    connection.unbind(\"open\", onOpen);\n                    connection.bind(\"closed\", onClosed);\n                    openTimestamp = util.now();\n                };\n                var onClosed = (closeEvent)=>{\n                    connection.unbind(\"closed\", onClosed);\n                    if (closeEvent.code === 1002 || closeEvent.code === 1003) {\n                        this.manager.reportDeath();\n                    } else if (!closeEvent.wasClean && openTimestamp) {\n                        var lifespan = util.now() - openTimestamp;\n                        if (lifespan < 2 * this.maxPingDelay) {\n                            this.manager.reportDeath();\n                            this.pingDelay = Math.max(lifespan / 2, this.minPingDelay);\n                        }\n                    }\n                };\n                connection.bind(\"open\", onOpen);\n                return connection;\n            }\n            isSupported(environment) {\n                return this.manager.isAlive() && this.transport.isSupported(environment);\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/connection/protocol/protocol.ts\n        const Protocol = {\n            decodeMessage: function(messageEvent) {\n                try {\n                    var messageData = JSON.parse(messageEvent.data);\n                    var pusherEventData = messageData.data;\n                    if (typeof pusherEventData === \"string\") {\n                        try {\n                            pusherEventData = JSON.parse(messageData.data);\n                        } catch (e) {}\n                    }\n                    var pusherEvent = {\n                        event: messageData.event,\n                        channel: messageData.channel,\n                        data: pusherEventData\n                    };\n                    if (messageData.user_id) {\n                        pusherEvent.user_id = messageData.user_id;\n                    }\n                    return pusherEvent;\n                } catch (e) {\n                    throw {\n                        type: \"MessageParseError\",\n                        error: e,\n                        data: messageEvent.data\n                    };\n                }\n            },\n            encodeMessage: function(event) {\n                return JSON.stringify(event);\n            },\n            processHandshake: function(messageEvent) {\n                var message = Protocol.decodeMessage(messageEvent);\n                if (message.event === \"pusher:connection_established\") {\n                    if (!message.data.activity_timeout) {\n                        throw \"No activity timeout specified in handshake\";\n                    }\n                    return {\n                        action: \"connected\",\n                        id: message.data.socket_id,\n                        activityTimeout: message.data.activity_timeout * 1000\n                    };\n                } else if (message.event === \"pusher:error\") {\n                    return {\n                        action: this.getCloseAction(message.data),\n                        error: this.getCloseError(message.data)\n                    };\n                } else {\n                    throw \"Invalid handshake\";\n                }\n            },\n            getCloseAction: function(closeEvent) {\n                if (closeEvent.code < 4000) {\n                    if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {\n                        return \"backoff\";\n                    } else {\n                        return null;\n                    }\n                } else if (closeEvent.code === 4000) {\n                    return \"tls_only\";\n                } else if (closeEvent.code < 4100) {\n                    return \"refused\";\n                } else if (closeEvent.code < 4200) {\n                    return \"backoff\";\n                } else if (closeEvent.code < 4300) {\n                    return \"retry\";\n                } else {\n                    return \"refused\";\n                }\n            },\n            getCloseError: function(closeEvent) {\n                if (closeEvent.code !== 1000 && closeEvent.code !== 1001) {\n                    return {\n                        type: \"PusherError\",\n                        data: {\n                            code: closeEvent.code,\n                            message: closeEvent.reason || closeEvent.message\n                        }\n                    };\n                } else {\n                    return null;\n                }\n            }\n        };\n        /* harmony default export */ var protocol = Protocol;\n        // CONCATENATED MODULE: ./src/core/connection/connection.ts\n        class connection_Connection extends dispatcher_Dispatcher {\n            constructor(id, transport){\n                super();\n                this.id = id;\n                this.transport = transport;\n                this.activityTimeout = transport.activityTimeout;\n                this.bindListeners();\n            }\n            handlesActivityChecks() {\n                return this.transport.handlesActivityChecks();\n            }\n            send(data) {\n                return this.transport.send(data);\n            }\n            send_event(name, data, channel) {\n                var event = {\n                    event: name,\n                    data: data\n                };\n                if (channel) {\n                    event.channel = channel;\n                }\n                logger.debug(\"Event sent\", event);\n                return this.send(protocol.encodeMessage(event));\n            }\n            ping() {\n                if (this.transport.supportsPing()) {\n                    this.transport.ping();\n                } else {\n                    this.send_event(\"pusher:ping\", {});\n                }\n            }\n            close() {\n                this.transport.close();\n            }\n            bindListeners() {\n                var listeners = {\n                    message: (messageEvent)=>{\n                        var pusherEvent;\n                        try {\n                            pusherEvent = protocol.decodeMessage(messageEvent);\n                        } catch (e) {\n                            this.emit(\"error\", {\n                                type: \"MessageParseError\",\n                                error: e,\n                                data: messageEvent.data\n                            });\n                        }\n                        if (pusherEvent !== undefined) {\n                            logger.debug(\"Event recd\", pusherEvent);\n                            switch(pusherEvent.event){\n                                case \"pusher:error\":\n                                    this.emit(\"error\", {\n                                        type: \"PusherError\",\n                                        data: pusherEvent.data\n                                    });\n                                    break;\n                                case \"pusher:ping\":\n                                    this.emit(\"ping\");\n                                    break;\n                                case \"pusher:pong\":\n                                    this.emit(\"pong\");\n                                    break;\n                            }\n                            this.emit(\"message\", pusherEvent);\n                        }\n                    },\n                    activity: ()=>{\n                        this.emit(\"activity\");\n                    },\n                    error: (error)=>{\n                        this.emit(\"error\", error);\n                    },\n                    closed: (closeEvent)=>{\n                        unbindListeners();\n                        if (closeEvent && closeEvent.code) {\n                            this.handleCloseEvent(closeEvent);\n                        }\n                        this.transport = null;\n                        this.emit(\"closed\");\n                    }\n                };\n                var unbindListeners = ()=>{\n                    objectApply(listeners, (listener, event)=>{\n                        this.transport.unbind(event, listener);\n                    });\n                };\n                objectApply(listeners, (listener, event)=>{\n                    this.transport.bind(event, listener);\n                });\n            }\n            handleCloseEvent(closeEvent) {\n                var action = protocol.getCloseAction(closeEvent);\n                var error = protocol.getCloseError(closeEvent);\n                if (error) {\n                    this.emit(\"error\", error);\n                }\n                if (action) {\n                    this.emit(action, {\n                        action: action,\n                        error: error\n                    });\n                }\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/connection/handshake/index.ts\n        class handshake_Handshake {\n            constructor(transport, callback){\n                this.transport = transport;\n                this.callback = callback;\n                this.bindListeners();\n            }\n            close() {\n                this.unbindListeners();\n                this.transport.close();\n            }\n            bindListeners() {\n                this.onMessage = (m)=>{\n                    this.unbindListeners();\n                    var result;\n                    try {\n                        result = protocol.processHandshake(m);\n                    } catch (e) {\n                        this.finish(\"error\", {\n                            error: e\n                        });\n                        this.transport.close();\n                        return;\n                    }\n                    if (result.action === \"connected\") {\n                        this.finish(\"connected\", {\n                            connection: new connection_Connection(result.id, this.transport),\n                            activityTimeout: result.activityTimeout\n                        });\n                    } else {\n                        this.finish(result.action, {\n                            error: result.error\n                        });\n                        this.transport.close();\n                    }\n                };\n                this.onClosed = (closeEvent)=>{\n                    this.unbindListeners();\n                    var action = protocol.getCloseAction(closeEvent) || \"backoff\";\n                    var error = protocol.getCloseError(closeEvent);\n                    this.finish(action, {\n                        error: error\n                    });\n                };\n                this.transport.bind(\"message\", this.onMessage);\n                this.transport.bind(\"closed\", this.onClosed);\n            }\n            unbindListeners() {\n                this.transport.unbind(\"message\", this.onMessage);\n                this.transport.unbind(\"closed\", this.onClosed);\n            }\n            finish(action, params) {\n                this.callback(extend({\n                    transport: this.transport,\n                    action: action\n                }, params));\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/timeline/timeline_sender.ts\n        class timeline_sender_TimelineSender {\n            constructor(timeline, options){\n                this.timeline = timeline;\n                this.options = options || {};\n            }\n            send(useTLS, callback) {\n                if (this.timeline.isEmpty()) {\n                    return;\n                }\n                this.timeline.send(node_runtime.TimelineTransport.getAgent(this, useTLS), callback);\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/errors.ts\n        class BadEventName extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class BadChannelName extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class RequestTimedOut extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class TransportPriorityTooLow extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class TransportClosed extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class UnsupportedFeature extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class UnsupportedTransport extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class UnsupportedStrategy extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class HTTPAuthError extends Error {\n            constructor(status, msg){\n                super(msg);\n                this.status = status;\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/utils/url_store.ts\n        const urlStore = {\n            baseUrl: \"https://pusher.com\",\n            urls: {\n                authenticationEndpoint: {\n                    path: \"/docs/channels/server_api/authenticating_users\"\n                },\n                authorizationEndpoint: {\n                    path: \"/docs/channels/server_api/authorizing-users/\"\n                },\n                javascriptQuickStart: {\n                    path: \"/docs/javascript_quick_start\"\n                },\n                triggeringClientEvents: {\n                    path: \"/docs/client_api_guide/client_events#trigger-events\"\n                },\n                encryptedChannelSupport: {\n                    fullUrl: \"https://github.com/pusher/pusher-js/tree/cc491015371a4bde5743d1c87a0fbac0feb53195#encrypted-channel-support\"\n                }\n            }\n        };\n        const buildLogSuffix = function(key) {\n            const urlPrefix = \"See:\";\n            const urlObj = urlStore.urls[key];\n            if (!urlObj) return \"\";\n            let url;\n            if (urlObj.fullUrl) {\n                url = urlObj.fullUrl;\n            } else if (urlObj.path) {\n                url = urlStore.baseUrl + urlObj.path;\n            }\n            if (!url) return \"\";\n            return `${urlPrefix} ${url}`;\n        };\n        /* harmony default export */ var url_store = {\n            buildLogSuffix\n        };\n        // CONCATENATED MODULE: ./src/core/channels/channel.ts\n        class channel_Channel extends dispatcher_Dispatcher {\n            constructor(name, pusher){\n                super(function(event, data) {\n                    logger.debug(\"No callbacks on \" + name + \" for \" + event);\n                });\n                this.name = name;\n                this.pusher = pusher;\n                this.subscribed = false;\n                this.subscriptionPending = false;\n                this.subscriptionCancelled = false;\n            }\n            authorize(socketId, callback) {\n                return callback(null, {\n                    auth: \"\"\n                });\n            }\n            trigger(event, data) {\n                if (event.indexOf(\"client-\") !== 0) {\n                    throw new BadEventName(\"Event '\" + event + \"' does not start with 'client-'\");\n                }\n                if (!this.subscribed) {\n                    var suffix = url_store.buildLogSuffix(\"triggeringClientEvents\");\n                    logger.warn(`Client event triggered before channel 'subscription_succeeded' event . ${suffix}`);\n                }\n                return this.pusher.send_event(event, data, this.name);\n            }\n            disconnect() {\n                this.subscribed = false;\n                this.subscriptionPending = false;\n            }\n            handleEvent(event) {\n                var eventName = event.event;\n                var data = event.data;\n                if (eventName === \"pusher_internal:subscription_succeeded\") {\n                    this.handleSubscriptionSucceededEvent(event);\n                } else if (eventName === \"pusher_internal:subscription_count\") {\n                    this.handleSubscriptionCountEvent(event);\n                } else if (eventName.indexOf(\"pusher_internal:\") !== 0) {\n                    var metadata = {};\n                    this.emit(eventName, data, metadata);\n                }\n            }\n            handleSubscriptionSucceededEvent(event) {\n                this.subscriptionPending = false;\n                this.subscribed = true;\n                if (this.subscriptionCancelled) {\n                    this.pusher.unsubscribe(this.name);\n                } else {\n                    this.emit(\"pusher:subscription_succeeded\", event.data);\n                }\n            }\n            handleSubscriptionCountEvent(event) {\n                if (event.data.subscription_count) {\n                    this.subscriptionCount = event.data.subscription_count;\n                }\n                this.emit(\"pusher:subscription_count\", event.data);\n            }\n            subscribe() {\n                if (this.subscribed) {\n                    return;\n                }\n                this.subscriptionPending = true;\n                this.subscriptionCancelled = false;\n                this.authorize(this.pusher.connection.socket_id, (error, data)=>{\n                    if (error) {\n                        this.subscriptionPending = false;\n                        logger.error(error.toString());\n                        this.emit(\"pusher:subscription_error\", Object.assign({}, {\n                            type: \"AuthError\",\n                            error: error.message\n                        }, error instanceof HTTPAuthError ? {\n                            status: error.status\n                        } : {}));\n                    } else {\n                        this.pusher.send_event(\"pusher:subscribe\", {\n                            auth: data.auth,\n                            channel_data: data.channel_data,\n                            channel: this.name\n                        });\n                    }\n                });\n            }\n            unsubscribe() {\n                this.subscribed = false;\n                this.pusher.send_event(\"pusher:unsubscribe\", {\n                    channel: this.name\n                });\n            }\n            cancelSubscription() {\n                this.subscriptionCancelled = true;\n            }\n            reinstateSubscription() {\n                this.subscriptionCancelled = false;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/channels/private_channel.ts\n        class private_channel_PrivateChannel extends channel_Channel {\n            authorize(socketId, callback) {\n                return this.pusher.config.channelAuthorizer({\n                    channelName: this.name,\n                    socketId: socketId\n                }, callback);\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/channels/members.ts\n        class members_Members {\n            constructor(){\n                this.reset();\n            }\n            get(id) {\n                if (Object.prototype.hasOwnProperty.call(this.members, id)) {\n                    return {\n                        id: id,\n                        info: this.members[id]\n                    };\n                } else {\n                    return null;\n                }\n            }\n            each(callback) {\n                objectApply(this.members, (member, id)=>{\n                    callback(this.get(id));\n                });\n            }\n            setMyID(id) {\n                this.myID = id;\n            }\n            onSubscription(subscriptionData) {\n                this.members = subscriptionData.presence.hash;\n                this.count = subscriptionData.presence.count;\n                this.me = this.get(this.myID);\n            }\n            addMember(memberData) {\n                if (this.get(memberData.user_id) === null) {\n                    this.count++;\n                }\n                this.members[memberData.user_id] = memberData.user_info;\n                return this.get(memberData.user_id);\n            }\n            removeMember(memberData) {\n                var member = this.get(memberData.user_id);\n                if (member) {\n                    delete this.members[memberData.user_id];\n                    this.count--;\n                }\n                return member;\n            }\n            reset() {\n                this.members = {};\n                this.count = 0;\n                this.myID = null;\n                this.me = null;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/channels/presence_channel.ts\n        var __awaiter =  false || function(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n                return value instanceof P ? value : new P(function(resolve) {\n                    resolve(value);\n                });\n            }\n            return new (P || (P = Promise))(function(resolve, reject) {\n                function fulfilled(value) {\n                    try {\n                        step(generator.next(value));\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                function rejected(value) {\n                    try {\n                        step(generator[\"throw\"](value));\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                function step(result) {\n                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n                }\n                step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n        };\n        class presence_channel_PresenceChannel extends private_channel_PrivateChannel {\n            constructor(name, pusher){\n                super(name, pusher);\n                this.members = new members_Members();\n            }\n            authorize(socketId, callback) {\n                super.authorize(socketId, (error, authData)=>__awaiter(this, void 0, void 0, function*() {\n                        if (!error) {\n                            authData = authData;\n                            if (authData.channel_data != null) {\n                                var channelData = JSON.parse(authData.channel_data);\n                                this.members.setMyID(channelData.user_id);\n                            } else {\n                                yield this.pusher.user.signinDonePromise;\n                                if (this.pusher.user.user_data != null) {\n                                    this.members.setMyID(this.pusher.user.user_data.id);\n                                } else {\n                                    let suffix = url_store.buildLogSuffix(\"authorizationEndpoint\");\n                                    logger.error(`Invalid auth response for channel '${this.name}', ` + `expected 'channel_data' field. ${suffix}, ` + `or the user should be signed in.`);\n                                    callback(\"Invalid auth response\");\n                                    return;\n                                }\n                            }\n                        }\n                        callback(error, authData);\n                    }));\n            }\n            handleEvent(event) {\n                var eventName = event.event;\n                if (eventName.indexOf(\"pusher_internal:\") === 0) {\n                    this.handleInternalEvent(event);\n                } else {\n                    var data = event.data;\n                    var metadata = {};\n                    if (event.user_id) {\n                        metadata.user_id = event.user_id;\n                    }\n                    this.emit(eventName, data, metadata);\n                }\n            }\n            handleInternalEvent(event) {\n                var eventName = event.event;\n                var data = event.data;\n                switch(eventName){\n                    case \"pusher_internal:subscription_succeeded\":\n                        this.handleSubscriptionSucceededEvent(event);\n                        break;\n                    case \"pusher_internal:subscription_count\":\n                        this.handleSubscriptionCountEvent(event);\n                        break;\n                    case \"pusher_internal:member_added\":\n                        var addedMember = this.members.addMember(data);\n                        this.emit(\"pusher:member_added\", addedMember);\n                        break;\n                    case \"pusher_internal:member_removed\":\n                        var removedMember = this.members.removeMember(data);\n                        if (removedMember) {\n                            this.emit(\"pusher:member_removed\", removedMember);\n                        }\n                        break;\n                }\n            }\n            handleSubscriptionSucceededEvent(event) {\n                this.subscriptionPending = false;\n                this.subscribed = true;\n                if (this.subscriptionCancelled) {\n                    this.pusher.unsubscribe(this.name);\n                } else {\n                    this.members.onSubscription(event.data);\n                    this.emit(\"pusher:subscription_succeeded\", this.members);\n                }\n            }\n            disconnect() {\n                this.members.reset();\n                super.disconnect();\n            }\n        }\n        // EXTERNAL MODULE: ./node_modules/@stablelib/utf8/lib/utf8.js\n        var utf8 = __nested_webpack_require_266496__(17);\n        // EXTERNAL MODULE: ./node_modules/@stablelib/base64/lib/base64.js\n        var base64 = __nested_webpack_require_266496__(8);\n        // CONCATENATED MODULE: ./src/core/channels/encrypted_channel.ts\n        class encrypted_channel_EncryptedChannel extends private_channel_PrivateChannel {\n            constructor(name, pusher, nacl){\n                super(name, pusher);\n                this.key = null;\n                this.nacl = nacl;\n            }\n            authorize(socketId, callback) {\n                super.authorize(socketId, (error, authData)=>{\n                    if (error) {\n                        callback(error, authData);\n                        return;\n                    }\n                    let sharedSecret = authData[\"shared_secret\"];\n                    if (!sharedSecret) {\n                        callback(new Error(`No shared_secret key in auth payload for encrypted channel: ${this.name}`), null);\n                        return;\n                    }\n                    this.key = Object(base64[\"decode\"])(sharedSecret);\n                    delete authData[\"shared_secret\"];\n                    callback(null, authData);\n                });\n            }\n            trigger(event, data) {\n                throw new UnsupportedFeature(\"Client events are not currently supported for encrypted channels\");\n            }\n            handleEvent(event) {\n                var eventName = event.event;\n                var data = event.data;\n                if (eventName.indexOf(\"pusher_internal:\") === 0 || eventName.indexOf(\"pusher:\") === 0) {\n                    super.handleEvent(event);\n                    return;\n                }\n                this.handleEncryptedEvent(eventName, data);\n            }\n            handleEncryptedEvent(event, data) {\n                if (!this.key) {\n                    logger.debug(\"Received encrypted event before key has been retrieved from the authEndpoint\");\n                    return;\n                }\n                if (!data.ciphertext || !data.nonce) {\n                    logger.error(\"Unexpected format for encrypted event, expected object with `ciphertext` and `nonce` fields, got: \" + data);\n                    return;\n                }\n                let cipherText = Object(base64[\"decode\"])(data.ciphertext);\n                if (cipherText.length < this.nacl.secretbox.overheadLength) {\n                    logger.error(`Expected encrypted event ciphertext length to be ${this.nacl.secretbox.overheadLength}, got: ${cipherText.length}`);\n                    return;\n                }\n                let nonce = Object(base64[\"decode\"])(data.nonce);\n                if (nonce.length < this.nacl.secretbox.nonceLength) {\n                    logger.error(`Expected encrypted event nonce length to be ${this.nacl.secretbox.nonceLength}, got: ${nonce.length}`);\n                    return;\n                }\n                let bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);\n                if (bytes === null) {\n                    logger.debug(\"Failed to decrypt an event, probably because it was encrypted with a different key. Fetching a new key from the authEndpoint...\");\n                    this.authorize(this.pusher.connection.socket_id, (error, authData)=>{\n                        if (error) {\n                            logger.error(`Failed to make a request to the authEndpoint: ${authData}. Unable to fetch new key, so dropping encrypted event`);\n                            return;\n                        }\n                        bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);\n                        if (bytes === null) {\n                            logger.error(`Failed to decrypt event with new key. Dropping encrypted event`);\n                            return;\n                        }\n                        this.emit(event, this.getDataToEmit(bytes));\n                        return;\n                    });\n                    return;\n                }\n                this.emit(event, this.getDataToEmit(bytes));\n            }\n            getDataToEmit(bytes) {\n                let raw = Object(utf8[\"decode\"])(bytes);\n                try {\n                    return JSON.parse(raw);\n                } catch (_a) {\n                    return raw;\n                }\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/connection/connection_manager.ts\n        class connection_manager_ConnectionManager extends dispatcher_Dispatcher {\n            constructor(key, options){\n                super();\n                this.state = \"initialized\";\n                this.connection = null;\n                this.key = key;\n                this.options = options;\n                this.timeline = this.options.timeline;\n                this.usingTLS = this.options.useTLS;\n                this.errorCallbacks = this.buildErrorCallbacks();\n                this.connectionCallbacks = this.buildConnectionCallbacks(this.errorCallbacks);\n                this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);\n                var Network = node_runtime.getNetwork();\n                Network.bind(\"online\", ()=>{\n                    this.timeline.info({\n                        netinfo: \"online\"\n                    });\n                    if (this.state === \"connecting\" || this.state === \"unavailable\") {\n                        this.retryIn(0);\n                    }\n                });\n                Network.bind(\"offline\", ()=>{\n                    this.timeline.info({\n                        netinfo: \"offline\"\n                    });\n                    if (this.connection) {\n                        this.sendActivityCheck();\n                    }\n                });\n                this.updateStrategy();\n            }\n            switchCluster(key) {\n                this.key = key;\n                this.updateStrategy();\n                this.retryIn(0);\n            }\n            connect() {\n                if (this.connection || this.runner) {\n                    return;\n                }\n                if (!this.strategy.isSupported()) {\n                    this.updateState(\"failed\");\n                    return;\n                }\n                this.updateState(\"connecting\");\n                this.startConnecting();\n                this.setUnavailableTimer();\n            }\n            send(data) {\n                if (this.connection) {\n                    return this.connection.send(data);\n                } else {\n                    return false;\n                }\n            }\n            send_event(name, data, channel) {\n                if (this.connection) {\n                    return this.connection.send_event(name, data, channel);\n                } else {\n                    return false;\n                }\n            }\n            disconnect() {\n                this.disconnectInternally();\n                this.updateState(\"disconnected\");\n            }\n            isUsingTLS() {\n                return this.usingTLS;\n            }\n            startConnecting() {\n                var callback = (error, handshake)=>{\n                    if (error) {\n                        this.runner = this.strategy.connect(0, callback);\n                    } else {\n                        if (handshake.action === \"error\") {\n                            this.emit(\"error\", {\n                                type: \"HandshakeError\",\n                                error: handshake.error\n                            });\n                            this.timeline.error({\n                                handshakeError: handshake.error\n                            });\n                        } else {\n                            this.abortConnecting();\n                            this.handshakeCallbacks[handshake.action](handshake);\n                        }\n                    }\n                };\n                this.runner = this.strategy.connect(0, callback);\n            }\n            abortConnecting() {\n                if (this.runner) {\n                    this.runner.abort();\n                    this.runner = null;\n                }\n            }\n            disconnectInternally() {\n                this.abortConnecting();\n                this.clearRetryTimer();\n                this.clearUnavailableTimer();\n                if (this.connection) {\n                    var connection = this.abandonConnection();\n                    connection.close();\n                }\n            }\n            updateStrategy() {\n                this.strategy = this.options.getStrategy({\n                    key: this.key,\n                    timeline: this.timeline,\n                    useTLS: this.usingTLS\n                });\n            }\n            retryIn(delay) {\n                this.timeline.info({\n                    action: \"retry\",\n                    delay: delay\n                });\n                if (delay > 0) {\n                    this.emit(\"connecting_in\", Math.round(delay / 1000));\n                }\n                this.retryTimer = new timers_OneOffTimer(delay || 0, ()=>{\n                    this.disconnectInternally();\n                    this.connect();\n                });\n            }\n            clearRetryTimer() {\n                if (this.retryTimer) {\n                    this.retryTimer.ensureAborted();\n                    this.retryTimer = null;\n                }\n            }\n            setUnavailableTimer() {\n                this.unavailableTimer = new timers_OneOffTimer(this.options.unavailableTimeout, ()=>{\n                    this.updateState(\"unavailable\");\n                });\n            }\n            clearUnavailableTimer() {\n                if (this.unavailableTimer) {\n                    this.unavailableTimer.ensureAborted();\n                }\n            }\n            sendActivityCheck() {\n                this.stopActivityCheck();\n                this.connection.ping();\n                this.activityTimer = new timers_OneOffTimer(this.options.pongTimeout, ()=>{\n                    this.timeline.error({\n                        pong_timed_out: this.options.pongTimeout\n                    });\n                    this.retryIn(0);\n                });\n            }\n            resetActivityCheck() {\n                this.stopActivityCheck();\n                if (this.connection && !this.connection.handlesActivityChecks()) {\n                    this.activityTimer = new timers_OneOffTimer(this.activityTimeout, ()=>{\n                        this.sendActivityCheck();\n                    });\n                }\n            }\n            stopActivityCheck() {\n                if (this.activityTimer) {\n                    this.activityTimer.ensureAborted();\n                }\n            }\n            buildConnectionCallbacks(errorCallbacks) {\n                return extend({}, errorCallbacks, {\n                    message: (message)=>{\n                        this.resetActivityCheck();\n                        this.emit(\"message\", message);\n                    },\n                    ping: ()=>{\n                        this.send_event(\"pusher:pong\", {});\n                    },\n                    activity: ()=>{\n                        this.resetActivityCheck();\n                    },\n                    error: (error)=>{\n                        this.emit(\"error\", error);\n                    },\n                    closed: ()=>{\n                        this.abandonConnection();\n                        if (this.shouldRetry()) {\n                            this.retryIn(1000);\n                        }\n                    }\n                });\n            }\n            buildHandshakeCallbacks(errorCallbacks) {\n                return extend({}, errorCallbacks, {\n                    connected: (handshake)=>{\n                        this.activityTimeout = Math.min(this.options.activityTimeout, handshake.activityTimeout, handshake.connection.activityTimeout || Infinity);\n                        this.clearUnavailableTimer();\n                        this.setConnection(handshake.connection);\n                        this.socket_id = this.connection.id;\n                        this.updateState(\"connected\", {\n                            socket_id: this.socket_id\n                        });\n                    }\n                });\n            }\n            buildErrorCallbacks() {\n                let withErrorEmitted = (callback)=>{\n                    return (result)=>{\n                        if (result.error) {\n                            this.emit(\"error\", {\n                                type: \"WebSocketError\",\n                                error: result.error\n                            });\n                        }\n                        callback(result);\n                    };\n                };\n                return {\n                    tls_only: withErrorEmitted(()=>{\n                        this.usingTLS = true;\n                        this.updateStrategy();\n                        this.retryIn(0);\n                    }),\n                    refused: withErrorEmitted(()=>{\n                        this.disconnect();\n                    }),\n                    backoff: withErrorEmitted(()=>{\n                        this.retryIn(1000);\n                    }),\n                    retry: withErrorEmitted(()=>{\n                        this.retryIn(0);\n                    })\n                };\n            }\n            setConnection(connection) {\n                this.connection = connection;\n                for(var event in this.connectionCallbacks){\n                    this.connection.bind(event, this.connectionCallbacks[event]);\n                }\n                this.resetActivityCheck();\n            }\n            abandonConnection() {\n                if (!this.connection) {\n                    return;\n                }\n                this.stopActivityCheck();\n                for(var event in this.connectionCallbacks){\n                    this.connection.unbind(event, this.connectionCallbacks[event]);\n                }\n                var connection = this.connection;\n                this.connection = null;\n                return connection;\n            }\n            updateState(newState, data) {\n                var previousState = this.state;\n                this.state = newState;\n                if (previousState !== newState) {\n                    var newStateDescription = newState;\n                    if (newStateDescription === \"connected\") {\n                        newStateDescription += \" with new socket ID \" + data.socket_id;\n                    }\n                    logger.debug(\"State changed\", previousState + \" -> \" + newStateDescription);\n                    this.timeline.info({\n                        state: newState,\n                        params: data\n                    });\n                    this.emit(\"state_change\", {\n                        previous: previousState,\n                        current: newState\n                    });\n                    this.emit(newState, data);\n                }\n            }\n            shouldRetry() {\n                return this.state === \"connecting\" || this.state === \"connected\";\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/channels/channels.ts\n        class channels_Channels {\n            constructor(){\n                this.channels = {};\n            }\n            add(name, pusher) {\n                if (!this.channels[name]) {\n                    this.channels[name] = createChannel(name, pusher);\n                }\n                return this.channels[name];\n            }\n            all() {\n                return values(this.channels);\n            }\n            find(name) {\n                return this.channels[name];\n            }\n            remove(name) {\n                var channel = this.channels[name];\n                delete this.channels[name];\n                return channel;\n            }\n            disconnect() {\n                objectApply(this.channels, function(channel) {\n                    channel.disconnect();\n                });\n            }\n        }\n        function createChannel(name, pusher) {\n            if (name.indexOf(\"private-encrypted-\") === 0) {\n                if (pusher.config.nacl) {\n                    return factory.createEncryptedChannel(name, pusher, pusher.config.nacl);\n                }\n                let errMsg = \"Tried to subscribe to a private-encrypted- channel but no nacl implementation available\";\n                let suffix = url_store.buildLogSuffix(\"encryptedChannelSupport\");\n                throw new UnsupportedFeature(`${errMsg}. ${suffix}`);\n            } else if (name.indexOf(\"private-\") === 0) {\n                return factory.createPrivateChannel(name, pusher);\n            } else if (name.indexOf(\"presence-\") === 0) {\n                return factory.createPresenceChannel(name, pusher);\n            } else if (name.indexOf(\"#\") === 0) {\n                throw new BadChannelName('Cannot create a channel with name \"' + name + '\".');\n            } else {\n                return factory.createChannel(name, pusher);\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/utils/factory.ts\n        var Factory = {\n            createChannels () {\n                return new channels_Channels();\n            },\n            createConnectionManager (key, options) {\n                return new connection_manager_ConnectionManager(key, options);\n            },\n            createChannel (name, pusher) {\n                return new channel_Channel(name, pusher);\n            },\n            createPrivateChannel (name, pusher) {\n                return new private_channel_PrivateChannel(name, pusher);\n            },\n            createPresenceChannel (name, pusher) {\n                return new presence_channel_PresenceChannel(name, pusher);\n            },\n            createEncryptedChannel (name, pusher, nacl) {\n                return new encrypted_channel_EncryptedChannel(name, pusher, nacl);\n            },\n            createTimelineSender (timeline, options) {\n                return new timeline_sender_TimelineSender(timeline, options);\n            },\n            createHandshake (transport, callback) {\n                return new handshake_Handshake(transport, callback);\n            },\n            createAssistantToTheTransportManager (manager, transport, options) {\n                return new assistant_to_the_transport_manager_AssistantToTheTransportManager(manager, transport, options);\n            }\n        };\n        /* harmony default export */ var factory = Factory;\n        // CONCATENATED MODULE: ./src/core/transports/transport_manager.ts\n        class transport_manager_TransportManager {\n            constructor(options){\n                this.options = options || {};\n                this.livesLeft = this.options.lives || Infinity;\n            }\n            getAssistant(transport) {\n                return factory.createAssistantToTheTransportManager(this, transport, {\n                    minPingDelay: this.options.minPingDelay,\n                    maxPingDelay: this.options.maxPingDelay\n                });\n            }\n            isAlive() {\n                return this.livesLeft > 0;\n            }\n            reportDeath() {\n                this.livesLeft -= 1;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/sequential_strategy.ts\n        class sequential_strategy_SequentialStrategy {\n            constructor(strategies, options){\n                this.strategies = strategies;\n                this.loop = Boolean(options.loop);\n                this.failFast = Boolean(options.failFast);\n                this.timeout = options.timeout;\n                this.timeoutLimit = options.timeoutLimit;\n            }\n            isSupported() {\n                return any(this.strategies, util.method(\"isSupported\"));\n            }\n            connect(minPriority, callback) {\n                var strategies = this.strategies;\n                var current = 0;\n                var timeout = this.timeout;\n                var runner = null;\n                var tryNextStrategy = (error, handshake)=>{\n                    if (handshake) {\n                        callback(null, handshake);\n                    } else {\n                        current = current + 1;\n                        if (this.loop) {\n                            current = current % strategies.length;\n                        }\n                        if (current < strategies.length) {\n                            if (timeout) {\n                                timeout = timeout * 2;\n                                if (this.timeoutLimit) {\n                                    timeout = Math.min(timeout, this.timeoutLimit);\n                                }\n                            }\n                            runner = this.tryStrategy(strategies[current], minPriority, {\n                                timeout,\n                                failFast: this.failFast\n                            }, tryNextStrategy);\n                        } else {\n                            callback(true);\n                        }\n                    }\n                };\n                runner = this.tryStrategy(strategies[current], minPriority, {\n                    timeout: timeout,\n                    failFast: this.failFast\n                }, tryNextStrategy);\n                return {\n                    abort: function() {\n                        runner.abort();\n                    },\n                    forceMinPriority: function(p) {\n                        minPriority = p;\n                        if (runner) {\n                            runner.forceMinPriority(p);\n                        }\n                    }\n                };\n            }\n            tryStrategy(strategy, minPriority, options, callback) {\n                var timer = null;\n                var runner = null;\n                if (options.timeout > 0) {\n                    timer = new timers_OneOffTimer(options.timeout, function() {\n                        runner.abort();\n                        callback(true);\n                    });\n                }\n                runner = strategy.connect(minPriority, function(error, handshake) {\n                    if (error && timer && timer.isRunning() && !options.failFast) {\n                        return;\n                    }\n                    if (timer) {\n                        timer.ensureAborted();\n                    }\n                    callback(error, handshake);\n                });\n                return {\n                    abort: function() {\n                        if (timer) {\n                            timer.ensureAborted();\n                        }\n                        runner.abort();\n                    },\n                    forceMinPriority: function(p) {\n                        runner.forceMinPriority(p);\n                    }\n                };\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/best_connected_ever_strategy.ts\n        class best_connected_ever_strategy_BestConnectedEverStrategy {\n            constructor(strategies){\n                this.strategies = strategies;\n            }\n            isSupported() {\n                return any(this.strategies, util.method(\"isSupported\"));\n            }\n            connect(minPriority, callback) {\n                return connect(this.strategies, minPriority, function(i, runners) {\n                    return function(error, handshake) {\n                        runners[i].error = error;\n                        if (error) {\n                            if (allRunnersFailed(runners)) {\n                                callback(true);\n                            }\n                            return;\n                        }\n                        apply(runners, function(runner) {\n                            runner.forceMinPriority(handshake.transport.priority);\n                        });\n                        callback(null, handshake);\n                    };\n                });\n            }\n        }\n        function connect(strategies, minPriority, callbackBuilder) {\n            var runners = map(strategies, function(strategy, i, _, rs) {\n                return strategy.connect(minPriority, callbackBuilder(i, rs));\n            });\n            return {\n                abort: function() {\n                    apply(runners, abortRunner);\n                },\n                forceMinPriority: function(p) {\n                    apply(runners, function(runner) {\n                        runner.forceMinPriority(p);\n                    });\n                }\n            };\n        }\n        function allRunnersFailed(runners) {\n            return collections_all(runners, function(runner) {\n                return Boolean(runner.error);\n            });\n        }\n        function abortRunner(runner) {\n            if (!runner.error && !runner.aborted) {\n                runner.abort();\n                runner.aborted = true;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/websocket_prioritized_cached_strategy.ts\n        class websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy {\n            constructor(strategy, transports, options){\n                this.strategy = strategy;\n                this.transports = transports;\n                this.ttl = options.ttl || 1800 * 1000;\n                this.usingTLS = options.useTLS;\n                this.timeline = options.timeline;\n            }\n            isSupported() {\n                return this.strategy.isSupported();\n            }\n            connect(minPriority, callback) {\n                var usingTLS = this.usingTLS;\n                var info = fetchTransportCache(usingTLS);\n                var cacheSkipCount = info && info.cacheSkipCount ? info.cacheSkipCount : 0;\n                var strategies = [\n                    this.strategy\n                ];\n                if (info && info.timestamp + this.ttl >= util.now()) {\n                    var transport = this.transports[info.transport];\n                    if (transport) {\n                        if ([\n                            \"ws\",\n                            \"wss\"\n                        ].includes(info.transport) || cacheSkipCount > 3) {\n                            this.timeline.info({\n                                cached: true,\n                                transport: info.transport,\n                                latency: info.latency\n                            });\n                            strategies.push(new sequential_strategy_SequentialStrategy([\n                                transport\n                            ], {\n                                timeout: info.latency * 2 + 1000,\n                                failFast: true\n                            }));\n                        } else {\n                            cacheSkipCount++;\n                        }\n                    }\n                }\n                var startTimestamp = util.now();\n                var runner = strategies.pop().connect(minPriority, function cb(error, handshake) {\n                    if (error) {\n                        flushTransportCache(usingTLS);\n                        if (strategies.length > 0) {\n                            startTimestamp = util.now();\n                            runner = strategies.pop().connect(minPriority, cb);\n                        } else {\n                            callback(error);\n                        }\n                    } else {\n                        storeTransportCache(usingTLS, handshake.transport.name, util.now() - startTimestamp, cacheSkipCount);\n                        callback(null, handshake);\n                    }\n                });\n                return {\n                    abort: function() {\n                        runner.abort();\n                    },\n                    forceMinPriority: function(p) {\n                        minPriority = p;\n                        if (runner) {\n                            runner.forceMinPriority(p);\n                        }\n                    }\n                };\n            }\n        }\n        function getTransportCacheKey(usingTLS) {\n            return \"pusherTransport\" + (usingTLS ? \"TLS\" : \"NonTLS\");\n        }\n        function fetchTransportCache(usingTLS) {\n            var storage = node_runtime.getLocalStorage();\n            if (storage) {\n                try {\n                    var serializedCache = storage[getTransportCacheKey(usingTLS)];\n                    if (serializedCache) {\n                        return JSON.parse(serializedCache);\n                    }\n                } catch (e) {\n                    flushTransportCache(usingTLS);\n                }\n            }\n            return null;\n        }\n        function storeTransportCache(usingTLS, transport, latency, cacheSkipCount) {\n            var storage = node_runtime.getLocalStorage();\n            if (storage) {\n                try {\n                    storage[getTransportCacheKey(usingTLS)] = safeJSONStringify({\n                        timestamp: util.now(),\n                        transport: transport,\n                        latency: latency,\n                        cacheSkipCount: cacheSkipCount\n                    });\n                } catch (e) {}\n            }\n        }\n        function flushTransportCache(usingTLS) {\n            var storage = node_runtime.getLocalStorage();\n            if (storage) {\n                try {\n                    delete storage[getTransportCacheKey(usingTLS)];\n                } catch (e) {}\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/delayed_strategy.ts\n        class delayed_strategy_DelayedStrategy {\n            constructor(strategy, { delay: number }){\n                this.strategy = strategy;\n                this.options = {\n                    delay: number\n                };\n            }\n            isSupported() {\n                return this.strategy.isSupported();\n            }\n            connect(minPriority, callback) {\n                var strategy = this.strategy;\n                var runner;\n                var timer = new timers_OneOffTimer(this.options.delay, function() {\n                    runner = strategy.connect(minPriority, callback);\n                });\n                return {\n                    abort: function() {\n                        timer.ensureAborted();\n                        if (runner) {\n                            runner.abort();\n                        }\n                    },\n                    forceMinPriority: function(p) {\n                        minPriority = p;\n                        if (runner) {\n                            runner.forceMinPriority(p);\n                        }\n                    }\n                };\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/if_strategy.ts\n        class IfStrategy {\n            constructor(test, trueBranch, falseBranch){\n                this.test = test;\n                this.trueBranch = trueBranch;\n                this.falseBranch = falseBranch;\n            }\n            isSupported() {\n                var branch = this.test() ? this.trueBranch : this.falseBranch;\n                return branch.isSupported();\n            }\n            connect(minPriority, callback) {\n                var branch = this.test() ? this.trueBranch : this.falseBranch;\n                return branch.connect(minPriority, callback);\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/first_connected_strategy.ts\n        class FirstConnectedStrategy {\n            constructor(strategy){\n                this.strategy = strategy;\n            }\n            isSupported() {\n                return this.strategy.isSupported();\n            }\n            connect(minPriority, callback) {\n                var runner = this.strategy.connect(minPriority, function(error, handshake) {\n                    if (handshake) {\n                        runner.abort();\n                    }\n                    callback(error, handshake);\n                });\n                return runner;\n            }\n        }\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/default_strategy.ts\n        function testSupportsStrategy(strategy) {\n            return function() {\n                return strategy.isSupported();\n            };\n        }\n        var getDefaultStrategy = function(config, baseOptions, defineTransport) {\n            var definedTransports = {};\n            function defineTransportStrategy(name, type, priority, options, manager) {\n                var transport = defineTransport(config, name, type, priority, options, manager);\n                definedTransports[name] = transport;\n                return transport;\n            }\n            var ws_options = Object.assign({}, baseOptions, {\n                hostNonTLS: config.wsHost + \":\" + config.wsPort,\n                hostTLS: config.wsHost + \":\" + config.wssPort,\n                httpPath: config.wsPath\n            });\n            var wss_options = extend({}, ws_options, {\n                useTLS: true\n            });\n            var http_options = Object.assign({}, baseOptions, {\n                hostNonTLS: config.httpHost + \":\" + config.httpPort,\n                hostTLS: config.httpHost + \":\" + config.httpsPort,\n                httpPath: config.httpPath\n            });\n            var timeouts = {\n                loop: true,\n                timeout: 15000,\n                timeoutLimit: 60000\n            };\n            var ws_manager = new transport_manager_TransportManager({\n                minPingDelay: 10000,\n                maxPingDelay: config.activityTimeout\n            });\n            var streaming_manager = new transport_manager_TransportManager({\n                lives: 2,\n                minPingDelay: 10000,\n                maxPingDelay: config.activityTimeout\n            });\n            var ws_transport = defineTransportStrategy(\"ws\", \"ws\", 3, ws_options, ws_manager);\n            var wss_transport = defineTransportStrategy(\"wss\", \"ws\", 3, wss_options, ws_manager);\n            var xhr_streaming_transport = defineTransportStrategy(\"xhr_streaming\", \"xhr_streaming\", 1, http_options, streaming_manager);\n            var xhr_polling_transport = defineTransportStrategy(\"xhr_polling\", \"xhr_polling\", 1, http_options);\n            var ws_loop = new sequential_strategy_SequentialStrategy([\n                ws_transport\n            ], timeouts);\n            var wss_loop = new sequential_strategy_SequentialStrategy([\n                wss_transport\n            ], timeouts);\n            var streaming_loop = new sequential_strategy_SequentialStrategy([\n                xhr_streaming_transport\n            ], timeouts);\n            var polling_loop = new sequential_strategy_SequentialStrategy([\n                xhr_polling_transport\n            ], timeouts);\n            var http_loop = new sequential_strategy_SequentialStrategy([\n                new IfStrategy(testSupportsStrategy(streaming_loop), new best_connected_ever_strategy_BestConnectedEverStrategy([\n                    streaming_loop,\n                    new delayed_strategy_DelayedStrategy(polling_loop, {\n                        delay: 4000\n                    })\n                ]), polling_loop)\n            ], timeouts);\n            var wsStrategy;\n            if (baseOptions.useTLS) {\n                wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([\n                    ws_loop,\n                    new delayed_strategy_DelayedStrategy(http_loop, {\n                        delay: 2000\n                    })\n                ]);\n            } else {\n                wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([\n                    ws_loop,\n                    new delayed_strategy_DelayedStrategy(wss_loop, {\n                        delay: 2000\n                    }),\n                    new delayed_strategy_DelayedStrategy(http_loop, {\n                        delay: 5000\n                    })\n                ]);\n            }\n            return new websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy(new FirstConnectedStrategy(new IfStrategy(testSupportsStrategy(ws_transport), wsStrategy, http_loop)), definedTransports, {\n                ttl: 1800000,\n                timeline: baseOptions.timeline,\n                useTLS: baseOptions.useTLS\n            });\n        };\n        /* harmony default export */ var default_strategy = getDefaultStrategy;\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/transports/transport_connection_initializer.ts\n        /* harmony default export */ var transport_connection_initializer = function() {\n            var self1 = this;\n            self1.timeline.info(self1.buildTimelineMessage({\n                transport: self1.name + (self1.options.useTLS ? \"s\" : \"\")\n            }));\n            if (self1.hooks.isInitialized()) {\n                self1.changeState(\"initialized\");\n            } else {\n                self1.onClose();\n            }\n        };\n        // CONCATENATED MODULE: ./src/core/http/http_request.ts\n        const MAX_BUFFER_LENGTH = 256 * 1024;\n        class http_request_HTTPRequest extends dispatcher_Dispatcher {\n            constructor(hooks, method, url){\n                super();\n                this.hooks = hooks;\n                this.method = method;\n                this.url = url;\n            }\n            start(payload) {\n                this.position = 0;\n                this.xhr = this.hooks.getRequest(this);\n                this.unloader = ()=>{\n                    this.close();\n                };\n                node_runtime.addUnloadListener(this.unloader);\n                this.xhr.open(this.method, this.url, true);\n                if (this.xhr.setRequestHeader) {\n                    this.xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n                }\n                this.xhr.send(payload);\n            }\n            close() {\n                if (this.unloader) {\n                    node_runtime.removeUnloadListener(this.unloader);\n                    this.unloader = null;\n                }\n                if (this.xhr) {\n                    this.hooks.abortRequest(this.xhr);\n                    this.xhr = null;\n                }\n            }\n            onChunk(status, data) {\n                while(true){\n                    var chunk = this.advanceBuffer(data);\n                    if (chunk) {\n                        this.emit(\"chunk\", {\n                            status: status,\n                            data: chunk\n                        });\n                    } else {\n                        break;\n                    }\n                }\n                if (this.isBufferTooLong(data)) {\n                    this.emit(\"buffer_too_long\");\n                }\n            }\n            advanceBuffer(buffer) {\n                var unreadData = buffer.slice(this.position);\n                var endOfLinePosition = unreadData.indexOf(\"\\n\");\n                if (endOfLinePosition !== -1) {\n                    this.position += endOfLinePosition + 1;\n                    return unreadData.slice(0, endOfLinePosition);\n                } else {\n                    return null;\n                }\n            }\n            isBufferTooLong(buffer) {\n                return this.position === buffer.length && buffer.length > MAX_BUFFER_LENGTH;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/http/state.ts\n        var State;\n        (function(State) {\n            State[State[\"CONNECTING\"] = 0] = \"CONNECTING\";\n            State[State[\"OPEN\"] = 1] = \"OPEN\";\n            State[State[\"CLOSED\"] = 3] = \"CLOSED\";\n        })(State || (State = {}));\n        /* harmony default export */ var state = State;\n        // CONCATENATED MODULE: ./src/core/http/http_socket.ts\n        var autoIncrement = 1;\n        class http_socket_HTTPSocket {\n            constructor(hooks, url){\n                this.hooks = hooks;\n                this.session = randomNumber(1000) + \"/\" + randomString(8);\n                this.location = getLocation(url);\n                this.readyState = state.CONNECTING;\n                this.openStream();\n            }\n            send(payload) {\n                return this.sendRaw(JSON.stringify([\n                    payload\n                ]));\n            }\n            ping() {\n                this.hooks.sendHeartbeat(this);\n            }\n            close(code, reason) {\n                this.onClose(code, reason, true);\n            }\n            sendRaw(payload) {\n                if (this.readyState === state.OPEN) {\n                    try {\n                        node_runtime.createSocketRequest(\"POST\", getUniqueURL(getSendURL(this.location, this.session))).start(payload);\n                        return true;\n                    } catch (e) {\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            }\n            reconnect() {\n                this.closeStream();\n                this.openStream();\n            }\n            onClose(code, reason, wasClean) {\n                this.closeStream();\n                this.readyState = state.CLOSED;\n                if (this.onclose) {\n                    this.onclose({\n                        code: code,\n                        reason: reason,\n                        wasClean: wasClean\n                    });\n                }\n            }\n            onChunk(chunk) {\n                if (chunk.status !== 200) {\n                    return;\n                }\n                if (this.readyState === state.OPEN) {\n                    this.onActivity();\n                }\n                var payload;\n                var type = chunk.data.slice(0, 1);\n                switch(type){\n                    case \"o\":\n                        payload = JSON.parse(chunk.data.slice(1) || \"{}\");\n                        this.onOpen(payload);\n                        break;\n                    case \"a\":\n                        payload = JSON.parse(chunk.data.slice(1) || \"[]\");\n                        for(var i = 0; i < payload.length; i++){\n                            this.onEvent(payload[i]);\n                        }\n                        break;\n                    case \"m\":\n                        payload = JSON.parse(chunk.data.slice(1) || \"null\");\n                        this.onEvent(payload);\n                        break;\n                    case \"h\":\n                        this.hooks.onHeartbeat(this);\n                        break;\n                    case \"c\":\n                        payload = JSON.parse(chunk.data.slice(1) || \"[]\");\n                        this.onClose(payload[0], payload[1], true);\n                        break;\n                }\n            }\n            onOpen(options) {\n                if (this.readyState === state.CONNECTING) {\n                    if (options && options.hostname) {\n                        this.location.base = replaceHost(this.location.base, options.hostname);\n                    }\n                    this.readyState = state.OPEN;\n                    if (this.onopen) {\n                        this.onopen();\n                    }\n                } else {\n                    this.onClose(1006, \"Server lost session\", true);\n                }\n            }\n            onEvent(event) {\n                if (this.readyState === state.OPEN && this.onmessage) {\n                    this.onmessage({\n                        data: event\n                    });\n                }\n            }\n            onActivity() {\n                if (this.onactivity) {\n                    this.onactivity();\n                }\n            }\n            onError(error) {\n                if (this.onerror) {\n                    this.onerror(error);\n                }\n            }\n            openStream() {\n                this.stream = node_runtime.createSocketRequest(\"POST\", getUniqueURL(this.hooks.getReceiveURL(this.location, this.session)));\n                this.stream.bind(\"chunk\", (chunk)=>{\n                    this.onChunk(chunk);\n                });\n                this.stream.bind(\"finished\", (status)=>{\n                    this.hooks.onFinished(this, status);\n                });\n                this.stream.bind(\"buffer_too_long\", ()=>{\n                    this.reconnect();\n                });\n                try {\n                    this.stream.start();\n                } catch (error) {\n                    util.defer(()=>{\n                        this.onError(error);\n                        this.onClose(1006, \"Could not start streaming\", false);\n                    });\n                }\n            }\n            closeStream() {\n                if (this.stream) {\n                    this.stream.unbind_all();\n                    this.stream.close();\n                    this.stream = null;\n                }\n            }\n        }\n        function getLocation(url) {\n            var parts = /([^\\?]*)\\/*(\\??.*)/.exec(url);\n            return {\n                base: parts[1],\n                queryString: parts[2]\n            };\n        }\n        function getSendURL(url, session) {\n            return url.base + \"/\" + session + \"/xhr_send\";\n        }\n        function getUniqueURL(url) {\n            var separator = url.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n            return url + separator + \"t=\" + +new Date() + \"&n=\" + autoIncrement++;\n        }\n        function replaceHost(url, hostname) {\n            var urlParts = /(https?:\\/\\/)([^\\/:]+)((\\/|:)?.*)/.exec(url);\n            return urlParts[1] + hostname + urlParts[3];\n        }\n        function randomNumber(max) {\n            return node_runtime.randomInt(max);\n        }\n        function randomString(length) {\n            var result = [];\n            for(var i = 0; i < length; i++){\n                result.push(randomNumber(32).toString(32));\n            }\n            return result.join(\"\");\n        }\n        /* harmony default export */ var http_socket = http_socket_HTTPSocket;\n        // CONCATENATED MODULE: ./src/core/http/http_streaming_socket.ts\n        var http_streaming_socket_hooks = {\n            getReceiveURL: function(url, session) {\n                return url.base + \"/\" + session + \"/xhr_streaming\" + url.queryString;\n            },\n            onHeartbeat: function(socket) {\n                socket.sendRaw(\"[]\");\n            },\n            sendHeartbeat: function(socket) {\n                socket.sendRaw(\"[]\");\n            },\n            onFinished: function(socket, status) {\n                socket.onClose(1006, \"Connection interrupted (\" + status + \")\", false);\n            }\n        };\n        /* harmony default export */ var http_streaming_socket = http_streaming_socket_hooks;\n        // CONCATENATED MODULE: ./src/core/http/http_polling_socket.ts\n        var http_polling_socket_hooks = {\n            getReceiveURL: function(url, session) {\n                return url.base + \"/\" + session + \"/xhr\" + url.queryString;\n            },\n            onHeartbeat: function() {},\n            sendHeartbeat: function(socket) {\n                socket.sendRaw(\"[]\");\n            },\n            onFinished: function(socket, status) {\n                if (status === 200) {\n                    socket.reconnect();\n                } else {\n                    socket.onClose(1006, \"Connection interrupted (\" + status + \")\", false);\n                }\n            }\n        };\n        /* harmony default export */ var http_polling_socket = http_polling_socket_hooks;\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http_xhr_request.ts\n        var http_xhr_request_hooks = {\n            getRequest: function(socket) {\n                var Constructor = node_runtime.getXHRAPI();\n                var xhr = new Constructor();\n                xhr.onreadystatechange = xhr.onprogress = function() {\n                    switch(xhr.readyState){\n                        case 3:\n                            if (xhr.responseText && xhr.responseText.length > 0) {\n                                socket.onChunk(xhr.status, xhr.responseText);\n                            }\n                            break;\n                        case 4:\n                            if (xhr.responseText && xhr.responseText.length > 0) {\n                                socket.onChunk(xhr.status, xhr.responseText);\n                            }\n                            socket.emit(\"finished\", xhr.status);\n                            socket.close();\n                            break;\n                    }\n                };\n                return xhr;\n            },\n            abortRequest: function(xhr) {\n                xhr.onreadystatechange = null;\n                xhr.abort();\n            }\n        };\n        /* harmony default export */ var http_xhr_request = http_xhr_request_hooks;\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http.ts\n        var HTTP = {\n            createStreamingSocket (url) {\n                return this.createSocket(http_streaming_socket, url);\n            },\n            createPollingSocket (url) {\n                return this.createSocket(http_polling_socket, url);\n            },\n            createSocket (hooks, url) {\n                return new http_socket(hooks, url);\n            },\n            createXHR (method, url) {\n                return this.createRequest(http_xhr_request, method, url);\n            },\n            createRequest (hooks, method, url) {\n                return new http_request_HTTPRequest(hooks, method, url);\n            }\n        };\n        /* harmony default export */ var http_http = HTTP;\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/runtime.ts\n        var Isomorphic = {\n            getDefaultStrategy: default_strategy,\n            Transports: transports,\n            transportConnectionInitializer: transport_connection_initializer,\n            HTTPFactory: http_http,\n            setup (PusherClass) {\n                PusherClass.ready();\n            },\n            getLocalStorage () {\n                return undefined;\n            },\n            getClientFeatures () {\n                return keys(filterObject({\n                    ws: transports.ws\n                }, function(t) {\n                    return t.isSupported({});\n                }));\n            },\n            getProtocol () {\n                return \"http:\";\n            },\n            isXHRSupported () {\n                return true;\n            },\n            createSocketRequest (method, url) {\n                if (this.isXHRSupported()) {\n                    return this.HTTPFactory.createXHR(method, url);\n                } else {\n                    throw \"Cross-origin HTTP requests are not supported\";\n                }\n            },\n            createXHR () {\n                var Constructor = this.getXHRAPI();\n                return new Constructor();\n            },\n            createWebSocket (url) {\n                var Constructor = this.getWebSocketAPI();\n                return new Constructor(url);\n            },\n            addUnloadListener (listener) {},\n            removeUnloadListener (listener) {}\n        };\n        /* harmony default export */ var runtime = Isomorphic;\n        // EXTERNAL MODULE: ./node_modules/faye-websocket/lib/faye/websocket.js\n        var websocket = __nested_webpack_require_266496__(18);\n        // EXTERNAL MODULE: ./node_modules/xmlhttprequest/lib/XMLHttpRequest.js\n        var XMLHttpRequest = __nested_webpack_require_266496__(19);\n        // CONCATENATED MODULE: ./src/runtimes/node/net_info.ts\n        class net_info_NetInfo extends dispatcher_Dispatcher {\n            isOnline() {\n                return true;\n            }\n        }\n        var net_info_Network = new net_info_NetInfo();\n        // CONCATENATED MODULE: ./src/core/auth/options.ts\n        var AuthRequestType;\n        (function(AuthRequestType) {\n            AuthRequestType[\"UserAuthentication\"] = \"user-authentication\";\n            AuthRequestType[\"ChannelAuthorization\"] = \"channel-authorization\";\n        })(AuthRequestType || (AuthRequestType = {}));\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/auth/xhr_auth.ts\n        const ajax = function(context, query, authOptions, authRequestType, callback) {\n            const xhr = node_runtime.createXHR();\n            xhr.open(\"POST\", authOptions.endpoint, true);\n            xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            for(var headerName in authOptions.headers){\n                xhr.setRequestHeader(headerName, authOptions.headers[headerName]);\n            }\n            if (authOptions.headersProvider != null) {\n                let dynamicHeaders = authOptions.headersProvider();\n                for(var headerName in dynamicHeaders){\n                    xhr.setRequestHeader(headerName, dynamicHeaders[headerName]);\n                }\n            }\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4) {\n                    if (xhr.status === 200) {\n                        let data;\n                        let parsed = false;\n                        try {\n                            data = JSON.parse(xhr.responseText);\n                            parsed = true;\n                        } catch (e) {\n                            callback(new HTTPAuthError(200, `JSON returned from ${authRequestType.toString()} endpoint was invalid, yet status code was 200. Data was: ${xhr.responseText}`), null);\n                        }\n                        if (parsed) {\n                            callback(null, data);\n                        }\n                    } else {\n                        let suffix = \"\";\n                        switch(authRequestType){\n                            case AuthRequestType.UserAuthentication:\n                                suffix = url_store.buildLogSuffix(\"authenticationEndpoint\");\n                                break;\n                            case AuthRequestType.ChannelAuthorization:\n                                suffix = `Clients must be authorized to join private or presence channels. ${url_store.buildLogSuffix(\"authorizationEndpoint\")}`;\n                                break;\n                        }\n                        callback(new HTTPAuthError(xhr.status, `Unable to retrieve auth string from ${authRequestType.toString()} endpoint - ` + `received status: ${xhr.status} from ${authOptions.endpoint}. ${suffix}`), null);\n                    }\n                }\n            };\n            xhr.send(query);\n            return xhr;\n        };\n        /* harmony default export */ var xhr_auth = ajax;\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/timeline/xhr_timeline.ts\n        var getAgent = function(sender, useTLS) {\n            return function(data, callback) {\n                var scheme = \"http\" + (useTLS ? \"s\" : \"\") + \"://\";\n                var url = scheme + (sender.host || sender.options.host) + sender.options.path;\n                var query = buildQueryString(data);\n                url += \"/\" + 2 + \"?\" + query;\n                var xhr = node_runtime.createXHR();\n                xhr.open(\"GET\", url, true);\n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState === 4) {\n                        let { status, responseText } = xhr;\n                        if (status !== 200) {\n                            logger.debug(`TimelineSender Error: received ${status} from stats.pusher.com`);\n                            return;\n                        }\n                        try {\n                            var { host } = JSON.parse(responseText);\n                        } catch (e) {\n                            logger.debug(`TimelineSenderError: invalid response ${responseText}`);\n                        }\n                        if (host) {\n                            sender.host = host;\n                        }\n                    }\n                };\n                xhr.send();\n            };\n        };\n        var xhr_timeline_xhr = {\n            name: \"xhr\",\n            getAgent\n        };\n        /* harmony default export */ var xhr_timeline = xhr_timeline_xhr;\n        // EXTERNAL MODULE: external \"crypto\"\n        var external_crypto_ = __nested_webpack_require_266496__(3);\n        // CONCATENATED MODULE: ./src/runtimes/node/runtime.ts\n        const { getDefaultStrategy: runtime_getDefaultStrategy, Transports: runtime_Transports, setup, getProtocol, isXHRSupported, getLocalStorage, createXHR, createWebSocket, addUnloadListener, removeUnloadListener, transportConnectionInitializer, createSocketRequest, HTTPFactory } = runtime;\n        const NodeJS = {\n            getDefaultStrategy: runtime_getDefaultStrategy,\n            Transports: runtime_Transports,\n            setup,\n            getProtocol,\n            isXHRSupported,\n            createSocketRequest,\n            getLocalStorage,\n            createXHR,\n            createWebSocket,\n            addUnloadListener,\n            removeUnloadListener,\n            transportConnectionInitializer,\n            HTTPFactory,\n            TimelineTransport: xhr_timeline,\n            getAuthorizers () {\n                return {\n                    ajax: xhr_auth\n                };\n            },\n            getWebSocketAPI () {\n                return websocket[\"Client\"];\n            },\n            getXHRAPI () {\n                return XMLHttpRequest[\"XMLHttpRequest\"];\n            },\n            getNetwork () {\n                return net_info_Network;\n            },\n            randomInt (max) {\n                return Object(external_crypto_[\"randomInt\"])(max);\n            }\n        };\n        /* harmony default export */ var node_runtime = NodeJS;\n        // CONCATENATED MODULE: ./src/core/timeline/level.ts\n        var TimelineLevel;\n        (function(TimelineLevel) {\n            TimelineLevel[TimelineLevel[\"ERROR\"] = 3] = \"ERROR\";\n            TimelineLevel[TimelineLevel[\"INFO\"] = 6] = \"INFO\";\n            TimelineLevel[TimelineLevel[\"DEBUG\"] = 7] = \"DEBUG\";\n        })(TimelineLevel || (TimelineLevel = {}));\n        /* harmony default export */ var timeline_level = TimelineLevel;\n        // CONCATENATED MODULE: ./src/core/timeline/timeline.ts\n        class timeline_Timeline {\n            constructor(key, session, options){\n                this.key = key;\n                this.session = session;\n                this.events = [];\n                this.options = options || {};\n                this.sent = 0;\n                this.uniqueID = 0;\n            }\n            log(level, event) {\n                if (level <= this.options.level) {\n                    this.events.push(extend({}, event, {\n                        timestamp: util.now()\n                    }));\n                    if (this.options.limit && this.events.length > this.options.limit) {\n                        this.events.shift();\n                    }\n                }\n            }\n            error(event) {\n                this.log(timeline_level.ERROR, event);\n            }\n            info(event) {\n                this.log(timeline_level.INFO, event);\n            }\n            debug(event) {\n                this.log(timeline_level.DEBUG, event);\n            }\n            isEmpty() {\n                return this.events.length === 0;\n            }\n            send(sendfn, callback) {\n                var data = extend({\n                    session: this.session,\n                    bundle: this.sent + 1,\n                    key: this.key,\n                    lib: \"js\",\n                    version: this.options.version,\n                    cluster: this.options.cluster,\n                    features: this.options.features,\n                    timeline: this.events\n                }, this.options.params);\n                this.events = [];\n                sendfn(data, (error, result)=>{\n                    if (!error) {\n                        this.sent++;\n                    }\n                    if (callback) {\n                        callback(error, result);\n                    }\n                });\n                return true;\n            }\n            generateUniqueID() {\n                this.uniqueID++;\n                return this.uniqueID;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/transport_strategy.ts\n        class transport_strategy_TransportStrategy {\n            constructor(name, priority, transport, options){\n                this.name = name;\n                this.priority = priority;\n                this.transport = transport;\n                this.options = options || {};\n            }\n            isSupported() {\n                return this.transport.isSupported({\n                    useTLS: this.options.useTLS\n                });\n            }\n            connect(minPriority, callback) {\n                if (!this.isSupported()) {\n                    return failAttempt(new UnsupportedStrategy(), callback);\n                } else if (this.priority < minPriority) {\n                    return failAttempt(new TransportPriorityTooLow(), callback);\n                }\n                var connected = false;\n                var transport = this.transport.createConnection(this.name, this.priority, this.options.key, this.options);\n                var handshake = null;\n                var onInitialized = function() {\n                    transport.unbind(\"initialized\", onInitialized);\n                    transport.connect();\n                };\n                var onOpen = function() {\n                    handshake = factory.createHandshake(transport, function(result) {\n                        connected = true;\n                        unbindListeners();\n                        callback(null, result);\n                    });\n                };\n                var onError = function(error) {\n                    unbindListeners();\n                    callback(error);\n                };\n                var onClosed = function() {\n                    unbindListeners();\n                    var serializedTransport;\n                    serializedTransport = safeJSONStringify(transport);\n                    callback(new TransportClosed(serializedTransport));\n                };\n                var unbindListeners = function() {\n                    transport.unbind(\"initialized\", onInitialized);\n                    transport.unbind(\"open\", onOpen);\n                    transport.unbind(\"error\", onError);\n                    transport.unbind(\"closed\", onClosed);\n                };\n                transport.bind(\"initialized\", onInitialized);\n                transport.bind(\"open\", onOpen);\n                transport.bind(\"error\", onError);\n                transport.bind(\"closed\", onClosed);\n                transport.initialize();\n                return {\n                    abort: ()=>{\n                        if (connected) {\n                            return;\n                        }\n                        unbindListeners();\n                        if (handshake) {\n                            handshake.close();\n                        } else {\n                            transport.close();\n                        }\n                    },\n                    forceMinPriority: (p)=>{\n                        if (connected) {\n                            return;\n                        }\n                        if (this.priority < p) {\n                            if (handshake) {\n                                handshake.close();\n                            } else {\n                                transport.close();\n                            }\n                        }\n                    }\n                };\n            }\n        }\n        function failAttempt(error, callback) {\n            util.defer(function() {\n                callback(error);\n            });\n            return {\n                abort: function() {},\n                forceMinPriority: function() {}\n            };\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/strategy_builder.ts\n        const { Transports: strategy_builder_Transports } = node_runtime;\n        var strategy_builder_defineTransport = function(config, name, type, priority, options, manager) {\n            var transportClass = strategy_builder_Transports[type];\n            if (!transportClass) {\n                throw new UnsupportedTransport(type);\n            }\n            var enabled = (!config.enabledTransports || arrayIndexOf(config.enabledTransports, name) !== -1) && (!config.disabledTransports || arrayIndexOf(config.disabledTransports, name) === -1);\n            var transport;\n            if (enabled) {\n                options = Object.assign({\n                    ignoreNullOrigin: config.ignoreNullOrigin\n                }, options);\n                transport = new transport_strategy_TransportStrategy(name, priority, manager ? manager.getAssistant(transportClass) : transportClass, options);\n            } else {\n                transport = strategy_builder_UnsupportedStrategy;\n            }\n            return transport;\n        };\n        var strategy_builder_UnsupportedStrategy = {\n            isSupported: function() {\n                return false;\n            },\n            connect: function(_, callback) {\n                var deferred = util.defer(function() {\n                    callback(new UnsupportedStrategy());\n                });\n                return {\n                    abort: function() {\n                        deferred.ensureAborted();\n                    },\n                    forceMinPriority: function() {}\n                };\n            }\n        };\n        // CONCATENATED MODULE: ./src/core/options.ts\n        function validateOptions(options) {\n            if (options == null) {\n                throw \"You must pass an options object\";\n            }\n            if (options.cluster == null) {\n                throw \"Options object must provide a cluster\";\n            }\n            if (\"disableStats\" in options) {\n                logger.warn(\"The disableStats option is deprecated in favor of enableStats\");\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/auth/user_authenticator.ts\n        const composeChannelQuery = (params, authOptions)=>{\n            var query = \"socket_id=\" + encodeURIComponent(params.socketId);\n            for(var key in authOptions.params){\n                query += \"&\" + encodeURIComponent(key) + \"=\" + encodeURIComponent(authOptions.params[key]);\n            }\n            if (authOptions.paramsProvider != null) {\n                let dynamicParams = authOptions.paramsProvider();\n                for(var key in dynamicParams){\n                    query += \"&\" + encodeURIComponent(key) + \"=\" + encodeURIComponent(dynamicParams[key]);\n                }\n            }\n            return query;\n        };\n        const UserAuthenticator = (authOptions)=>{\n            if (typeof node_runtime.getAuthorizers()[authOptions.transport] === \"undefined\") {\n                throw `'${authOptions.transport}' is not a recognized auth transport`;\n            }\n            return (params, callback)=>{\n                const query = composeChannelQuery(params, authOptions);\n                node_runtime.getAuthorizers()[authOptions.transport](node_runtime, query, authOptions, AuthRequestType.UserAuthentication, callback);\n            };\n        };\n        /* harmony default export */ var user_authenticator = UserAuthenticator;\n        // CONCATENATED MODULE: ./src/core/auth/channel_authorizer.ts\n        const channel_authorizer_composeChannelQuery = (params, authOptions)=>{\n            var query = \"socket_id=\" + encodeURIComponent(params.socketId);\n            query += \"&channel_name=\" + encodeURIComponent(params.channelName);\n            for(var key in authOptions.params){\n                query += \"&\" + encodeURIComponent(key) + \"=\" + encodeURIComponent(authOptions.params[key]);\n            }\n            if (authOptions.paramsProvider != null) {\n                let dynamicParams = authOptions.paramsProvider();\n                for(var key in dynamicParams){\n                    query += \"&\" + encodeURIComponent(key) + \"=\" + encodeURIComponent(dynamicParams[key]);\n                }\n            }\n            return query;\n        };\n        const ChannelAuthorizer = (authOptions)=>{\n            if (typeof node_runtime.getAuthorizers()[authOptions.transport] === \"undefined\") {\n                throw `'${authOptions.transport}' is not a recognized auth transport`;\n            }\n            return (params, callback)=>{\n                const query = channel_authorizer_composeChannelQuery(params, authOptions);\n                node_runtime.getAuthorizers()[authOptions.transport](node_runtime, query, authOptions, AuthRequestType.ChannelAuthorization, callback);\n            };\n        };\n        /* harmony default export */ var channel_authorizer = ChannelAuthorizer;\n        // CONCATENATED MODULE: ./src/core/auth/deprecated_channel_authorizer.ts\n        const ChannelAuthorizerProxy = (pusher, authOptions, channelAuthorizerGenerator)=>{\n            const deprecatedAuthorizerOptions = {\n                authTransport: authOptions.transport,\n                authEndpoint: authOptions.endpoint,\n                auth: {\n                    params: authOptions.params,\n                    headers: authOptions.headers\n                }\n            };\n            return (params, callback)=>{\n                const channel = pusher.channel(params.channelName);\n                const channelAuthorizer = channelAuthorizerGenerator(channel, deprecatedAuthorizerOptions);\n                channelAuthorizer.authorize(params.socketId, callback);\n            };\n        };\n        // CONCATENATED MODULE: ./src/core/config.ts\n        function getConfig(opts, pusher) {\n            let config = {\n                activityTimeout: opts.activityTimeout || defaults.activityTimeout,\n                cluster: opts.cluster,\n                httpPath: opts.httpPath || defaults.httpPath,\n                httpPort: opts.httpPort || defaults.httpPort,\n                httpsPort: opts.httpsPort || defaults.httpsPort,\n                pongTimeout: opts.pongTimeout || defaults.pongTimeout,\n                statsHost: opts.statsHost || defaults.stats_host,\n                unavailableTimeout: opts.unavailableTimeout || defaults.unavailableTimeout,\n                wsPath: opts.wsPath || defaults.wsPath,\n                wsPort: opts.wsPort || defaults.wsPort,\n                wssPort: opts.wssPort || defaults.wssPort,\n                enableStats: getEnableStatsConfig(opts),\n                httpHost: getHttpHost(opts),\n                useTLS: shouldUseTLS(opts),\n                wsHost: getWebsocketHost(opts),\n                userAuthenticator: buildUserAuthenticator(opts),\n                channelAuthorizer: buildChannelAuthorizer(opts, pusher)\n            };\n            if (\"disabledTransports\" in opts) config.disabledTransports = opts.disabledTransports;\n            if (\"enabledTransports\" in opts) config.enabledTransports = opts.enabledTransports;\n            if (\"ignoreNullOrigin\" in opts) config.ignoreNullOrigin = opts.ignoreNullOrigin;\n            if (\"timelineParams\" in opts) config.timelineParams = opts.timelineParams;\n            if (\"nacl\" in opts) {\n                config.nacl = opts.nacl;\n            }\n            return config;\n        }\n        function getHttpHost(opts) {\n            if (opts.httpHost) {\n                return opts.httpHost;\n            }\n            if (opts.cluster) {\n                return `sockjs-${opts.cluster}.pusher.com`;\n            }\n            return defaults.httpHost;\n        }\n        function getWebsocketHost(opts) {\n            if (opts.wsHost) {\n                return opts.wsHost;\n            }\n            return getWebsocketHostFromCluster(opts.cluster);\n        }\n        function getWebsocketHostFromCluster(cluster) {\n            return `ws-${cluster}.pusher.com`;\n        }\n        function shouldUseTLS(opts) {\n            if (node_runtime.getProtocol() === \"https:\") {\n                return true;\n            } else if (opts.forceTLS === false) {\n                return false;\n            }\n            return true;\n        }\n        function getEnableStatsConfig(opts) {\n            if (\"enableStats\" in opts) {\n                return opts.enableStats;\n            }\n            if (\"disableStats\" in opts) {\n                return !opts.disableStats;\n            }\n            return false;\n        }\n        const hasCustomHandler = (auth)=>{\n            return \"customHandler\" in auth && auth[\"customHandler\"] != null;\n        };\n        function buildUserAuthenticator(opts) {\n            const userAuthentication = Object.assign(Object.assign({}, defaults.userAuthentication), opts.userAuthentication);\n            if (hasCustomHandler(userAuthentication)) {\n                return userAuthentication[\"customHandler\"];\n            }\n            return user_authenticator(userAuthentication);\n        }\n        function buildChannelAuth(opts, pusher) {\n            let channelAuthorization;\n            if (\"channelAuthorization\" in opts) {\n                channelAuthorization = Object.assign(Object.assign({}, defaults.channelAuthorization), opts.channelAuthorization);\n            } else {\n                channelAuthorization = {\n                    transport: opts.authTransport || defaults.authTransport,\n                    endpoint: opts.authEndpoint || defaults.authEndpoint\n                };\n                if (\"auth\" in opts) {\n                    if (\"params\" in opts.auth) channelAuthorization.params = opts.auth.params;\n                    if (\"headers\" in opts.auth) channelAuthorization.headers = opts.auth.headers;\n                }\n                if (\"authorizer\" in opts) {\n                    return {\n                        customHandler: ChannelAuthorizerProxy(pusher, channelAuthorization, opts.authorizer)\n                    };\n                }\n            }\n            return channelAuthorization;\n        }\n        function buildChannelAuthorizer(opts, pusher) {\n            const channelAuthorization = buildChannelAuth(opts, pusher);\n            if (hasCustomHandler(channelAuthorization)) {\n                return channelAuthorization[\"customHandler\"];\n            }\n            return channel_authorizer(channelAuthorization);\n        }\n        // CONCATENATED MODULE: ./src/core/watchlist.ts\n        class watchlist_WatchlistFacade extends dispatcher_Dispatcher {\n            constructor(pusher){\n                super(function(eventName, data) {\n                    logger.debug(`No callbacks on watchlist events for ${eventName}`);\n                });\n                this.pusher = pusher;\n                this.bindWatchlistInternalEvent();\n            }\n            handleEvent(pusherEvent) {\n                pusherEvent.data.events.forEach((watchlistEvent)=>{\n                    this.emit(watchlistEvent.name, watchlistEvent);\n                });\n            }\n            bindWatchlistInternalEvent() {\n                this.pusher.connection.bind(\"message\", (pusherEvent)=>{\n                    var eventName = pusherEvent.event;\n                    if (eventName === \"pusher_internal:watchlist_events\") {\n                        this.handleEvent(pusherEvent);\n                    }\n                });\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/utils/flat_promise.ts\n        function flatPromise() {\n            let resolve, reject;\n            const promise = new Promise((res, rej)=>{\n                resolve = res;\n                reject = rej;\n            });\n            return {\n                promise,\n                resolve,\n                reject\n            };\n        }\n        /* harmony default export */ var flat_promise = flatPromise;\n        // CONCATENATED MODULE: ./src/core/user.ts\n        class user_UserFacade extends dispatcher_Dispatcher {\n            constructor(pusher){\n                super(function(eventName, data) {\n                    logger.debug(\"No callbacks on user for \" + eventName);\n                });\n                this.signin_requested = false;\n                this.user_data = null;\n                this.serverToUserChannel = null;\n                this.signinDonePromise = null;\n                this._signinDoneResolve = null;\n                this._onAuthorize = (err, authData)=>{\n                    if (err) {\n                        logger.warn(`Error during signin: ${err}`);\n                        this._cleanup();\n                        return;\n                    }\n                    this.pusher.send_event(\"pusher:signin\", {\n                        auth: authData.auth,\n                        user_data: authData.user_data\n                    });\n                };\n                this.pusher = pusher;\n                this.pusher.connection.bind(\"state_change\", ({ previous, current })=>{\n                    if (previous !== \"connected\" && current === \"connected\") {\n                        this._signin();\n                    }\n                    if (previous === \"connected\" && current !== \"connected\") {\n                        this._cleanup();\n                        this._newSigninPromiseIfNeeded();\n                    }\n                });\n                this.watchlist = new watchlist_WatchlistFacade(pusher);\n                this.pusher.connection.bind(\"message\", (event)=>{\n                    var eventName = event.event;\n                    if (eventName === \"pusher:signin_success\") {\n                        this._onSigninSuccess(event.data);\n                    }\n                    if (this.serverToUserChannel && this.serverToUserChannel.name === event.channel) {\n                        this.serverToUserChannel.handleEvent(event);\n                    }\n                });\n            }\n            signin() {\n                if (this.signin_requested) {\n                    return;\n                }\n                this.signin_requested = true;\n                this._signin();\n            }\n            _signin() {\n                if (!this.signin_requested) {\n                    return;\n                }\n                this._newSigninPromiseIfNeeded();\n                if (this.pusher.connection.state !== \"connected\") {\n                    return;\n                }\n                this.pusher.config.userAuthenticator({\n                    socketId: this.pusher.connection.socket_id\n                }, this._onAuthorize);\n            }\n            _onSigninSuccess(data) {\n                try {\n                    this.user_data = JSON.parse(data.user_data);\n                } catch (e) {\n                    logger.error(`Failed parsing user data after signin: ${data.user_data}`);\n                    this._cleanup();\n                    return;\n                }\n                if (typeof this.user_data.id !== \"string\" || this.user_data.id === \"\") {\n                    logger.error(`user_data doesn't contain an id. user_data: ${this.user_data}`);\n                    this._cleanup();\n                    return;\n                }\n                this._signinDoneResolve();\n                this._subscribeChannels();\n            }\n            _subscribeChannels() {\n                const ensure_subscribed = (channel)=>{\n                    if (channel.subscriptionPending && channel.subscriptionCancelled) {\n                        channel.reinstateSubscription();\n                    } else if (!channel.subscriptionPending && this.pusher.connection.state === \"connected\") {\n                        channel.subscribe();\n                    }\n                };\n                this.serverToUserChannel = new channel_Channel(`#server-to-user-${this.user_data.id}`, this.pusher);\n                this.serverToUserChannel.bind_global((eventName, data)=>{\n                    if (eventName.indexOf(\"pusher_internal:\") === 0 || eventName.indexOf(\"pusher:\") === 0) {\n                        return;\n                    }\n                    this.emit(eventName, data);\n                });\n                ensure_subscribed(this.serverToUserChannel);\n            }\n            _cleanup() {\n                this.user_data = null;\n                if (this.serverToUserChannel) {\n                    this.serverToUserChannel.unbind_all();\n                    this.serverToUserChannel.disconnect();\n                    this.serverToUserChannel = null;\n                }\n                if (this.signin_requested) {\n                    this._signinDoneResolve();\n                }\n            }\n            _newSigninPromiseIfNeeded() {\n                if (!this.signin_requested) {\n                    return;\n                }\n                if (this.signinDonePromise && !this.signinDonePromise.done) {\n                    return;\n                }\n                const { promise, resolve, reject: _ } = flat_promise();\n                promise.done = false;\n                const setDone = ()=>{\n                    promise.done = true;\n                };\n                promise.then(setDone).catch(setDone);\n                this.signinDonePromise = promise;\n                this._signinDoneResolve = resolve;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/pusher.ts\n        class pusher_Pusher {\n            static ready() {\n                pusher_Pusher.isReady = true;\n                for(var i = 0, l = pusher_Pusher.instances.length; i < l; i++){\n                    pusher_Pusher.instances[i].connect();\n                }\n            }\n            static getClientFeatures() {\n                return keys(filterObject({\n                    ws: node_runtime.Transports.ws\n                }, function(t) {\n                    return t.isSupported({});\n                }));\n            }\n            constructor(app_key, options){\n                checkAppKey(app_key);\n                validateOptions(options);\n                this.key = app_key;\n                this.options = options;\n                this.config = getConfig(this.options, this);\n                this.channels = factory.createChannels();\n                this.global_emitter = new dispatcher_Dispatcher();\n                this.sessionID = node_runtime.randomInt(1000000000);\n                this.timeline = new timeline_Timeline(this.key, this.sessionID, {\n                    cluster: this.config.cluster,\n                    features: pusher_Pusher.getClientFeatures(),\n                    params: this.config.timelineParams || {},\n                    limit: 50,\n                    level: timeline_level.INFO,\n                    version: defaults.VERSION\n                });\n                if (this.config.enableStats) {\n                    this.timelineSender = factory.createTimelineSender(this.timeline, {\n                        host: this.config.statsHost,\n                        path: \"/timeline/v2/\" + node_runtime.TimelineTransport.name\n                    });\n                }\n                var getStrategy = (options)=>{\n                    return node_runtime.getDefaultStrategy(this.config, options, strategy_builder_defineTransport);\n                };\n                this.connection = factory.createConnectionManager(this.key, {\n                    getStrategy: getStrategy,\n                    timeline: this.timeline,\n                    activityTimeout: this.config.activityTimeout,\n                    pongTimeout: this.config.pongTimeout,\n                    unavailableTimeout: this.config.unavailableTimeout,\n                    useTLS: Boolean(this.config.useTLS)\n                });\n                this.connection.bind(\"connected\", ()=>{\n                    this.subscribeAll();\n                    if (this.timelineSender) {\n                        this.timelineSender.send(this.connection.isUsingTLS());\n                    }\n                });\n                this.connection.bind(\"message\", (event)=>{\n                    var eventName = event.event;\n                    var internal = eventName.indexOf(\"pusher_internal:\") === 0;\n                    if (event.channel) {\n                        var channel = this.channel(event.channel);\n                        if (channel) {\n                            channel.handleEvent(event);\n                        }\n                    }\n                    if (!internal) {\n                        this.global_emitter.emit(event.event, event.data);\n                    }\n                });\n                this.connection.bind(\"connecting\", ()=>{\n                    this.channels.disconnect();\n                });\n                this.connection.bind(\"disconnected\", ()=>{\n                    this.channels.disconnect();\n                });\n                this.connection.bind(\"error\", (err)=>{\n                    logger.warn(err);\n                });\n                pusher_Pusher.instances.push(this);\n                this.timeline.info({\n                    instances: pusher_Pusher.instances.length\n                });\n                this.user = new user_UserFacade(this);\n                if (pusher_Pusher.isReady) {\n                    this.connect();\n                }\n            }\n            switchCluster(options) {\n                const { appKey, cluster } = options;\n                this.key = appKey;\n                this.options = Object.assign(Object.assign({}, this.options), {\n                    cluster\n                });\n                this.config = getConfig(this.options, this);\n                this.connection.switchCluster(this.key);\n            }\n            channel(name) {\n                return this.channels.find(name);\n            }\n            allChannels() {\n                return this.channels.all();\n            }\n            connect() {\n                this.connection.connect();\n                if (this.timelineSender) {\n                    if (!this.timelineSenderTimer) {\n                        var usingTLS = this.connection.isUsingTLS();\n                        var timelineSender = this.timelineSender;\n                        this.timelineSenderTimer = new timers_PeriodicTimer(60000, function() {\n                            timelineSender.send(usingTLS);\n                        });\n                    }\n                }\n            }\n            disconnect() {\n                this.connection.disconnect();\n                if (this.timelineSenderTimer) {\n                    this.timelineSenderTimer.ensureAborted();\n                    this.timelineSenderTimer = null;\n                }\n            }\n            bind(event_name, callback, context) {\n                this.global_emitter.bind(event_name, callback, context);\n                return this;\n            }\n            unbind(event_name, callback, context) {\n                this.global_emitter.unbind(event_name, callback, context);\n                return this;\n            }\n            bind_global(callback) {\n                this.global_emitter.bind_global(callback);\n                return this;\n            }\n            unbind_global(callback) {\n                this.global_emitter.unbind_global(callback);\n                return this;\n            }\n            unbind_all(callback) {\n                this.global_emitter.unbind_all();\n                return this;\n            }\n            subscribeAll() {\n                var channelName;\n                for(channelName in this.channels.channels){\n                    if (this.channels.channels.hasOwnProperty(channelName)) {\n                        this.subscribe(channelName);\n                    }\n                }\n            }\n            subscribe(channel_name) {\n                var channel = this.channels.add(channel_name, this);\n                if (channel.subscriptionPending && channel.subscriptionCancelled) {\n                    channel.reinstateSubscription();\n                } else if (!channel.subscriptionPending && this.connection.state === \"connected\") {\n                    channel.subscribe();\n                }\n                return channel;\n            }\n            unsubscribe(channel_name) {\n                var channel = this.channels.find(channel_name);\n                if (channel && channel.subscriptionPending) {\n                    channel.cancelSubscription();\n                } else {\n                    channel = this.channels.remove(channel_name);\n                    if (channel && channel.subscribed) {\n                        channel.unsubscribe();\n                    }\n                }\n            }\n            send_event(event_name, data, channel) {\n                return this.connection.send_event(event_name, data, channel);\n            }\n            shouldUseTLS() {\n                return this.config.useTLS;\n            }\n            signin() {\n                this.user.signin();\n            }\n        }\n        pusher_Pusher.instances = [];\n        pusher_Pusher.isReady = false;\n        pusher_Pusher.logToConsole = false;\n        pusher_Pusher.Runtime = node_runtime;\n        pusher_Pusher.ScriptReceivers = node_runtime.ScriptReceivers;\n        pusher_Pusher.DependenciesReceivers = node_runtime.DependenciesReceivers;\n        pusher_Pusher.auth_callbacks = node_runtime.auth_callbacks;\n        /* harmony default export */ var core_pusher = pusher_Pusher;\n        function checkAppKey(key) {\n            if (key === null || key === undefined) {\n                throw \"You must pass your app key when you instantiate Pusher.\";\n            }\n        }\n        node_runtime.setup(pusher_Pusher);\n        // EXTERNAL MODULE: ./node_modules/tweetnacl/nacl-fast.js\n        var nacl_fast = __nested_webpack_require_266496__(20);\n        // CONCATENATED MODULE: ./src/core/pusher-with-encryption.ts\n        class pusher_with_encryption_PusherWithEncryption extends core_pusher {\n            constructor(app_key, options){\n                core_pusher.logToConsole = pusher_with_encryption_PusherWithEncryption.logToConsole;\n                core_pusher.log = pusher_with_encryption_PusherWithEncryption.log;\n                validateOptions(options);\n                options.nacl = nacl_fast;\n                super(app_key, options);\n            }\n        }\n    /***/ }\n]); //# sourceMappingURL=pusher.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHVzaGVyLWpzL2Rpc3Qvbm9kZS9wdXNoZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DO0FBRURBLE9BQU9DLE9BQU8sR0FDTCxNQUFILEdBQUksU0FBU0MsT0FBTztJQUMxQixNQUFNLEdBQUksbUJBQW1CO0lBQzdCLE1BQU0sR0FBSSxJQUFJQyxtQkFBbUIsQ0FBQztJQUNsQyxNQUFNLEdBQ04sTUFBTSxHQUFJLHVCQUF1QjtJQUNqQyxNQUFNLEdBQUksU0FBU0MsOEJBQW1CQSxDQUFDQyxRQUFRO1FBQy9DLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1FBQ3pDLE1BQU0sR0FBSyxJQUFHRixnQkFBZ0IsQ0FBQ0UsU0FBUyxFQUFFO1lBQzFDLE1BQU0sR0FBTSxPQUFPRixnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDSixPQUFPO1FBQ3JELE1BQU0sR0FBSztRQUNYLE1BQU0sR0FBSyxrREFBa0Q7UUFDN0QsTUFBTSxHQUFLLElBQUlELFVBQVNHLGdCQUFnQixDQUFDRSxTQUFTLEdBQUc7WUFDckQsTUFBTSxHQUFNQyxHQUFHRDtZQUNmLE1BQU0sR0FBTUUsR0FBRztZQUNmLE1BQU0sR0FBTU4sU0FBUyxDQUFDO1FBQ1g7UUFDWCxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtRQUN6QyxNQUFNLEdBQUtDLE9BQU8sQ0FBQ0csU0FBUyxDQUFDRyxJQUFJLENBQUNSLFFBQU9DLE9BQU8sRUFBRUQsU0FBUUEsUUFBT0MsT0FBTyxFQUFFRyw4QkFBbUJBO1FBQzdGLE1BQU0sR0FDTixNQUFNLEdBQUssNEJBQTRCO1FBQ3ZDLE1BQU0sR0FBS0osUUFBT08sQ0FBQyxHQUFHO1FBQ3RCLE1BQU0sR0FDTixNQUFNLEdBQUssbUNBQW1DO1FBQzlDLE1BQU0sR0FBSyxPQUFPUCxRQUFPQyxPQUFPO0lBQ2hDLE1BQU0sR0FBSTtJQUNWLE1BQU0sR0FDTixNQUFNLEdBQ04sTUFBTSxHQUFJLGtEQUFrRDtJQUM1RCxNQUFNLEdB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bkIsSUFBSTtnQkFDbEI7Z0JBRUFILEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBTyxHQUFHLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBTyxHQUFHLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FB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QTBCLEdBQUcsSUFBSTVlLGNBQWUwZDtRQUNoRCxTQUFTSSxZQUFZMWtELEdBQUc7WUFDcEIsSUFBSUEsUUFBUSxRQUFRQSxRQUFROEIsV0FBVztnQkFDbkMsTUFBTTtZQUNWO1FBQ0o7UUFDQW9sQyxhQUFhcVcsS0FBSyxDQUFDK0c7UUFFbkIseURBQXlEO1FBQ3pELElBQUltQixZQUFZam5ELGlDQUFtQkEsQ0FBQztRQUVwQyw0REFBNEQ7UUFJNUQsTUFBTW9oQyxvREFBb0RnSDtZQUN0RDU5QixZQUFZeTdDLE9BQU8sRUFBRWhpRCxPQUFPLENBQUU7Z0JBQzFCbWtDLFlBQVlDLFlBQVksR0FBR2pILDRDQUE0Q2lILFlBQVk7Z0JBQ25GRCxZQUFZTCxHQUFHLEdBQUczRyw0Q0FBNEMyRyxHQUFHO2dCQUNqRTdqQyxnQkFBZ0JEO2dCQUNoQkEsUUFBUWdjLElBQUksR0FBR2duQztnQkFDZixLQUFLLENBQUNoQixTQUFTaGlEO1lBQ25CO1FBQ0o7SUFHQSxHQUFHLEdBQUc7Q0FDSSxHQUNWLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXQtYXBwLXN0cmF5YWlkY29ubmVjdC8uL25vZGVfbW9kdWxlcy9wdXNoZXItanMvZGlzdC9ub2RlL3B1c2hlci5qcz9hZDUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogUHVzaGVyIEphdmFTY3JpcHQgTGlicmFyeSB2OC40LjAtcmMyXG4gKiBodHRwczovL3B1c2hlci5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMjAsIFB1c2hlclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbmNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID1cbi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMjEpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEJ1ZmZlciAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLkJ1ZmZlcixcbiAgICBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMykuRXZlbnRFbWl0dGVyLFxuICAgIHV0aWwgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLFxuICAgIHN0cmVhbXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSxcbiAgICBIZWFkZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KSxcbiAgICBSZWFkZXIgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cbnZhciBCYXNlID0gZnVuY3Rpb24ocmVxdWVzdCwgdXJsLCBvcHRpb25zKSB7XG4gIEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgQmFzZS52YWxpZGF0ZU9wdGlvbnMob3B0aW9ucyB8fCB7fSwgWydtYXhMZW5ndGgnLCAnbWFza2luZycsICdyZXF1aXJlTWFza2luZycsICdwcm90b2NvbHMnXSk7XG5cbiAgdGhpcy5fcmVxdWVzdCAgID0gcmVxdWVzdDtcbiAgdGhpcy5fcmVhZGVyICAgID0gbmV3IFJlYWRlcigpO1xuICB0aGlzLl9vcHRpb25zICAgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9tYXhMZW5ndGggPSB0aGlzLl9vcHRpb25zLm1heExlbmd0aCB8fCB0aGlzLk1BWF9MRU5HVEg7XG4gIHRoaXMuX2hlYWRlcnMgICA9IG5ldyBIZWFkZXJzKCk7XG4gIHRoaXMuX19xdWV1ZSAgICA9IFtdO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAwO1xuICB0aGlzLnVybCAgICAgICAgPSB1cmw7XG5cbiAgdGhpcy5pbyA9IG5ldyBzdHJlYW1zLklPKHRoaXMpO1xuICB0aGlzLm1lc3NhZ2VzID0gbmV3IHN0cmVhbXMuTWVzc2FnZXModGhpcyk7XG4gIHRoaXMuX2JpbmRFdmVudExpc3RlbmVycygpO1xufTtcbnV0aWwuaW5oZXJpdHMoQmFzZSwgRW1pdHRlcik7XG5cbkJhc2UuaXNXZWJTb2NrZXQgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIHZhciBjb25uZWN0aW9uID0gcmVxdWVzdC5oZWFkZXJzLmNvbm5lY3Rpb24gfHwgJycsXG4gICAgICB1cGdyYWRlICAgID0gcmVxdWVzdC5oZWFkZXJzLnVwZ3JhZGUgfHwgJyc7XG5cbiAgcmV0dXJuIHJlcXVlc3QubWV0aG9kID09PSAnR0VUJyAmJlxuICAgICAgICAgY29ubmVjdGlvbi50b0xvd2VyQ2FzZSgpLnNwbGl0KC8gKiwgKi8pLmluZGV4T2YoJ3VwZ3JhZGUnKSA+PSAwICYmXG4gICAgICAgICB1cGdyYWRlLnRvTG93ZXJDYXNlKCkgPT09ICd3ZWJzb2NrZXQnO1xufTtcblxuQmFzZS52YWxpZGF0ZU9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zLCB2YWxpZEtleXMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICBpZiAodmFsaWRLZXlzLmluZGV4T2Yoa2V5KSA8IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBvcHRpb246ICcgKyBrZXkpO1xuICB9XG59O1xuXG52YXIgaW5zdGFuY2UgPSB7XG4gIC8vIFRoaXMgaXMgNjRNQiwgc21hbGwgZW5vdWdoIGZvciBhbiBhdmVyYWdlIFZQUyB0byBoYW5kbGUgd2l0aG91dFxuICAvLyBjcmFzaGluZyBmcm9tIHByb2Nlc3Mgb3V0IG9mIG1lbW9yeVxuICBNQVhfTEVOR1RIOiAweDNmZmZmZmYsXG5cbiAgU1RBVEVTOiBbJ2Nvbm5lY3RpbmcnLCAnb3BlbicsICdjbG9zaW5nJywgJ2Nsb3NlZCddLFxuXG4gIF9iaW5kRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFByb3RvY29sIGVycm9ycyBhcmUgaW5mb3JtYXRpb25hbCBhbmQgZG8gbm90IGhhdmUgdG8gYmUgaGFuZGxlZFxuICAgIHRoaXMubWVzc2FnZXMub24oJ2Vycm9yJywgZnVuY3Rpb24oKSB7fSk7XG5cbiAgICB0aGlzLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBtZXNzYWdlcyA9IHNlbGYubWVzc2FnZXM7XG4gICAgICBpZiAobWVzc2FnZXMucmVhZGFibGUpIG1lc3NhZ2VzLmVtaXQoJ2RhdGEnLCBldmVudC5kYXRhKTtcbiAgICB9KTtcblxuICAgIHRoaXMub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIHZhciBtZXNzYWdlcyA9IHNlbGYubWVzc2FnZXM7XG4gICAgICBpZiAobWVzc2FnZXMucmVhZGFibGUpIG1lc3NhZ2VzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbignY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtZXNzYWdlcyA9IHNlbGYubWVzc2FnZXM7XG4gICAgICBpZiAoIW1lc3NhZ2VzLnJlYWRhYmxlKSByZXR1cm47XG4gICAgICBtZXNzYWdlcy5yZWFkYWJsZSA9IG1lc3NhZ2VzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICBtZXNzYWdlcy5lbWl0KCdlbmQnKTtcbiAgICB9KTtcbiAgfSxcblxuICBnZXRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuU1RBVEVTW3RoaXMucmVhZHlTdGF0ZV0gfHwgbnVsbDtcbiAgfSxcblxuICBhZGRFeHRlbnNpb246IGZ1bmN0aW9uKGV4dGVuc2lvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBzZXRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IDApIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLl9oZWFkZXJzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IDApIHJldHVybiBmYWxzZTtcblxuICAgIGlmICghQmFzZS5pc1dlYlNvY2tldCh0aGlzLl9yZXF1ZXN0KSlcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsSGFuZHNoYWtlKG5ldyBFcnJvcignTm90IGEgV2ViU29ja2V0IHJlcXVlc3QnKSk7XG5cbiAgICB2YXIgcmVzcG9uc2U7XG5cbiAgICB0cnkge1xuICAgICAgcmVzcG9uc2UgPSB0aGlzLl9oYW5kc2hha2VSZXNwb25zZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFpbEhhbmRzaGFrZShlcnJvcik7XG4gICAgfVxuXG4gICAgdGhpcy5fd3JpdGUocmVzcG9uc2UpO1xuICAgIGlmICh0aGlzLl9zdGFnZSAhPT0gLTEpIHRoaXMuX29wZW4oKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBfZmFpbEhhbmRzaGFrZTogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgaGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3BsYWluJyk7XG4gICAgaGVhZGVycy5zZXQoJ0NvbnRlbnQtTGVuZ3RoJywgQnVmZmVyLmJ5dGVMZW5ndGgoZXJyb3IubWVzc2FnZSwgJ3V0ZjgnKSk7XG5cbiAgICBoZWFkZXJzID0gWydIVFRQLzEuMSA0MDAgQmFkIFJlcXVlc3QnLCBoZWFkZXJzLnRvU3RyaW5nKCksIGVycm9yLm1lc3NhZ2VdO1xuICAgIHRoaXMuX3dyaXRlKEJ1ZmZlci5mcm9tKGhlYWRlcnMuam9pbignXFxyXFxuJyksICd1dGY4JykpO1xuICAgIHRoaXMuX2ZhaWwoJ3Byb3RvY29sX2Vycm9yJywgZXJyb3IubWVzc2FnZSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgdGV4dDogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLmZyYW1lKG1lc3NhZ2UpO1xuICB9LFxuXG4gIGJpbmFyeTogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBwaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgcG9uZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgY2xvc2U6IGZ1bmN0aW9uKHJlYXNvbiwgY29kZSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IDEpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAzO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBuZXcgQmFzZS5DbG9zZUV2ZW50KG51bGwsIG51bGwpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBfb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gMTtcbiAgICB0aGlzLl9fcXVldWUuZm9yRWFjaChmdW5jdGlvbihhcmdzKSB7IHRoaXMuZnJhbWUuYXBwbHkodGhpcywgYXJncykgfSwgdGhpcyk7XG4gICAgdGhpcy5fX3F1ZXVlID0gW107XG4gICAgdGhpcy5lbWl0KCdvcGVuJywgbmV3IEJhc2UuT3BlbkV2ZW50KCkpO1xuICB9LFxuXG4gIF9xdWV1ZTogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHRoaXMuX19xdWV1ZS5wdXNoKG1lc3NhZ2UpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIF93cml0ZTogZnVuY3Rpb24oY2h1bmspIHtcbiAgICB2YXIgaW8gPSB0aGlzLmlvO1xuICAgIGlmIChpby5yZWFkYWJsZSkgaW8uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgfSxcblxuICBfZmFpbDogZnVuY3Rpb24odHlwZSwgbWVzc2FnZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IDI7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG59O1xuXG5mb3IgKHZhciBrZXkgaW4gaW5zdGFuY2UpXG4gIEJhc2UucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5cbkJhc2UuQ29ubmVjdEV2ZW50ID0gZnVuY3Rpb24oKSB7fTtcblxuQmFzZS5PcGVuRXZlbnQgPSBmdW5jdGlvbigpIHt9O1xuXG5CYXNlLkNsb3NlRXZlbnQgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgdGhpcy5jb2RlICAgPSBjb2RlO1xuICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbn07XG5cbkJhc2UuTWVzc2FnZUV2ZW50ID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLmRhdGEgPSBkYXRhO1xufTtcblxuQmFzZS5QaW5nRXZlbnQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG59O1xuXG5CYXNlLlBvbmdFdmVudCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZTtcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gUHJvdG9jb2wgcmVmZXJlbmNlczpcbi8vXG4vLyAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWhpeGllLXRoZXdlYnNvY2tldHByb3RvY29sLTc1XG4vLyAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWhpeGllLXRoZXdlYnNvY2tldHByb3RvY29sLTc2XG4vLyAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtaHliaS10aGV3ZWJzb2NrZXRwcm90b2NvbC0xN1xuXG52YXIgQmFzZSAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKSxcbiAgICBDbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KSxcbiAgICBTZXJ2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblxudmFyIERyaXZlciA9IHtcbiAgY2xpZW50OiBmdW5jdGlvbih1cmwsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy5tYXNraW5nID09PSB1bmRlZmluZWQpIG9wdGlvbnMubWFza2luZyA9IHRydWU7XG4gICAgcmV0dXJuIG5ldyBDbGllbnQodXJsLCBvcHRpb25zKTtcbiAgfSxcblxuICBzZXJ2ZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy5yZXF1aXJlTWFza2luZyA9PT0gdW5kZWZpbmVkKSBvcHRpb25zLnJlcXVpcmVNYXNraW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gbmV3IFNlcnZlcihvcHRpb25zKTtcbiAgfSxcblxuICBodHRwOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gU2VydmVyLmh0dHAuYXBwbHkoU2VydmVyLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIGlzU2VjdXJlUmVxdWVzdDogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHJldHVybiBTZXJ2ZXIuaXNTZWN1cmVSZXF1ZXN0KHJlcXVlc3QpO1xuICB9LFxuXG4gIGlzV2ViU29ja2V0OiBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIEJhc2UuaXNXZWJTb2NrZXQocmVxdWVzdCk7XG4gIH0sXG5cbiAgdmFsaWRhdGVPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zLCB2YWxpZEtleXMpIHtcbiAgICBCYXNlLnZhbGlkYXRlT3B0aW9ucyhvcHRpb25zLCB2YWxpZEtleXMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyaXZlcjtcblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXJsXCIpO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBvcHRpb25zKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpXG4gICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xufTtcblxuRXZlbnQucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgY2FuQnViYmxlLCBjYW5jZWxhYmxlKSB7XG4gIHRoaXMudHlwZSAgICAgICA9IGV2ZW50VHlwZTtcbiAgdGhpcy5idWJibGVzICAgID0gY2FuQnViYmxlO1xuICB0aGlzLmNhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xufTtcblxuRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge307XG5FdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgID0gZnVuY3Rpb24oKSB7fTtcblxuRXZlbnQuQ0FQVFVSSU5HX1BIQVNFID0gMTtcbkV2ZW50LkFUX1RBUkdFVCAgICAgICA9IDI7XG5FdmVudC5CVUJCTElOR19QSEFTRSAgPSAzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuXG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gQ29weXJpZ2h0IChDKSAyMDE2IERtaXRyeSBDaGVzdG55a2hcbi8vIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFBhY2thZ2UgYmFzZTY0IGltcGxlbWVudHMgQmFzZTY0IGVuY29kaW5nIGFuZCBkZWNvZGluZy5cbiAqL1xuLy8gSW52YWxpZCBjaGFyYWN0ZXIgdXNlZCBpbiBkZWNvZGluZyB0byBpbmRpY2F0ZVxuLy8gdGhhdCB0aGUgY2hhcmFjdGVyIHRvIGRlY29kZSBpcyBvdXQgb2YgcmFuZ2Ugb2Zcbi8vIGFscGhhYmV0IGFuZCBjYW5ub3QgYmUgZGVjb2RlZC5cbnZhciBJTlZBTElEX0JZVEUgPSAyNTY7XG4vKipcbiAqIEltcGxlbWVudHMgc3RhbmRhcmQgQmFzZTY0IGVuY29kaW5nLlxuICpcbiAqIE9wZXJhdGVzIGluIGNvbnN0YW50IHRpbWUuXG4gKi9cbnZhciBDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPKGRjaGVzdCk6IG1ldGhvZHMgdG8gZW5jb2RlIGNodW5rLWJ5LWNodW5rLlxuICAgIGZ1bmN0aW9uIENvZGVyKF9wYWRkaW5nQ2hhcmFjdGVyKSB7XG4gICAgICAgIGlmIChfcGFkZGluZ0NoYXJhY3RlciA9PT0gdm9pZCAwKSB7IF9wYWRkaW5nQ2hhcmFjdGVyID0gXCI9XCI7IH1cbiAgICAgICAgdGhpcy5fcGFkZGluZ0NoYXJhY3RlciA9IF9wYWRkaW5nQ2hhcmFjdGVyO1xuICAgIH1cbiAgICBDb2Rlci5wcm90b3R5cGUuZW5jb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wYWRkaW5nQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKGxlbmd0aCAqIDggKyA1KSAvIDYgfCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobGVuZ3RoICsgMikgLyAzICogNCB8IDA7XG4gICAgfTtcbiAgICBDb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIG91dCA9IFwiXCI7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBkYXRhLmxlbmd0aCAtIDI7IGkgKz0gMykge1xuICAgICAgICAgICAgdmFyIGMgPSAoZGF0YVtpXSA8PCAxNikgfCAoZGF0YVtpICsgMV0gPDwgOCkgfCAoZGF0YVtpICsgMl0pO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuX2VuY29kZUJ5dGUoKGMgPj4+IDMgKiA2KSAmIDYzKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAyICogNikgJiA2Myk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMSAqIDYpICYgNjMpO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuX2VuY29kZUJ5dGUoKGMgPj4+IDAgKiA2KSAmIDYzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdCA9IGRhdGEubGVuZ3RoIC0gaTtcbiAgICAgICAgaWYgKGxlZnQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgYyA9IChkYXRhW2ldIDw8IDE2KSB8IChsZWZ0ID09PSAyID8gZGF0YVtpICsgMV0gPDwgOCA6IDApO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuX2VuY29kZUJ5dGUoKGMgPj4+IDMgKiA2KSAmIDYzKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAyICogNikgJiA2Myk7XG4gICAgICAgICAgICBpZiAobGVmdCA9PT0gMikge1xuICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAxICogNikgJiA2Myk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5fcGFkZGluZ0NoYXJhY3RlciB8fCBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9IHRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIgfHwgXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLm1heERlY29kZWRMZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgcmV0dXJuIChsZW5ndGggKiA2ICsgNykgLyA4IHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVuZ3RoIC8gNCAqIDMgfCAwO1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLmRlY29kZWRMZW5ndGggPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhEZWNvZGVkTGVuZ3RoKHMubGVuZ3RoIC0gdGhpcy5fZ2V0UGFkZGluZ0xlbmd0aChzKSk7XG4gICAgfTtcbiAgICBDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgaWYgKHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhZGRpbmdMZW5ndGggPSB0aGlzLl9nZXRQYWRkaW5nTGVuZ3RoKHMpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcy5sZW5ndGggLSBwYWRkaW5nTGVuZ3RoO1xuICAgICAgICB2YXIgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tYXhEZWNvZGVkTGVuZ3RoKGxlbmd0aCkpO1xuICAgICAgICB2YXIgb3AgPSAwO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBoYXZlQmFkID0gMDtcbiAgICAgICAgdmFyIHYwID0gMCwgdjEgPSAwLCB2MiA9IDAsIHYzID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGggLSA0OyBpICs9IDQpIHtcbiAgICAgICAgICAgIHYwID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSArIDApKTtcbiAgICAgICAgICAgIHYxID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSArIDEpKTtcbiAgICAgICAgICAgIHYyID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSArIDIpKTtcbiAgICAgICAgICAgIHYzID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSArIDMpKTtcbiAgICAgICAgICAgIG91dFtvcCsrXSA9ICh2MCA8PCAyKSB8ICh2MSA+Pj4gNCk7XG4gICAgICAgICAgICBvdXRbb3ArK10gPSAodjEgPDwgNCkgfCAodjIgPj4+IDIpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYyIDw8IDYpIHwgdjM7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYwICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MSAmIElOVkFMSURfQllURTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjIgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYzICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdjAgPSB0aGlzLl9kZWNvZGVDaGFyKHMuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgICB2MSA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAxKSk7XG4gICAgICAgICAgICBvdXRbb3ArK10gPSAodjAgPDwgMikgfCAodjEgPj4+IDQpO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MCAmIElOVkFMSURfQllURTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjEgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgICAgICAgICB2MiA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAyKSk7XG4gICAgICAgICAgICBvdXRbb3ArK10gPSAodjEgPDwgNCkgfCAodjIgPj4+IDIpO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MiAmIElOVkFMSURfQllURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDMpIHtcbiAgICAgICAgICAgIHYzID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSArIDMpKTtcbiAgICAgICAgICAgIG91dFtvcCsrXSA9ICh2MiA8PCA2KSB8IHYzO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MyAmIElOVkFMSURfQllURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGF2ZUJhZCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFzZTY0Q29kZXI6IGluY29ycmVjdCBjaGFyYWN0ZXJzIGZvciBkZWNvZGluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLy8gU3RhbmRhcmQgZW5jb2RpbmcgaGF2ZSB0aGUgZm9sbG93aW5nIGVuY29kZWQvZGVjb2RlZCByYW5nZXMsXG4gICAgLy8gd2hpY2ggd2UgbmVlZCB0byBjb252ZXJ0IGJldHdlZW4uXG4gICAgLy9cbiAgICAvLyBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eiAwMTIzNDU2Nzg5ICArICAgL1xuICAgIC8vIEluZGV4OiAgIDAgLSAyNSAgICAgICAgICAgICAgICAgICAgMjYgLSA1MSAgICAgICAgICAgICAgNTIgLSA2MSAgIDYyICA2M1xuICAgIC8vIEFTQ0lJOiAgNjUgLSA5MCAgICAgICAgICAgICAgICAgICAgOTcgLSAxMjIgICAgICAgICAgICAgNDggLSA1NyAgIDQzICA0N1xuICAgIC8vXG4gICAgLy8gRW5jb2RlIDYgYml0cyBpbiBiIGludG8gYSBuZXcgY2hhcmFjdGVyLlxuICAgIENvZGVyLnByb3RvdHlwZS5fZW5jb2RlQnl0ZSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIC8vIEVuY29kaW5nIHVzZXMgY29uc3RhbnQgdGltZSBvcGVyYXRpb25zIGFzIGZvbGxvd3M6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIERlZmluZSBjb21wYXJpc29uIG9mIEEgd2l0aCBCIHVzaW5nIChBIC0gQikgPj4+IDg6XG4gICAgICAgIC8vICAgICAgICAgIGlmIEEgPiBCLCB0aGVuIHJlc3VsdCBpcyBwb3NpdGl2ZSBpbnRlZ2VyXG4gICAgICAgIC8vICAgICAgICAgIGlmIEEgPD0gQiwgdGhlbiByZXN1bHQgaXMgMFxuICAgICAgICAvL1xuICAgICAgICAvLyAyLiBEZWZpbmUgc2VsZWN0aW9uIG9mIEMgb3IgMCB1c2luZyBiaXR3aXNlIEFORDogWCAmIEM6XG4gICAgICAgIC8vICAgICAgICAgIGlmIFggPT0gMCwgdGhlbiByZXN1bHQgaXMgMFxuICAgICAgICAvLyAgICAgICAgICBpZiBYICE9IDAsIHRoZW4gcmVzdWx0IGlzIENcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMy4gU3RhcnQgd2l0aCB0aGUgc21hbGxlc3QgY29tcGFyaXNvbiAoYiA+PSAwKSwgd2hpY2ggaXMgYWx3YXlzXG4gICAgICAgIC8vICAgIHRydWUsIHNvIHNldCB0aGUgcmVzdWx0IHRvIHRoZSBzdGFydGluZyBBU0NJSSB2YWx1ZSAoNjUpLlxuICAgICAgICAvL1xuICAgICAgICAvLyA0LiBDb250aW51ZSBjb21wYXJpbmcgYiB0byBoaWdoZXIgQVNDSUkgdmFsdWVzLCBhbmQgc2VsZWN0aW5nXG4gICAgICAgIC8vICAgIHplcm8gaWYgY29tcGFyaXNvbiBpc24ndCB0cnVlLCBvdGhlcndpc2Ugc2VsZWN0aW5nIGEgdmFsdWVcbiAgICAgICAgLy8gICAgdG8gYWRkIHRvIHJlc3VsdCwgd2hpY2g6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICAgIGEpIHVuZG9lcyB0aGUgcHJldmlvdXMgYWRkaXRpb25cbiAgICAgICAgLy8gICAgICAgICAgYikgcHJvdmlkZXMgbmV3IHZhbHVlIHRvIGFkZFxuICAgICAgICAvL1xuICAgICAgICB2YXIgcmVzdWx0ID0gYjtcbiAgICAgICAgLy8gYiA+PSAwXG4gICAgICAgIHJlc3VsdCArPSA2NTtcbiAgICAgICAgLy8gYiA+IDI1XG4gICAgICAgIHJlc3VsdCArPSAoKDI1IC0gYikgPj4+IDgpICYgKCgwIC0gNjUpIC0gMjYgKyA5Nyk7XG4gICAgICAgIC8vIGIgPiA1MVxuICAgICAgICByZXN1bHQgKz0gKCg1MSAtIGIpID4+PiA4KSAmICgoMjYgLSA5NykgLSA1MiArIDQ4KTtcbiAgICAgICAgLy8gYiA+IDYxXG4gICAgICAgIHJlc3VsdCArPSAoKDYxIC0gYikgPj4+IDgpICYgKCg1MiAtIDQ4KSAtIDYyICsgNDMpO1xuICAgICAgICAvLyBiID4gNjJcbiAgICAgICAgcmVzdWx0ICs9ICgoNjIgLSBiKSA+Pj4gOCkgJiAoKDYyIC0gNDMpIC0gNjMgKyA0Nyk7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHJlc3VsdCk7XG4gICAgfTtcbiAgICAvLyBEZWNvZGUgYSBjaGFyYWN0ZXIgY29kZSBpbnRvIGEgYnl0ZS5cbiAgICAvLyBNdXN0IHJldHVybiAyNTYgaWYgY2hhcmFjdGVyIGlzIG91dCBvZiBhbHBoYWJldCByYW5nZS5cbiAgICBDb2Rlci5wcm90b3R5cGUuX2RlY29kZUNoYXIgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAvLyBEZWNvZGluZyB3b3JrcyBzaW1pbGFyIHRvIGVuY29kaW5nOiB1c2luZyB0aGUgc2FtZSBjb21wYXJpc29uXG4gICAgICAgIC8vIGZ1bmN0aW9uLCBidXQgbm93IGl0IHdvcmtzIG9uIHJhbmdlczogcmVzdWx0IGlzIGFsd2F5cyBpbmNyZW1lbnRlZFxuICAgICAgICAvLyBieSB2YWx1ZSwgYnV0IHRoaXMgdmFsdWUgYmVjb21lcyB6ZXJvIGlmIHRoZSByYW5nZSBpcyBub3RcbiAgICAgICAgLy8gc2F0aXNmaWVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBEZWNvZGluZyBzdGFydHMgd2l0aCBpbnZhbGlkIHZhbHVlLCAyNTYsIHdoaWNoIGlzIHRoZW5cbiAgICAgICAgLy8gc3VidHJhY3RlZCB3aGVuIHRoZSByYW5nZSBpcyBzYXRpc2ZpZWQuIElmIG5vbmUgb2YgdGhlIHJhbmdlc1xuICAgICAgICAvLyBhcHBseSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgMjU2LCB3aGljaCBpcyB0aGVuIGNoZWNrZWQgYnlcbiAgICAgICAgLy8gdGhlIGNhbGxlciB0byB0aHJvdyBlcnJvci5cbiAgICAgICAgdmFyIHJlc3VsdCA9IElOVkFMSURfQllURTsgLy8gc3RhcnQgd2l0aCBpbnZhbGlkIGNoYXJhY3RlclxuICAgICAgICAvLyBjID09IDQzIChjID4gNDIgYW5kIGMgPCA0NClcbiAgICAgICAgcmVzdWx0ICs9ICgoKDQyIC0gYykgJiAoYyAtIDQ0KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gNDMgKyA2Mik7XG4gICAgICAgIC8vIGMgPT0gNDcgKGMgPiA0NiBhbmQgYyA8IDQ4KVxuICAgICAgICByZXN1bHQgKz0gKCgoNDYgLSBjKSAmIChjIC0gNDgpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA0NyArIDYzKTtcbiAgICAgICAgLy8gYyA+IDQ3IGFuZCBjIDwgNThcbiAgICAgICAgcmVzdWx0ICs9ICgoKDQ3IC0gYykgJiAoYyAtIDU4KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gNDggKyA1Mik7XG4gICAgICAgIC8vIGMgPiA2NCBhbmQgYyA8IDkxXG4gICAgICAgIHJlc3VsdCArPSAoKCg2NCAtIGMpICYgKGMgLSA5MSkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDY1ICsgMCk7XG4gICAgICAgIC8vIGMgPiA5NiBhbmQgYyA8IDEyM1xuICAgICAgICByZXN1bHQgKz0gKCgoOTYgLSBjKSAmIChjIC0gMTIzKSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gOTcgKyAyNik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBDb2Rlci5wcm90b3R5cGUuX2dldFBhZGRpbmdMZW5ndGggPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgcGFkZGluZ0xlbmd0aCA9IDA7XG4gICAgICAgIGlmICh0aGlzLl9wYWRkaW5nQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChzW2ldICE9PSB0aGlzLl9wYWRkaW5nQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVuZ3RoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocy5sZW5ndGggPCA0IHx8IHBhZGRpbmdMZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFzZTY0Q29kZXI6IGluY29ycmVjdCBwYWRkaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWRkaW5nTGVuZ3RoO1xuICAgIH07XG4gICAgcmV0dXJuIENvZGVyO1xufSgpKTtcbmV4cG9ydHMuQ29kZXIgPSBDb2RlcjtcbnZhciBzdGRDb2RlciA9IG5ldyBDb2RlcigpO1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIuZW5jb2RlKGRhdGEpO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5mdW5jdGlvbiBkZWNvZGUocykge1xuICAgIHJldHVybiBzdGRDb2Rlci5kZWNvZGUocyk7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbi8qKlxuICogSW1wbGVtZW50cyBVUkwtc2FmZSBCYXNlNjQgZW5jb2RpbmcuXG4gKiAoU2FtZSBhcyBCYXNlNjQsIGJ1dCAnKycgaXMgcmVwbGFjZWQgd2l0aCAnLScsIGFuZCAnLycgd2l0aCAnXycpLlxuICpcbiAqIE9wZXJhdGVzIGluIGNvbnN0YW50IHRpbWUuXG4gKi9cbnZhciBVUkxTYWZlQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVSTFNhZmVDb2RlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVUkxTYWZlQ29kZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLy8gVVJMLXNhZmUgZW5jb2RpbmcgaGF2ZSB0aGUgZm9sbG93aW5nIGVuY29kZWQvZGVjb2RlZCByYW5nZXM6XG4gICAgLy9cbiAgICAvLyBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eiAwMTIzNDU2Nzg5ICAtICAgX1xuICAgIC8vIEluZGV4OiAgIDAgLSAyNSAgICAgICAgICAgICAgICAgICAgMjYgLSA1MSAgICAgICAgICAgICAgNTIgLSA2MSAgIDYyICA2M1xuICAgIC8vIEFTQ0lJOiAgNjUgLSA5MCAgICAgICAgICAgICAgICAgICAgOTcgLSAxMjIgICAgICAgICAgICAgNDggLSA1NyAgIDQ1ICA5NVxuICAgIC8vXG4gICAgVVJMU2FmZUNvZGVyLnByb3RvdHlwZS5fZW5jb2RlQnl0ZSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBiO1xuICAgICAgICAvLyBiID49IDBcbiAgICAgICAgcmVzdWx0ICs9IDY1O1xuICAgICAgICAvLyBiID4gMjVcbiAgICAgICAgcmVzdWx0ICs9ICgoMjUgLSBiKSA+Pj4gOCkgJiAoKDAgLSA2NSkgLSAyNiArIDk3KTtcbiAgICAgICAgLy8gYiA+IDUxXG4gICAgICAgIHJlc3VsdCArPSAoKDUxIC0gYikgPj4+IDgpICYgKCgyNiAtIDk3KSAtIDUyICsgNDgpO1xuICAgICAgICAvLyBiID4gNjFcbiAgICAgICAgcmVzdWx0ICs9ICgoNjEgLSBiKSA+Pj4gOCkgJiAoKDUyIC0gNDgpIC0gNjIgKyA0NSk7XG4gICAgICAgIC8vIGIgPiA2MlxuICAgICAgICByZXN1bHQgKz0gKCg2MiAtIGIpID4+PiA4KSAmICgoNjIgLSA0NSkgLSA2MyArIDk1KTtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocmVzdWx0KTtcbiAgICB9O1xuICAgIFVSTFNhZmVDb2Rlci5wcm90b3R5cGUuX2RlY29kZUNoYXIgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gSU5WQUxJRF9CWVRFO1xuICAgICAgICAvLyBjID09IDQ1IChjID4gNDQgYW5kIGMgPCA0NilcbiAgICAgICAgcmVzdWx0ICs9ICgoKDQ0IC0gYykgJiAoYyAtIDQ2KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gNDUgKyA2Mik7XG4gICAgICAgIC8vIGMgPT0gOTUgKGMgPiA5NCBhbmQgYyA8IDk2KVxuICAgICAgICByZXN1bHQgKz0gKCgoOTQgLSBjKSAmIChjIC0gOTYpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA5NSArIDYzKTtcbiAgICAgICAgLy8gYyA+IDQ3IGFuZCBjIDwgNThcbiAgICAgICAgcmVzdWx0ICs9ICgoKDQ3IC0gYykgJiAoYyAtIDU4KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gNDggKyA1Mik7XG4gICAgICAgIC8vIGMgPiA2NCBhbmQgYyA8IDkxXG4gICAgICAgIHJlc3VsdCArPSAoKCg2NCAtIGMpICYgKGMgLSA5MSkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDY1ICsgMCk7XG4gICAgICAgIC8vIGMgPiA5NiBhbmQgYyA8IDEyM1xuICAgICAgICByZXN1bHQgKz0gKCgoOTYgLSBjKSAmIChjIC0gMTIzKSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gOTcgKyAyNik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gVVJMU2FmZUNvZGVyO1xufShDb2RlcikpO1xuZXhwb3J0cy5VUkxTYWZlQ29kZXIgPSBVUkxTYWZlQ29kZXI7XG52YXIgdXJsU2FmZUNvZGVyID0gbmV3IFVSTFNhZmVDb2RlcigpO1xuZnVuY3Rpb24gZW5jb2RlVVJMU2FmZShkYXRhKSB7XG4gICAgcmV0dXJuIHVybFNhZmVDb2Rlci5lbmNvZGUoZGF0YSk7XG59XG5leHBvcnRzLmVuY29kZVVSTFNhZmUgPSBlbmNvZGVVUkxTYWZlO1xuZnVuY3Rpb24gZGVjb2RlVVJMU2FmZShzKSB7XG4gICAgcmV0dXJuIHVybFNhZmVDb2Rlci5kZWNvZGUocyk7XG59XG5leHBvcnRzLmRlY29kZVVSTFNhZmUgPSBkZWNvZGVVUkxTYWZlO1xuZXhwb3J0cy5lbmNvZGVkTGVuZ3RoID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHJldHVybiBzdGRDb2Rlci5lbmNvZGVkTGVuZ3RoKGxlbmd0aCk7XG59O1xuZXhwb3J0cy5tYXhEZWNvZGVkTGVuZ3RoID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHJldHVybiBzdGRDb2Rlci5tYXhEZWNvZGVkTGVuZ3RoKGxlbmd0aCk7XG59O1xuZXhwb3J0cy5kZWNvZGVkTGVuZ3RoID0gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIuZGVjb2RlZExlbmd0aChzKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBIZWFkZXJzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY2xlYXIoKTtcbn07XG5cbkhlYWRlcnMucHJvdG90eXBlLkFMTE9XRURfRFVQTElDQVRFUyA9IFsnc2V0LWNvb2tpZScsICdzZXQtY29va2llMicsICd3YXJuaW5nJywgJ3d3dy1hdXRoZW50aWNhdGUnXTtcblxuSGVhZGVycy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc2VudCAgPSB7fTtcbiAgdGhpcy5fbGluZXMgPSBbXTtcbn07XG5cbkhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgbmFtZSA9IHRoaXMuX3N0cmlwKG5hbWUpO1xuICB2YWx1ZSA9IHRoaXMuX3N0cmlwKHZhbHVlKTtcblxuICB2YXIga2V5ID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIXRoaXMuX3NlbnQuaGFzT3duUHJvcGVydHkoa2V5KSB8fCB0aGlzLkFMTE9XRURfRFVQTElDQVRFUy5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgIHRoaXMuX3NlbnRba2V5XSA9IHRydWU7XG4gICAgdGhpcy5fbGluZXMucHVzaChuYW1lICsgJzogJyArIHZhbHVlICsgJ1xcclxcbicpO1xuICB9XG59O1xuXG5IZWFkZXJzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGluZXMuam9pbignJyk7XG59O1xuXG5IZWFkZXJzLnByb3RvdHlwZS5fc3RyaXAgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy50b1N0cmluZygpLnJlcGxhY2UoL14gKi8sICcnKS5yZXBsYWNlKC8gKiQvLCAnJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYWRlcnM7XG5cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTm9kZUhUVFBQYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KS5IVFRQUGFyc2VyLFxuICAgIEJ1ZmZlciAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5CdWZmZXI7XG5cbnZhciBUWVBFUyA9IHtcbiAgcmVxdWVzdDogIE5vZGVIVFRQUGFyc2VyLlJFUVVFU1QgIHx8ICdyZXF1ZXN0JyxcbiAgcmVzcG9uc2U6IE5vZGVIVFRQUGFyc2VyLlJFU1BPTlNFIHx8ICdyZXNwb25zZSdcbn07XG5cbnZhciBIdHRwUGFyc2VyID0gZnVuY3Rpb24odHlwZSkge1xuICB0aGlzLl90eXBlICAgICA9IHR5cGU7XG4gIHRoaXMuX3BhcnNlciAgID0gbmV3IE5vZGVIVFRQUGFyc2VyKFRZUEVTW3R5cGVdKTtcbiAgdGhpcy5fY29tcGxldGUgPSBmYWxzZTtcbiAgdGhpcy5oZWFkZXJzICAgPSB7fTtcblxuICB2YXIgY3VycmVudCA9IG51bGwsXG4gICAgICBzZWxmICAgID0gdGhpcztcblxuICB0aGlzLl9wYXJzZXIub25IZWFkZXJGaWVsZCA9IGZ1bmN0aW9uKGIsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgICBjdXJyZW50ID0gYi50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBzdGFydCArIGxlbmd0aCkudG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICB0aGlzLl9wYXJzZXIub25IZWFkZXJWYWx1ZSA9IGZ1bmN0aW9uKGIsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBiLnRvU3RyaW5nKCd1dGY4Jywgc3RhcnQsIHN0YXJ0ICsgbGVuZ3RoKTtcblxuICAgIGlmIChzZWxmLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoY3VycmVudCkpXG4gICAgICBzZWxmLmhlYWRlcnNbY3VycmVudF0gKz0gJywgJyArIHZhbHVlO1xuICAgIGVsc2VcbiAgICAgIHNlbGYuaGVhZGVyc1tjdXJyZW50XSA9IHZhbHVlO1xuICB9O1xuXG4gIHRoaXMuX3BhcnNlci5vbkhlYWRlcnNDb21wbGV0ZSA9IHRoaXMuX3BhcnNlcltOb2RlSFRUUFBhcnNlci5rT25IZWFkZXJzQ29tcGxldGVdID1cbiAgZnVuY3Rpb24obWFqb3JWZXJzaW9uLCBtaW5vclZlcnNpb24sIGhlYWRlcnMsIG1ldGhvZCwgcGF0aG5hbWUsIHN0YXR1c0NvZGUpIHtcbiAgICB2YXIgaW5mbyA9IGFyZ3VtZW50c1swXTtcblxuICAgIGlmICh0eXBlb2YgaW5mbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1ldGhvZCAgICAgPSBpbmZvLm1ldGhvZDtcbiAgICAgIHBhdGhuYW1lICAgPSBpbmZvLnVybDtcbiAgICAgIHN0YXR1c0NvZGUgPSBpbmZvLnN0YXR1c0NvZGU7XG4gICAgICBoZWFkZXJzICAgID0gaW5mby5oZWFkZXJzO1xuICAgIH1cblxuICAgIHNlbGYubWV0aG9kICAgICA9ICh0eXBlb2YgbWV0aG9kID09PSAnbnVtYmVyJykgPyBIdHRwUGFyc2VyLk1FVEhPRFNbbWV0aG9kXSA6IG1ldGhvZDtcbiAgICBzZWxmLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHNlbGYudXJsICAgICAgICA9IHBhdGhuYW1lO1xuXG4gICAgaWYgKCFoZWFkZXJzKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGhlYWRlcnMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbjsgaSArPSAyKSB7XG4gICAgICBrZXkgICA9IGhlYWRlcnNbaV0udG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhbHVlID0gaGVhZGVyc1tpKzFdO1xuICAgICAgaWYgKHNlbGYuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICBzZWxmLmhlYWRlcnNba2V5XSArPSAnLCAnICsgdmFsdWU7XG4gICAgICBlbHNlXG4gICAgICAgIHNlbGYuaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgc2VsZi5fY29tcGxldGUgPSB0cnVlO1xuICB9O1xufTtcblxuSHR0cFBhcnNlci5NRVRIT0RTID0ge1xuICAwOiAgJ0RFTEVURScsXG4gIDE6ICAnR0VUJyxcbiAgMjogICdIRUFEJyxcbiAgMzogICdQT1NUJyxcbiAgNDogICdQVVQnLFxuICA1OiAgJ0NPTk5FQ1QnLFxuICA2OiAgJ09QVElPTlMnLFxuICA3OiAgJ1RSQUNFJyxcbiAgODogICdDT1BZJyxcbiAgOTogICdMT0NLJyxcbiAgMTA6ICdNS0NPTCcsXG4gIDExOiAnTU9WRScsXG4gIDEyOiAnUFJPUEZJTkQnLFxuICAxMzogJ1BST1BQQVRDSCcsXG4gIDE0OiAnU0VBUkNIJyxcbiAgMTU6ICdVTkxPQ0snLFxuICAxNjogJ0JJTkQnLFxuICAxNzogJ1JFQklORCcsXG4gIDE4OiAnVU5CSU5EJyxcbiAgMTk6ICdBQ0wnLFxuICAyMDogJ1JFUE9SVCcsXG4gIDIxOiAnTUtBQ1RJVklUWScsXG4gIDIyOiAnQ0hFQ0tPVVQnLFxuICAyMzogJ01FUkdFJyxcbiAgMjQ6ICdNLVNFQVJDSCcsXG4gIDI1OiAnTk9USUZZJyxcbiAgMjY6ICdTVUJTQ1JJQkUnLFxuICAyNzogJ1VOU1VCU0NSSUJFJyxcbiAgMjg6ICdQQVRDSCcsXG4gIDI5OiAnUFVSR0UnLFxuICAzMDogJ01LQ0FMRU5EQVInLFxuICAzMTogJ0xJTksnLFxuICAzMjogJ1VOTElOSydcbn07XG5cbnZhciBWRVJTSU9OID0gcHJvY2Vzcy52ZXJzaW9uXG4gID8gcHJvY2Vzcy52ZXJzaW9uLm1hdGNoKC9bMC05XSsvZykubWFwKGZ1bmN0aW9uKG4pIHsgcmV0dXJuIHBhcnNlSW50KG4sIDEwKSB9KVxuICA6IFtdO1xuXG5pZiAoVkVSU0lPTlswXSA9PT0gMCAmJiBWRVJTSU9OWzFdID09PSAxMikge1xuICBIdHRwUGFyc2VyLk1FVEhPRFNbMTZdID0gJ1JFUE9SVCc7XG4gIEh0dHBQYXJzZXIuTUVUSE9EU1sxN10gPSAnTUtBQ1RJVklUWSc7XG4gIEh0dHBQYXJzZXIuTUVUSE9EU1sxOF0gPSAnQ0hFQ0tPVVQnO1xuICBIdHRwUGFyc2VyLk1FVEhPRFNbMTldID0gJ01FUkdFJztcbiAgSHR0cFBhcnNlci5NRVRIT0RTWzIwXSA9ICdNLVNFQVJDSCc7XG4gIEh0dHBQYXJzZXIuTUVUSE9EU1syMV0gPSAnTk9USUZZJztcbiAgSHR0cFBhcnNlci5NRVRIT0RTWzIyXSA9ICdTVUJTQ1JJQkUnO1xuICBIdHRwUGFyc2VyLk1FVEhPRFNbMjNdID0gJ1VOU1VCU0NSSUJFJztcbiAgSHR0cFBhcnNlci5NRVRIT0RTWzI0XSA9ICdQQVRDSCc7XG4gIEh0dHBQYXJzZXIuTUVUSE9EU1syNV0gPSAnUFVSR0UnO1xufVxuXG5IdHRwUGFyc2VyLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jb21wbGV0ZTtcbn07XG5cbkh0dHBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIGNvbnN1bWVkID0gdGhpcy5fcGFyc2VyLmV4ZWN1dGUoY2h1bmssIDAsIGNodW5rLmxlbmd0aCk7XG5cbiAgaWYgKHR5cGVvZiBjb25zdW1lZCAhPT0gJ251bWJlcicpIHtcbiAgICB0aGlzLmVycm9yICAgICA9IGNvbnN1bWVkO1xuICAgIHRoaXMuX2NvbXBsZXRlID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5fY29tcGxldGUpXG4gICAgdGhpcy5ib2R5ID0gKGNvbnN1bWVkIDwgY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgICA/IGNodW5rLnNsaWNlKGNvbnN1bWVkKVxuICAgICAgICAgICAgICA6IEJ1ZmZlci5hbGxvYygwKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSHR0cFBhcnNlcjtcblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBTdHJlYW0gICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNSkuU3RyZWFtLFxuICAgIHV0aWwgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKSxcbiAgICBkcml2ZXIgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNCksXG4gICAgRXZlbnRUYXJnZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSxcbiAgICBFdmVudCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBBUEkgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBkcml2ZXIudmFsaWRhdGVPcHRpb25zKG9wdGlvbnMsIFsnaGVhZGVycycsICdleHRlbnNpb25zJywgJ21heExlbmd0aCcsICdwaW5nJywgJ3Byb3h5JywgJ3RscycsICdjYSddKTtcblxuICB0aGlzLnJlYWRhYmxlID0gdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgdmFyIGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gIGlmIChoZWFkZXJzKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSB0aGlzLl9kcml2ZXIuc2V0SGVhZGVyKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICB9XG5cbiAgdmFyIGV4dGVuc2lvbnMgPSBvcHRpb25zLmV4dGVuc2lvbnM7XG4gIGlmIChleHRlbnNpb25zKSB7XG4gICAgW10uY29uY2F0KGV4dGVuc2lvbnMpLmZvckVhY2godGhpcy5fZHJpdmVyLmFkZEV4dGVuc2lvbiwgdGhpcy5fZHJpdmVyKTtcbiAgfVxuXG4gIHRoaXMuX3BpbmcgICAgICAgICAgPSBvcHRpb25zLnBpbmc7XG4gIHRoaXMuX3BpbmdJZCAgICAgICAgPSAwO1xuICB0aGlzLnJlYWR5U3RhdGUgICAgID0gQVBJLkNPTk5FQ1RJTkc7XG4gIHRoaXMuYnVmZmVyZWRBbW91bnQgPSAwO1xuICB0aGlzLnByb3RvY29sICAgICAgID0gJyc7XG4gIHRoaXMudXJsICAgICAgICAgICAgPSB0aGlzLl9kcml2ZXIudXJsO1xuICB0aGlzLnZlcnNpb24gICAgICAgID0gdGhpcy5fZHJpdmVyLnZlcnNpb247XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuX2RyaXZlci5vbignb3BlbicsICAgIGZ1bmN0aW9uKGUpIHsgc2VsZi5fb3BlbigpIH0pO1xuICB0aGlzLl9kcml2ZXIub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihlKSB7IHNlbGYuX3JlY2VpdmVNZXNzYWdlKGUuZGF0YSkgfSk7XG4gIHRoaXMuX2RyaXZlci5vbignY2xvc2UnLCAgIGZ1bmN0aW9uKGUpIHsgc2VsZi5fYmVnaW5DbG9zZShlLnJlYXNvbiwgZS5jb2RlKSB9KTtcblxuICB0aGlzLl9kcml2ZXIub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBzZWxmLl9lbWl0RXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gIH0pO1xuICB0aGlzLm9uKCdlcnJvcicsIGZ1bmN0aW9uKCkge30pO1xuXG4gIHRoaXMuX2RyaXZlci5tZXNzYWdlcy5vbignZHJhaW4nLCBmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH0pO1xuXG4gIGlmICh0aGlzLl9waW5nKVxuICAgIHRoaXMuX3BpbmdUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fcGluZ0lkICs9IDE7XG4gICAgICBzZWxmLnBpbmcoc2VsZi5fcGluZ0lkLnRvU3RyaW5nKCkpO1xuICAgIH0sIHRoaXMuX3BpbmcgKiAxMDAwKTtcblxuICB0aGlzLl9jb25maWd1cmVTdHJlYW0oKTtcblxuICBpZiAoIXRoaXMuX3Byb3h5KSB7XG4gICAgdGhpcy5fc3RyZWFtLnBpcGUodGhpcy5fZHJpdmVyLmlvKTtcbiAgICB0aGlzLl9kcml2ZXIuaW8ucGlwZSh0aGlzLl9zdHJlYW0pO1xuICB9XG59O1xudXRpbC5pbmhlcml0cyhBUEksIFN0cmVhbSk7XG5cbkFQSS5DT05ORUNUSU5HID0gMDtcbkFQSS5PUEVOICAgICAgID0gMTtcbkFQSS5DTE9TSU5HICAgID0gMjtcbkFQSS5DTE9TRUQgICAgID0gMztcblxuQVBJLkNMT1NFX1RJTUVPVVQgPSAzMDAwMDtcblxudmFyIGluc3RhbmNlID0ge1xuICB3cml0ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNlbmQoZGF0YSk7XG4gIH0sXG5cbiAgZW5kOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkgdGhpcy5zZW5kKGRhdGEpO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfSxcblxuICBwYXVzZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RyaXZlci5tZXNzYWdlcy5wYXVzZSgpO1xuICB9LFxuXG4gIHJlc3VtZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RyaXZlci5tZXNzYWdlcy5yZXN1bWUoKTtcbiAgfSxcblxuICBzZW5kOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IEFQSS5PUEVOKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIEJ1ZmZlcikpIGRhdGEgPSBTdHJpbmcoZGF0YSk7XG4gICAgcmV0dXJuIHRoaXMuX2RyaXZlci5tZXNzYWdlcy53cml0ZShkYXRhKTtcbiAgfSxcblxuICBwaW5nOiBmdW5jdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPiBBUEkuT1BFTikgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLl9kcml2ZXIucGluZyhtZXNzYWdlLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgY2xvc2U6IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIGNvZGUgPSAxMDAwO1xuICAgIGlmIChyZWFzb24gPT09IHVuZGVmaW5lZCkgcmVhc29uID0gJyc7XG5cbiAgICBpZiAoY29kZSAhPT0gMTAwMCAmJiAoY29kZSA8IDMwMDAgfHwgY29kZSA+IDQ5OTkpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2Nsb3NlJyBvbiBXZWJTb2NrZXQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBcIlRoZSBjb2RlIG11c3QgYmUgZWl0aGVyIDEwMDAsIG9yIGJldHdlZW4gMzAwMCBhbmQgNDk5OS4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIGNvZGUgKyBcIiBpcyBuZWl0aGVyLlwiKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IEFQSS5DTE9TRUQpIHRoaXMucmVhZHlTdGF0ZSA9IEFQSS5DTE9TSU5HO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fYmVnaW5DbG9zZSgnJywgMTAwNik7XG4gICAgfSwgQVBJLkNMT1NFX1RJTUVPVVQpO1xuXG4gICAgdGhpcy5fZHJpdmVyLmNsb3NlKHJlYXNvbiwgY29kZSk7XG4gIH0sXG5cbiAgX2NvbmZpZ3VyZVN0cmVhbTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5fc3RyZWFtLnNldFRpbWVvdXQoMCk7XG4gICAgdGhpcy5fc3RyZWFtLnNldE5vRGVsYXkodHJ1ZSk7XG5cbiAgICBbJ2Nsb3NlJywgJ2VuZCddLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHRoaXMuX3N0cmVhbS5vbihldmVudCwgZnVuY3Rpb24oKSB7IHNlbGYuX2ZpbmFsaXplQ2xvc2UoKSB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX3N0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgc2VsZi5fZW1pdEVycm9yKCdOZXR3b3JrIGVycm9yOiAnICsgc2VsZi51cmwgKyAnOiAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICBzZWxmLl9maW5hbGl6ZUNsb3NlKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgX29wZW46IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IEFQSS5DT05ORUNUSU5HKSByZXR1cm47XG5cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBBUEkuT1BFTjtcbiAgICB0aGlzLnByb3RvY29sID0gdGhpcy5fZHJpdmVyLnByb3RvY29sIHx8ICcnO1xuXG4gICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdvcGVuJyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdvcGVuJywgZmFsc2UsIGZhbHNlKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9LFxuXG4gIF9yZWNlaXZlTWVzc2FnZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPiBBUEkuT1BFTikgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHRoaXMucmVhZGFibGUpIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xuXG4gICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdtZXNzYWdlJywge2RhdGE6IGRhdGF9KTtcbiAgICBldmVudC5pbml0RXZlbnQoJ21lc3NhZ2UnLCBmYWxzZSwgZmFsc2UpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0sXG5cbiAgX2VtaXRFcnJvcjogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPj0gQVBJLkNMT1NJTkcpIHJldHVybjtcblxuICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnZXJyb3InLCB7bWVzc2FnZTogbWVzc2FnZX0pO1xuICAgIGV2ZW50LmluaXRFdmVudCgnZXJyb3InLCBmYWxzZSwgZmFsc2UpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0sXG5cbiAgX2JlZ2luQ2xvc2U6IGZ1bmN0aW9uKHJlYXNvbiwgY29kZSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IEFQSS5DTE9TRUQpIHJldHVybjtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBBUEkuQ0xPU0lORztcbiAgICB0aGlzLl9jbG9zZVBhcmFtcyA9IFtyZWFzb24sIGNvZGVdO1xuXG4gICAgaWYgKHRoaXMuX3N0cmVhbSkge1xuICAgICAgdGhpcy5fc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIGlmICghdGhpcy5fc3RyZWFtLnJlYWRhYmxlKSB0aGlzLl9maW5hbGl6ZUNsb3NlKCk7XG4gICAgfVxuICB9LFxuXG4gIF9maW5hbGl6ZUNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBBUEkuQ0xPU0VEKSByZXR1cm47XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gQVBJLkNMT1NFRDtcblxuICAgIGlmICh0aGlzLl9jbG9zZVRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5fY2xvc2VUaW1lcik7XG4gICAgaWYgKHRoaXMuX3BpbmdUaW1lcikgY2xlYXJJbnRlcnZhbCh0aGlzLl9waW5nVGltZXIpO1xuICAgIGlmICh0aGlzLl9zdHJlYW0pIHRoaXMuX3N0cmVhbS5lbmQoKTtcblxuICAgIGlmICh0aGlzLnJlYWRhYmxlKSB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgIHRoaXMucmVhZGFibGUgPSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgICB2YXIgcmVhc29uID0gdGhpcy5fY2xvc2VQYXJhbXMgPyB0aGlzLl9jbG9zZVBhcmFtc1swXSA6ICcnLFxuICAgICAgICBjb2RlICAgPSB0aGlzLl9jbG9zZVBhcmFtcyA/IHRoaXMuX2Nsb3NlUGFyYW1zWzFdIDogMTAwNjtcblxuICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnY2xvc2UnLCB7Y29kZTogY29kZSwgcmVhc29uOiByZWFzb259KTtcbiAgICBldmVudC5pbml0RXZlbnQoJ2Nsb3NlJywgZmFsc2UsIGZhbHNlKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG59O1xuXG5mb3IgKHZhciBtZXRob2QgaW4gaW5zdGFuY2UpIEFQSS5wcm90b3R5cGVbbWV0aG9kXSA9IGluc3RhbmNlW21ldGhvZF07XG5mb3IgKHZhciBrZXkgaW4gRXZlbnRUYXJnZXQpIEFQSS5wcm90b3R5cGVba2V5XSA9IEV2ZW50VGFyZ2V0W2tleV07XG5cbm1vZHVsZS5leHBvcnRzID0gQVBJO1xuXG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEJ1ZmZlciAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLkJ1ZmZlcixcbiAgICBjcnlwdG8gICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKSxcbiAgICB1dGlsICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKSxcbiAgICBFeHRlbnNpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSksXG4gICAgQmFzZSAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMiksXG4gICAgRnJhbWUgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpLFxuICAgIE1lc3NhZ2UgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcblxudmFyIEh5YmkgPSBmdW5jdGlvbihyZXF1ZXN0LCB1cmwsIG9wdGlvbnMpIHtcbiAgQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIHRoaXMuX2V4dGVuc2lvbnMgICAgID0gbmV3IEV4dGVuc2lvbnMoKTtcbiAgdGhpcy5fc3RhZ2UgICAgICAgICAgPSAwO1xuICB0aGlzLl9tYXNraW5nICAgICAgICA9IHRoaXMuX29wdGlvbnMubWFza2luZztcbiAgdGhpcy5fcHJvdG9jb2xzICAgICAgPSB0aGlzLl9vcHRpb25zLnByb3RvY29scyB8fCBbXTtcbiAgdGhpcy5fcmVxdWlyZU1hc2tpbmcgPSB0aGlzLl9vcHRpb25zLnJlcXVpcmVNYXNraW5nO1xuICB0aGlzLl9waW5nQ2FsbGJhY2tzICA9IHt9O1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fcHJvdG9jb2xzID09PSAnc3RyaW5nJylcbiAgICB0aGlzLl9wcm90b2NvbHMgPSB0aGlzLl9wcm90b2NvbHMuc3BsaXQoLyAqLCAqLyk7XG5cbiAgaWYgKCF0aGlzLl9yZXF1ZXN0KSByZXR1cm47XG5cbiAgdmFyIHByb3RvcyAgICA9IHRoaXMuX3JlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddLFxuICAgICAgc3VwcG9ydGVkID0gdGhpcy5fcHJvdG9jb2xzO1xuXG4gIGlmIChwcm90b3MgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgcHJvdG9zID09PSAnc3RyaW5nJykgcHJvdG9zID0gcHJvdG9zLnNwbGl0KC8gKiwgKi8pO1xuICAgIHRoaXMucHJvdG9jb2wgPSBwcm90b3MuZmlsdGVyKGZ1bmN0aW9uKHApIHsgcmV0dXJuIHN1cHBvcnRlZC5pbmRleE9mKHApID49IDAgfSlbMF07XG4gIH1cblxuICB0aGlzLnZlcnNpb24gPSAnaHliaS0nICsgSHliaS5WRVJTSU9OO1xufTtcbnV0aWwuaW5oZXJpdHMoSHliaSwgQmFzZSk7XG5cbkh5YmkuVkVSU0lPTiA9ICcxMyc7XG5cbkh5YmkubWFzayA9IGZ1bmN0aW9uKHBheWxvYWQsIG1hc2ssIG9mZnNldCkge1xuICBpZiAoIW1hc2sgfHwgbWFzay5sZW5ndGggPT09IDApIHJldHVybiBwYXlsb2FkO1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHBheWxvYWQubGVuZ3RoIC0gb2Zmc2V0OyBpIDwgbjsgaSsrKSB7XG4gICAgcGF5bG9hZFtvZmZzZXQgKyBpXSA9IHBheWxvYWRbb2Zmc2V0ICsgaV0gXiBtYXNrW2kgJSA0XTtcbiAgfVxuICByZXR1cm4gcGF5bG9hZDtcbn07XG5cbkh5YmkuZ2VuZXJhdGVBY2NlcHQgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIHNoYTEgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpO1xuICBzaGExLnVwZGF0ZShrZXkgKyBIeWJpLkdVSUQpO1xuICByZXR1cm4gc2hhMS5kaWdlc3QoJ2Jhc2U2NCcpO1xufTtcblxuSHliaS5HVUlEID0gJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMSc7XG5cbnZhciBpbnN0YW5jZSA9IHtcbiAgRklOOiAgICAweDgwLFxuICBNQVNLOiAgIDB4ODAsXG4gIFJTVjE6ICAgMHg0MCxcbiAgUlNWMjogICAweDIwLFxuICBSU1YzOiAgIDB4MTAsXG4gIE9QQ09ERTogMHgwRixcbiAgTEVOR1RIOiAweDdGLFxuXG4gIE9QQ09ERVM6IHtcbiAgICBjb250aW51YXRpb246IDAsXG4gICAgdGV4dDogICAgICAgICAxLFxuICAgIGJpbmFyeTogICAgICAgMixcbiAgICBjbG9zZTogICAgICAgIDgsXG4gICAgcGluZzogICAgICAgICA5LFxuICAgIHBvbmc6ICAgICAgICAgMTBcbiAgfSxcblxuICBPUENPREVfQ09ERVM6ICAgIFswLCAxLCAyLCA4LCA5LCAxMF0sXG4gIE1FU1NBR0VfT1BDT0RFUzogWzAsIDEsIDJdLFxuICBPUEVOSU5HX09QQ09ERVM6IFsxLCAyXSxcblxuICBFUlJPUlM6IHtcbiAgICBub3JtYWxfY2xvc3VyZTogICAgICAgMTAwMCxcbiAgICBnb2luZ19hd2F5OiAgICAgICAgICAgMTAwMSxcbiAgICBwcm90b2NvbF9lcnJvcjogICAgICAgMTAwMixcbiAgICB1bmFjY2VwdGFibGU6ICAgICAgICAgMTAwMyxcbiAgICBlbmNvZGluZ19lcnJvcjogICAgICAgMTAwNyxcbiAgICBwb2xpY3lfdmlvbGF0aW9uOiAgICAgMTAwOCxcbiAgICB0b29fbGFyZ2U6ICAgICAgICAgICAgMTAwOSxcbiAgICBleHRlbnNpb25fZXJyb3I6ICAgICAgMTAxMCxcbiAgICB1bmV4cGVjdGVkX2NvbmRpdGlvbjogMTAxMVxuICB9LFxuXG4gIEVSUk9SX0NPREVTOiAgICAgICAgWzEwMDAsIDEwMDEsIDEwMDIsIDEwMDMsIDEwMDcsIDEwMDgsIDEwMDksIDEwMTAsIDEwMTFdLFxuICBERUZBVUxUX0VSUk9SX0NPREU6IDEwMDAsXG4gIE1JTl9SRVNFUlZFRF9FUlJPUjogMzAwMCxcbiAgTUFYX1JFU0VSVkVEX0VSUk9SOiA0OTk5LFxuXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvcXVlc3Rpb25zL3FhLWZvcm1zLXV0Zi04LmVuLnBocFxuICBVVEY4X01BVENIOiAvXihbXFx4MDAtXFx4N0ZdfFtcXHhDMi1cXHhERl1bXFx4ODAtXFx4QkZdfFxceEUwW1xceEEwLVxceEJGXVtcXHg4MC1cXHhCRl18W1xceEUxLVxceEVDXFx4RUVcXHhFRl1bXFx4ODAtXFx4QkZdezJ9fFxceEVEW1xceDgwLVxceDlGXVtcXHg4MC1cXHhCRl18XFx4RjBbXFx4OTAtXFx4QkZdW1xceDgwLVxceEJGXXsyfXxbXFx4RjEtXFx4RjNdW1xceDgwLVxceEJGXXszfXxcXHhGNFtcXHg4MC1cXHg4Rl1bXFx4ODAtXFx4QkZdezJ9KSokLyxcblxuICBhZGRFeHRlbnNpb246IGZ1bmN0aW9uKGV4dGVuc2lvbikge1xuICAgIHRoaXMuX2V4dGVuc2lvbnMuYWRkKGV4dGVuc2lvbik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgdGhpcy5fcmVhZGVyLnB1dChjaHVuayk7XG4gICAgdmFyIGJ1ZmZlciA9IHRydWU7XG4gICAgd2hpbGUgKGJ1ZmZlcikge1xuICAgICAgc3dpdGNoICh0aGlzLl9zdGFnZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgYnVmZmVyID0gdGhpcy5fcmVhZGVyLnJlYWQoMSk7XG4gICAgICAgICAgaWYgKGJ1ZmZlcikgdGhpcy5fcGFyc2VPcGNvZGUoYnVmZmVyWzBdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYnVmZmVyID0gdGhpcy5fcmVhZGVyLnJlYWQoMSk7XG4gICAgICAgICAgaWYgKGJ1ZmZlcikgdGhpcy5fcGFyc2VMZW5ndGgoYnVmZmVyWzBdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgYnVmZmVyID0gdGhpcy5fcmVhZGVyLnJlYWQodGhpcy5fZnJhbWUubGVuZ3RoQnl0ZXMpO1xuICAgICAgICAgIGlmIChidWZmZXIpIHRoaXMuX3BhcnNlRXh0ZW5kZWRMZW5ndGgoYnVmZmVyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgYnVmZmVyID0gdGhpcy5fcmVhZGVyLnJlYWQoNCk7XG4gICAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5fc3RhZ2UgPSA0O1xuICAgICAgICAgICAgdGhpcy5fZnJhbWUubWFza2luZ0tleSA9IGJ1ZmZlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuX3JlYWRlci5yZWFkKHRoaXMuX2ZyYW1lLmxlbmd0aCk7XG4gICAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5fc3RhZ2UgPSAwO1xuICAgICAgICAgICAgdGhpcy5fZW1pdEZyYW1lKGJ1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnVmZmVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdGV4dDogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPiAxKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWUobWVzc2FnZSwgJ3RleHQnKTtcbiAgfSxcblxuICBiaW5hcnk6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gMSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmZyYW1lKG1lc3NhZ2UsICdiaW5hcnknKTtcbiAgfSxcblxuICBwaW5nOiBmdW5jdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPiAxKSByZXR1cm4gZmFsc2U7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJyc7XG4gICAgaWYgKGNhbGxiYWNrKSB0aGlzLl9waW5nQ2FsbGJhY2tzW21lc3NhZ2VdID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWUobWVzc2FnZSwgJ3BpbmcnKTtcbiAgfSxcblxuICBwb25nOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwnJztcbiAgICAgIHJldHVybiB0aGlzLmZyYW1lKG1lc3NhZ2UsICdwb25nJyk7XG4gIH0sXG5cbiAgY2xvc2U6IGZ1bmN0aW9uKHJlYXNvbiwgY29kZSkge1xuICAgIHJlYXNvbiA9IHJlYXNvbiB8fCAnJztcbiAgICBjb2RlICAgPSBjb2RlICAgfHwgdGhpcy5FUlJPUlMubm9ybWFsX2Nsb3N1cmU7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlIDw9IDApIHtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IDM7XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgbmV3IEJhc2UuQ2xvc2VFdmVudChjb2RlLCByZWFzb24pKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSAyO1xuICAgICAgdGhpcy5fZXh0ZW5zaW9ucy5jbG9zZShmdW5jdGlvbigpIHsgdGhpcy5mcmFtZShyZWFzb24sICdjbG9zZScsIGNvZGUpIH0sIHRoaXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgZnJhbWU6IGZ1bmN0aW9uKGJ1ZmZlciwgdHlwZSwgY29kZSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPD0gMCkgcmV0dXJuIHRoaXMuX3F1ZXVlKFtidWZmZXIsIHR5cGUsIGNvZGVdKTtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gMikgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5KSAgICBidWZmZXIgPSBCdWZmZXIuZnJvbShidWZmZXIpO1xuICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnbnVtYmVyJykgYnVmZmVyID0gYnVmZmVyLnRvU3RyaW5nKCk7XG5cbiAgICB2YXIgbWVzc2FnZSA9IG5ldyBNZXNzYWdlKCksXG4gICAgICAgIGlzVGV4dCAgPSAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpLFxuICAgICAgICBwYXlsb2FkLCBjb3B5O1xuXG4gICAgbWVzc2FnZS5yc3YxICAgPSBtZXNzYWdlLnJzdjIgPSBtZXNzYWdlLnJzdjMgPSBmYWxzZTtcbiAgICBtZXNzYWdlLm9wY29kZSA9IHRoaXMuT1BDT0RFU1t0eXBlIHx8IChpc1RleHQgPyAndGV4dCcgOiAnYmluYXJ5JyldO1xuXG4gICAgcGF5bG9hZCA9IGlzVGV4dCA/IEJ1ZmZlci5mcm9tKGJ1ZmZlciwgJ3V0ZjgnKSA6IGJ1ZmZlcjtcblxuICAgIGlmIChjb2RlKSB7XG4gICAgICBjb3B5ID0gcGF5bG9hZDtcbiAgICAgIHBheWxvYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIGNvcHkubGVuZ3RoKTtcbiAgICAgIHBheWxvYWQud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcbiAgICAgIGNvcHkuY29weShwYXlsb2FkLCAyKTtcbiAgICB9XG4gICAgbWVzc2FnZS5kYXRhID0gcGF5bG9hZDtcblxuICAgIHZhciBvbk1lc3NhZ2VSZWFkeSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIHZhciBmcmFtZSA9IG5ldyBGcmFtZSgpO1xuXG4gICAgICBmcmFtZS5maW5hbCAgID0gdHJ1ZTtcbiAgICAgIGZyYW1lLnJzdjEgICAgPSBtZXNzYWdlLnJzdjE7XG4gICAgICBmcmFtZS5yc3YyICAgID0gbWVzc2FnZS5yc3YyO1xuICAgICAgZnJhbWUucnN2MyAgICA9IG1lc3NhZ2UucnN2MztcbiAgICAgIGZyYW1lLm9wY29kZSAgPSBtZXNzYWdlLm9wY29kZTtcbiAgICAgIGZyYW1lLm1hc2tlZCAgPSAhIXRoaXMuX21hc2tpbmc7XG4gICAgICBmcmFtZS5sZW5ndGggID0gbWVzc2FnZS5kYXRhLmxlbmd0aDtcbiAgICAgIGZyYW1lLnBheWxvYWQgPSBtZXNzYWdlLmRhdGE7XG5cbiAgICAgIGlmIChmcmFtZS5tYXNrZWQpIGZyYW1lLm1hc2tpbmdLZXkgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoNCk7XG5cbiAgICAgIHRoaXMuX3NlbmRGcmFtZShmcmFtZSk7XG4gICAgfTtcblxuICAgIGlmICh0aGlzLk1FU1NBR0VfT1BDT0RFUy5pbmRleE9mKG1lc3NhZ2Uub3Bjb2RlKSA+PSAwKVxuICAgICAgdGhpcy5fZXh0ZW5zaW9ucy5wcm9jZXNzT3V0Z29pbmdNZXNzYWdlKG1lc3NhZ2UsIGZ1bmN0aW9uKGVycm9yLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChlcnJvcikgcmV0dXJuIHRoaXMuX2ZhaWwoJ2V4dGVuc2lvbl9lcnJvcicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBvbk1lc3NhZ2VSZWFkeS5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgZWxzZVxuICAgICAgb25NZXNzYWdlUmVhZHkuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIF9zZW5kRnJhbWU6IGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgdmFyIGxlbmd0aCA9IGZyYW1lLmxlbmd0aCxcbiAgICAgICAgaGVhZGVyID0gKGxlbmd0aCA8PSAxMjUpID8gMiA6IChsZW5ndGggPD0gNjU1MzUgPyA0IDogMTApLFxuICAgICAgICBvZmZzZXQgPSBoZWFkZXIgKyAoZnJhbWUubWFza2VkID8gNCA6IDApLFxuICAgICAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUob2Zmc2V0ICsgbGVuZ3RoKSxcbiAgICAgICAgbWFza2VkID0gZnJhbWUubWFza2VkID8gdGhpcy5NQVNLIDogMDtcblxuICAgIGJ1ZmZlclswXSA9IChmcmFtZS5maW5hbCA/IHRoaXMuRklOIDogMCkgfFxuICAgICAgICAgICAgICAgIChmcmFtZS5yc3YxID8gdGhpcy5SU1YxIDogMCkgfFxuICAgICAgICAgICAgICAgIChmcmFtZS5yc3YyID8gdGhpcy5SU1YyIDogMCkgfFxuICAgICAgICAgICAgICAgIChmcmFtZS5yc3YzID8gdGhpcy5SU1YzIDogMCkgfFxuICAgICAgICAgICAgICAgIGZyYW1lLm9wY29kZTtcblxuICAgIGlmIChsZW5ndGggPD0gMTI1KSB7XG4gICAgICBidWZmZXJbMV0gPSBtYXNrZWQgfCBsZW5ndGg7XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPD0gNjU1MzUpIHtcbiAgICAgIGJ1ZmZlclsxXSA9IG1hc2tlZCB8IDEyNjtcbiAgICAgIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGxlbmd0aCwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlclsxXSA9IG1hc2tlZCB8IDEyNztcbiAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKE1hdGguZmxvb3IobGVuZ3RoIC8gMHgxMDAwMDAwMDApLCAyKTtcbiAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGxlbmd0aCAlIDB4MTAwMDAwMDAwLCA2KTtcbiAgICB9XG5cbiAgICBmcmFtZS5wYXlsb2FkLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuXG4gICAgaWYgKGZyYW1lLm1hc2tlZCkge1xuICAgICAgZnJhbWUubWFza2luZ0tleS5jb3B5KGJ1ZmZlciwgaGVhZGVyKTtcbiAgICAgIEh5YmkubWFzayhidWZmZXIsIGZyYW1lLm1hc2tpbmdLZXksIG9mZnNldCk7XG4gICAgfVxuXG4gICAgdGhpcy5fd3JpdGUoYnVmZmVyKTtcbiAgfSxcblxuICBfaGFuZHNoYWtlUmVzcG9uc2U6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWNLZXkgID0gdGhpcy5fcmVxdWVzdC5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddLFxuICAgICAgICB2ZXJzaW9uID0gdGhpcy5fcmVxdWVzdC5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXZlcnNpb24nXTtcblxuICAgIGlmICh2ZXJzaW9uICE9PSBIeWJpLlZFUlNJT04pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFdlYlNvY2tldCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG5cbiAgICBpZiAodHlwZW9mIHNlY0tleSAhPT0gJ3N0cmluZycpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgaGFuZHNoYWtlIHJlcXVlc3QgaGVhZGVyOiBTZWMtV2ViU29ja2V0LUtleScpO1xuXG4gICAgdGhpcy5faGVhZGVycy5zZXQoJ1VwZ3JhZGUnLCAnd2Vic29ja2V0Jyk7XG4gICAgdGhpcy5faGVhZGVycy5zZXQoJ0Nvbm5lY3Rpb24nLCAnVXBncmFkZScpO1xuICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdTZWMtV2ViU29ja2V0LUFjY2VwdCcsIEh5YmkuZ2VuZXJhdGVBY2NlcHQoc2VjS2V5KSk7XG5cbiAgICBpZiAodGhpcy5wcm90b2NvbCkgdGhpcy5faGVhZGVycy5zZXQoJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnLCB0aGlzLnByb3RvY29sKTtcblxuICAgIHZhciBleHRlbnNpb25zID0gdGhpcy5fZXh0ZW5zaW9ucy5nZW5lcmF0ZVJlc3BvbnNlKHRoaXMuX3JlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ10pO1xuICAgIGlmIChleHRlbnNpb25zKSB0aGlzLl9oZWFkZXJzLnNldCgnU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJywgZXh0ZW5zaW9ucyk7XG5cbiAgICB2YXIgc3RhcnQgICA9ICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgICAgIGhlYWRlcnMgPSBbc3RhcnQsIHRoaXMuX2hlYWRlcnMudG9TdHJpbmcoKSwgJyddO1xuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhlYWRlcnMuam9pbignXFxyXFxuJyksICd1dGY4Jyk7XG4gIH0sXG5cbiAgX3NodXRkb3duOiBmdW5jdGlvbihjb2RlLCByZWFzb24sIGVycm9yKSB7XG4gICAgZGVsZXRlIHRoaXMuX2ZyYW1lO1xuICAgIGRlbGV0ZSB0aGlzLl9tZXNzYWdlO1xuICAgIHRoaXMuX3N0YWdlID0gNTtcblxuICAgIHZhciBzZW5kQ2xvc2VGcmFtZSA9ICh0aGlzLnJlYWR5U3RhdGUgPT09IDEpO1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IDI7XG5cbiAgICB0aGlzLl9leHRlbnNpb25zLmNsb3NlKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNlbmRDbG9zZUZyYW1lKSB0aGlzLmZyYW1lKHJlYXNvbiwgJ2Nsb3NlJywgY29kZSk7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSAzO1xuICAgICAgaWYgKGVycm9yKSB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKHJlYXNvbikpO1xuICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIG5ldyBCYXNlLkNsb3NlRXZlbnQoY29kZSwgcmVhc29uKSk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgX2ZhaWw6IGZ1bmN0aW9uKHR5cGUsIG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gMSkgcmV0dXJuO1xuICAgIHRoaXMuX3NodXRkb3duKHRoaXMuRVJST1JTW3R5cGVdLCBtZXNzYWdlLCB0cnVlKTtcbiAgfSxcblxuICBfcGFyc2VPcGNvZGU6IGZ1bmN0aW9uKG9jdGV0KSB7XG4gICAgdmFyIHJzdnMgPSBbdGhpcy5SU1YxLCB0aGlzLlJTVjIsIHRoaXMuUlNWM10ubWFwKGZ1bmN0aW9uKHJzdikge1xuICAgICAgcmV0dXJuIChvY3RldCAmIHJzdikgPT09IHJzdjtcbiAgICB9KTtcblxuICAgIHZhciBmcmFtZSA9IHRoaXMuX2ZyYW1lID0gbmV3IEZyYW1lKCk7XG5cbiAgICBmcmFtZS5maW5hbCAgPSAob2N0ZXQgJiB0aGlzLkZJTikgPT09IHRoaXMuRklOO1xuICAgIGZyYW1lLnJzdjEgICA9IHJzdnNbMF07XG4gICAgZnJhbWUucnN2MiAgID0gcnN2c1sxXTtcbiAgICBmcmFtZS5yc3YzICAgPSByc3ZzWzJdO1xuICAgIGZyYW1lLm9wY29kZSA9IChvY3RldCAmIHRoaXMuT1BDT0RFKTtcblxuICAgIHRoaXMuX3N0YWdlID0gMTtcblxuICAgIGlmICghdGhpcy5fZXh0ZW5zaW9ucy52YWxpZEZyYW1lUnN2KGZyYW1lKSlcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsKCdwcm90b2NvbF9lcnJvcicsXG4gICAgICAgICAgJ09uZSBvciBtb3JlIHJlc2VydmVkIGJpdHMgYXJlIG9uOiByZXNlcnZlZDEgPSAnICsgKGZyYW1lLnJzdjEgPyAxIDogMCkgK1xuICAgICAgICAgICcsIHJlc2VydmVkMiA9ICcgKyAoZnJhbWUucnN2MiA/IDEgOiAwKSArXG4gICAgICAgICAgJywgcmVzZXJ2ZWQzID0gJyArIChmcmFtZS5yc3YzID8gMSA6IDApKTtcblxuICAgIGlmICh0aGlzLk9QQ09ERV9DT0RFUy5pbmRleE9mKGZyYW1lLm9wY29kZSkgPCAwKVxuICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoJ3Byb3RvY29sX2Vycm9yJywgJ1VucmVjb2duaXplZCBmcmFtZSBvcGNvZGU6ICcgKyBmcmFtZS5vcGNvZGUpO1xuXG4gICAgaWYgKHRoaXMuTUVTU0FHRV9PUENPREVTLmluZGV4T2YoZnJhbWUub3Bjb2RlKSA8IDAgJiYgIWZyYW1lLmZpbmFsKVxuICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoJ3Byb3RvY29sX2Vycm9yJywgJ1JlY2VpdmVkIGZyYWdtZW50ZWQgY29udHJvbCBmcmFtZTogb3Bjb2RlID0gJyArIGZyYW1lLm9wY29kZSk7XG5cbiAgICBpZiAodGhpcy5fbWVzc2FnZSAmJiB0aGlzLk9QRU5JTkdfT1BDT0RFUy5pbmRleE9mKGZyYW1lLm9wY29kZSkgPj0gMClcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsKCdwcm90b2NvbF9lcnJvcicsICdSZWNlaXZlZCBuZXcgZGF0YSBmcmFtZSBidXQgcHJldmlvdXMgY29udGludW91cyBmcmFtZSBpcyB1bmZpbmlzaGVkJyk7XG4gIH0sXG5cbiAgX3BhcnNlTGVuZ3RoOiBmdW5jdGlvbihvY3RldCkge1xuICAgIHZhciBmcmFtZSA9IHRoaXMuX2ZyYW1lO1xuICAgIGZyYW1lLm1hc2tlZCA9IChvY3RldCAmIHRoaXMuTUFTSykgPT09IHRoaXMuTUFTSztcbiAgICBmcmFtZS5sZW5ndGggPSAob2N0ZXQgJiB0aGlzLkxFTkdUSCk7XG5cbiAgICBpZiAoZnJhbWUubGVuZ3RoID49IDAgJiYgZnJhbWUubGVuZ3RoIDw9IDEyNSkge1xuICAgICAgdGhpcy5fc3RhZ2UgPSBmcmFtZS5tYXNrZWQgPyAzIDogNDtcbiAgICAgIGlmICghdGhpcy5fY2hlY2tGcmFtZUxlbmd0aCgpKSByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0YWdlID0gMjtcbiAgICAgIGZyYW1lLmxlbmd0aEJ5dGVzID0gKGZyYW1lLmxlbmd0aCA9PT0gMTI2ID8gMiA6IDgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZXF1aXJlTWFza2luZyAmJiAhZnJhbWUubWFza2VkKVxuICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoJ3VuYWNjZXB0YWJsZScsICdSZWNlaXZlZCB1bm1hc2tlZCBmcmFtZSBidXQgbWFza2luZyBpcyByZXF1aXJlZCcpO1xuICB9LFxuXG4gIF9wYXJzZUV4dGVuZGVkTGVuZ3RoOiBmdW5jdGlvbihidWZmZXIpIHtcbiAgICB2YXIgZnJhbWUgPSB0aGlzLl9mcmFtZTtcbiAgICBmcmFtZS5sZW5ndGggPSB0aGlzLl9yZWFkVUludChidWZmZXIpO1xuXG4gICAgdGhpcy5fc3RhZ2UgPSBmcmFtZS5tYXNrZWQgPyAzIDogNDtcblxuICAgIGlmICh0aGlzLk1FU1NBR0VfT1BDT0RFUy5pbmRleE9mKGZyYW1lLm9wY29kZSkgPCAwICYmIGZyYW1lLmxlbmd0aCA+IDEyNSlcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsKCdwcm90b2NvbF9lcnJvcicsICdSZWNlaXZlZCBjb250cm9sIGZyYW1lIGhhdmluZyB0b28gbG9uZyBwYXlsb2FkOiAnICsgZnJhbWUubGVuZ3RoKTtcblxuICAgIGlmICghdGhpcy5fY2hlY2tGcmFtZUxlbmd0aCgpKSByZXR1cm47XG4gIH0sXG5cbiAgX2NoZWNrRnJhbWVMZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9tZXNzYWdlID8gdGhpcy5fbWVzc2FnZS5sZW5ndGggOiAwO1xuXG4gICAgaWYgKGxlbmd0aCArIHRoaXMuX2ZyYW1lLmxlbmd0aCA+IHRoaXMuX21heExlbmd0aCkge1xuICAgICAgdGhpcy5fZmFpbCgndG9vX2xhcmdlJywgJ1dlYlNvY2tldCBmcmFtZSBsZW5ndGggdG9vIGxhcmdlJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBfZW1pdEZyYW1lOiBmdW5jdGlvbihidWZmZXIpIHtcbiAgICB2YXIgZnJhbWUgICA9IHRoaXMuX2ZyYW1lLFxuICAgICAgICBwYXlsb2FkID0gZnJhbWUucGF5bG9hZCA9IEh5YmkubWFzayhidWZmZXIsIGZyYW1lLm1hc2tpbmdLZXkpLFxuICAgICAgICBvcGNvZGUgID0gZnJhbWUub3Bjb2RlLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBjb2RlLCByZWFzb24sXG4gICAgICAgIGNhbGxiYWNrcywgY2FsbGJhY2s7XG5cbiAgICBkZWxldGUgdGhpcy5fZnJhbWU7XG5cbiAgICBpZiAob3Bjb2RlID09PSB0aGlzLk9QQ09ERVMuY29udGludWF0aW9uKSB7XG4gICAgICBpZiAoIXRoaXMuX21lc3NhZ2UpIHJldHVybiB0aGlzLl9mYWlsKCdwcm90b2NvbF9lcnJvcicsICdSZWNlaXZlZCB1bmV4cGVjdGVkIGNvbnRpbnVhdGlvbiBmcmFtZScpO1xuICAgICAgdGhpcy5fbWVzc2FnZS5wdXNoRnJhbWUoZnJhbWUpO1xuICAgIH1cblxuICAgIGlmIChvcGNvZGUgPT09IHRoaXMuT1BDT0RFUy50ZXh0IHx8IG9wY29kZSA9PT0gdGhpcy5PUENPREVTLmJpbmFyeSkge1xuICAgICAgdGhpcy5fbWVzc2FnZSA9IG5ldyBNZXNzYWdlKCk7XG4gICAgICB0aGlzLl9tZXNzYWdlLnB1c2hGcmFtZShmcmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGZyYW1lLmZpbmFsICYmIHRoaXMuTUVTU0FHRV9PUENPREVTLmluZGV4T2Yob3Bjb2RlKSA+PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuX2VtaXRNZXNzYWdlKHRoaXMuX21lc3NhZ2UpO1xuXG4gICAgaWYgKG9wY29kZSA9PT0gdGhpcy5PUENPREVTLmNsb3NlKSB7XG4gICAgICBjb2RlICAgPSAocGF5bG9hZC5sZW5ndGggPj0gMikgPyBwYXlsb2FkLnJlYWRVSW50MTZCRSgwKSA6IG51bGw7XG4gICAgICByZWFzb24gPSAocGF5bG9hZC5sZW5ndGggPiAyKSA/IHRoaXMuX2VuY29kZShwYXlsb2FkLnNsaWNlKDIpKSA6IG51bGw7XG5cbiAgICAgIGlmICghKHBheWxvYWQubGVuZ3RoID09PSAwKSAmJlxuICAgICAgICAgICEoY29kZSAhPT0gbnVsbCAmJiBjb2RlID49IHRoaXMuTUlOX1JFU0VSVkVEX0VSUk9SICYmIGNvZGUgPD0gdGhpcy5NQVhfUkVTRVJWRURfRVJST1IpICYmXG4gICAgICAgICAgdGhpcy5FUlJPUl9DT0RFUy5pbmRleE9mKGNvZGUpIDwgMClcbiAgICAgICAgY29kZSA9IHRoaXMuRVJST1JTLnByb3RvY29sX2Vycm9yO1xuXG4gICAgICBpZiAocGF5bG9hZC5sZW5ndGggPiAxMjUgfHwgKHBheWxvYWQubGVuZ3RoID4gMiAmJiAhcmVhc29uKSlcbiAgICAgICAgY29kZSA9IHRoaXMuRVJST1JTLnByb3RvY29sX2Vycm9yO1xuXG4gICAgICB0aGlzLl9zaHV0ZG93bihjb2RlIHx8IHRoaXMuREVGQVVMVF9FUlJPUl9DT0RFLCByZWFzb24gfHwgJycpO1xuICAgIH1cblxuICAgIGlmIChvcGNvZGUgPT09IHRoaXMuT1BDT0RFUy5waW5nKSB7XG4gICAgICB0aGlzLmZyYW1lKHBheWxvYWQsICdwb25nJyk7XG4gICAgICB0aGlzLmVtaXQoJ3BpbmcnLCBuZXcgQmFzZS5QaW5nRXZlbnQocGF5bG9hZC50b1N0cmluZygpKSlcbiAgICB9XG5cbiAgICBpZiAob3Bjb2RlID09PSB0aGlzLk9QQ09ERVMucG9uZykge1xuICAgICAgY2FsbGJhY2tzID0gdGhpcy5fcGluZ0NhbGxiYWNrcztcbiAgICAgIG1lc3NhZ2UgICA9IHRoaXMuX2VuY29kZShwYXlsb2FkKTtcbiAgICAgIGNhbGxiYWNrICA9IGNhbGxiYWNrc1ttZXNzYWdlXTtcblxuICAgICAgZGVsZXRlIGNhbGxiYWNrc1ttZXNzYWdlXTtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKVxuXG4gICAgICB0aGlzLmVtaXQoJ3BvbmcnLCBuZXcgQmFzZS5Qb25nRXZlbnQocGF5bG9hZC50b1N0cmluZygpKSlcbiAgICB9XG4gIH0sXG5cbiAgX2VtaXRNZXNzYWdlOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSB0aGlzLl9tZXNzYWdlO1xuICAgIG1lc3NhZ2UucmVhZCgpO1xuXG4gICAgZGVsZXRlIHRoaXMuX21lc3NhZ2U7XG5cbiAgICB0aGlzLl9leHRlbnNpb25zLnByb2Nlc3NJbmNvbWluZ01lc3NhZ2UobWVzc2FnZSwgZnVuY3Rpb24oZXJyb3IsIG1lc3NhZ2UpIHtcbiAgICAgIGlmIChlcnJvcikgcmV0dXJuIHRoaXMuX2ZhaWwoJ2V4dGVuc2lvbl9lcnJvcicsIGVycm9yLm1lc3NhZ2UpO1xuXG4gICAgICB2YXIgcGF5bG9hZCA9IG1lc3NhZ2UuZGF0YTtcbiAgICAgIGlmIChtZXNzYWdlLm9wY29kZSA9PT0gdGhpcy5PUENPREVTLnRleHQpIHBheWxvYWQgPSB0aGlzLl9lbmNvZGUocGF5bG9hZCk7XG5cbiAgICAgIGlmIChwYXlsb2FkID09PSBudWxsKVxuICAgICAgICByZXR1cm4gdGhpcy5fZmFpbCgnZW5jb2RpbmdfZXJyb3InLCAnQ291bGQgbm90IGRlY29kZSBhIHRleHQgZnJhbWUgYXMgVVRGLTgnKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbmV3IEJhc2UuTWVzc2FnZUV2ZW50KHBheWxvYWQpKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBfZW5jb2RlOiBmdW5jdGlvbihidWZmZXIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHN0cmluZyA9IGJ1ZmZlci50b1N0cmluZygnYmluYXJ5JywgMCwgYnVmZmVyLmxlbmd0aCk7XG4gICAgICBpZiAoIXRoaXMuVVRGOF9NQVRDSC50ZXN0KHN0cmluZykpIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygndXRmOCcsIDAsIGJ1ZmZlci5sZW5ndGgpO1xuICB9LFxuXG4gIF9yZWFkVUludDogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDIpIHJldHVybiBidWZmZXIucmVhZFVJbnQxNkJFKDApO1xuXG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkVUludDMyQkUoMCkgKiAweDEwMDAwMDAwMCArXG4gICAgICAgICAgIGJ1ZmZlci5yZWFkVUludDMyQkUoNCk7XG4gIH1cbn07XG5cbmZvciAodmFyIGtleSBpbiBpbnN0YW5jZSlcbiAgSHliaS5wcm90b3R5cGVba2V5XSA9IGluc3RhbmNlW2tleV07XG5cbm1vZHVsZS5leHBvcnRzID0gSHliaTtcblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBSaW5nQnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyU2l6ZSkge1xuICB0aGlzLl9idWZmZXJTaXplID0gYnVmZmVyU2l6ZTtcbiAgdGhpcy5jbGVhcigpO1xufTtcblxuUmluZ0J1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fYnVmZmVyICAgICA9IG5ldyBBcnJheSh0aGlzLl9idWZmZXJTaXplKTtcbiAgdGhpcy5fcmluZ09mZnNldCA9IDA7XG4gIHRoaXMuX3JpbmdTaXplICAgPSB0aGlzLl9idWZmZXJTaXplO1xuICB0aGlzLl9oZWFkICAgICAgID0gMDtcbiAgdGhpcy5fdGFpbCAgICAgICA9IDA7XG4gIHRoaXMubGVuZ3RoICAgICAgPSAwO1xufTtcblxuUmluZ0J1ZmZlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBleHBhbmRCdWZmZXIgPSBmYWxzZSxcbiAgICAgIGV4cGFuZFJpbmcgICA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLl9yaW5nU2l6ZSA8IHRoaXMuX2J1ZmZlclNpemUpIHtcbiAgICBleHBhbmRCdWZmZXIgPSAodGhpcy5fdGFpbCA9PT0gMCk7XG4gIH0gZWxzZSBpZiAodGhpcy5fcmluZ09mZnNldCA9PT0gdGhpcy5fcmluZ1NpemUpIHtcbiAgICBleHBhbmRCdWZmZXIgPSB0cnVlO1xuICAgIGV4cGFuZFJpbmcgICA9ICh0aGlzLl90YWlsID09PSAwKTtcbiAgfVxuXG4gIGlmIChleHBhbmRCdWZmZXIpIHtcbiAgICB0aGlzLl90YWlsICAgICAgID0gdGhpcy5fYnVmZmVyU2l6ZTtcbiAgICB0aGlzLl9idWZmZXIgICAgID0gdGhpcy5fYnVmZmVyLmNvbmNhdChuZXcgQXJyYXkodGhpcy5fYnVmZmVyU2l6ZSkpO1xuICAgIHRoaXMuX2J1ZmZlclNpemUgPSB0aGlzLl9idWZmZXIubGVuZ3RoO1xuXG4gICAgaWYgKGV4cGFuZFJpbmcpXG4gICAgICB0aGlzLl9yaW5nU2l6ZSA9IHRoaXMuX2J1ZmZlclNpemU7XG4gIH1cblxuICB0aGlzLl9idWZmZXJbdGhpcy5fdGFpbF0gPSB2YWx1ZTtcbiAgdGhpcy5sZW5ndGggKz0gMTtcbiAgaWYgKHRoaXMuX3RhaWwgPCB0aGlzLl9yaW5nU2l6ZSkgdGhpcy5fcmluZ09mZnNldCArPSAxO1xuICB0aGlzLl90YWlsID0gKHRoaXMuX3RhaWwgKyAxKSAlIHRoaXMuX2J1ZmZlclNpemU7XG59O1xuXG5SaW5nQnVmZmVyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHZvaWQgMDtcbiAgcmV0dXJuIHRoaXMuX2J1ZmZlclt0aGlzLl9oZWFkXTtcbn07XG5cblJpbmdCdWZmZXIucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHZvaWQgMDtcblxuICB2YXIgdmFsdWUgPSB0aGlzLl9idWZmZXJbdGhpcy5faGVhZF07XG4gIHRoaXMuX2J1ZmZlclt0aGlzLl9oZWFkXSA9IHZvaWQgMDtcbiAgdGhpcy5sZW5ndGggLT0gMTtcbiAgdGhpcy5fcmluZ09mZnNldCAtPSAxO1xuXG4gIGlmICh0aGlzLl9yaW5nT2Zmc2V0ID09PSAwICYmIHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuX2hlYWQgICAgICAgPSB0aGlzLl9yaW5nU2l6ZTtcbiAgICB0aGlzLl9yaW5nT2Zmc2V0ID0gdGhpcy5sZW5ndGg7XG4gICAgdGhpcy5fcmluZ1NpemUgICA9IHRoaXMuX2J1ZmZlclNpemU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5faGVhZCA9ICh0aGlzLl9oZWFkICsgMSkgJSB0aGlzLl9yaW5nU2l6ZTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJpbmdCdWZmZXI7XG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgUmluZ0J1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgUGxlZGdlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NvbXBsZXRlICA9IGZhbHNlO1xuICB0aGlzLl9jYWxsYmFja3MgPSBuZXcgUmluZ0J1ZmZlcihQbGVkZ2UuUVVFVUVfU0laRSk7XG59O1xuXG5QbGVkZ2UuUVVFVUVfU0laRSA9IDQ7XG5cblBsZWRnZS5hbGwgPSBmdW5jdGlvbihsaXN0KSB7XG4gIHZhciBwbGVkZ2UgID0gbmV3IFBsZWRnZSgpLFxuICAgICAgcGVuZGluZyA9IGxpc3QubGVuZ3RoLFxuICAgICAgbiAgICAgICA9IHBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmcgPT09IDApIHBsZWRnZS5kb25lKCk7XG5cbiAgd2hpbGUgKG4tLSkgbGlzdFtuXS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIHBlbmRpbmcgLT0gMTtcbiAgICBpZiAocGVuZGluZyA9PT0gMCkgcGxlZGdlLmRvbmUoKTtcbiAgfSk7XG4gIHJldHVybiBwbGVkZ2U7XG59O1xuXG5QbGVkZ2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICBpZiAodGhpcy5fY29tcGxldGUpIGNhbGxiYWNrKCk7XG4gIGVsc2UgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xufTtcblxuUGxlZGdlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NvbXBsZXRlID0gdHJ1ZTtcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcywgY2FsbGJhY2s7XG4gIHdoaWxlIChjYWxsYmFjayA9IGNhbGxiYWNrcy5zaGlmdCgpKSBjYWxsYmFjaygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbGVkZ2U7XG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5CdWZmZXIsXG4gICAgQmFzZSAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKSxcbiAgICB1dGlsICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgRHJhZnQ3NSA9IGZ1bmN0aW9uKHJlcXVlc3QsIHVybCwgb3B0aW9ucykge1xuICBCYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRoaXMuX3N0YWdlICA9IDA7XG4gIHRoaXMudmVyc2lvbiA9ICdoaXhpZS03NSc7XG5cbiAgdGhpcy5faGVhZGVycy5zZXQoJ1VwZ3JhZGUnLCAnV2ViU29ja2V0Jyk7XG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdDb25uZWN0aW9uJywgJ1VwZ3JhZGUnKTtcbiAgdGhpcy5faGVhZGVycy5zZXQoJ1dlYlNvY2tldC1PcmlnaW4nLCB0aGlzLl9yZXF1ZXN0LmhlYWRlcnMub3JpZ2luKTtcbiAgdGhpcy5faGVhZGVycy5zZXQoJ1dlYlNvY2tldC1Mb2NhdGlvbicsIHRoaXMudXJsKTtcbn07XG51dGlsLmluaGVyaXRzKERyYWZ0NzUsIEJhc2UpO1xuXG52YXIgaW5zdGFuY2UgPSB7XG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSAzKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gMztcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgbmV3IEJhc2UuQ2xvc2VFdmVudChudWxsLCBudWxsKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IDEpIHJldHVybjtcblxuICAgIHRoaXMuX3JlYWRlci5wdXQoY2h1bmspO1xuXG4gICAgdGhpcy5fcmVhZGVyLmVhY2hCeXRlKGZ1bmN0aW9uKG9jdGV0KSB7XG4gICAgICB2YXIgbWVzc2FnZTtcblxuICAgICAgc3dpdGNoICh0aGlzLl9zdGFnZSkge1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgIHRoaXMuX2JvZHkucHVzaChvY3RldCk7XG4gICAgICAgICAgdGhpcy5fc2VuZEhhbmRzaGFrZUJvZHkoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgdGhpcy5fcGFyc2VMZWFkaW5nQnl0ZShvY3RldCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IChvY3RldCAmIDB4N0YpICsgMTI4ICogdGhpcy5fbGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX2Nsb3NpbmcgJiYgdGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICgob2N0ZXQgJiAweDgwKSAhPT0gMHg4MCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICB0aGlzLl9zdGFnZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2tpcHBlZCA9IDA7XG4gICAgICAgICAgICAgIHRoaXMuX3N0YWdlICAgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaWYgKG9jdGV0ID09PSAweEZGKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFnZSA9IDA7XG4gICAgICAgICAgICBtZXNzYWdlID0gQnVmZmVyLmZyb20odGhpcy5fYnVmZmVyKS50b1N0cmluZygndXRmOCcsIDAsIHRoaXMuX2J1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbmV3IEJhc2UuTWVzc2FnZUV2ZW50KG1lc3NhZ2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NraXBwZWQgKz0gMTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3NraXBwZWQgPT09IHRoaXMuX2xlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFnZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9idWZmZXIucHVzaChvY3RldCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9idWZmZXIubGVuZ3RoID4gdGhpcy5fbWF4TGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBmcmFtZTogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gMCkgcmV0dXJuIHRoaXMuX3F1ZXVlKFtidWZmZXJdKTtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiBidWZmZXIgIT09ICdzdHJpbmcnKSBidWZmZXIgPSBidWZmZXIudG9TdHJpbmcoKTtcblxuICAgIHZhciBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChidWZmZXIpLFxuICAgICAgICBmcmFtZSAgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoICsgMik7XG5cbiAgICBmcmFtZVswXSA9IDB4MDA7XG4gICAgZnJhbWUud3JpdGUoYnVmZmVyLCAxKTtcbiAgICBmcmFtZVtmcmFtZS5sZW5ndGggLSAxXSA9IDB4RkY7XG5cbiAgICB0aGlzLl93cml0ZShmcmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgX2hhbmRzaGFrZVJlc3BvbnNlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnQgICA9ICdIVFRQLzEuMSAxMDEgV2ViIFNvY2tldCBQcm90b2NvbCBIYW5kc2hha2UnLFxuICAgICAgICBoZWFkZXJzID0gW3N0YXJ0LCB0aGlzLl9oZWFkZXJzLnRvU3RyaW5nKCksICcnXTtcblxuICAgIHJldHVybiBCdWZmZXIuZnJvbShoZWFkZXJzLmpvaW4oJ1xcclxcbicpLCAndXRmOCcpO1xuICB9LFxuXG4gIF9wYXJzZUxlYWRpbmdCeXRlOiBmdW5jdGlvbihvY3RldCkge1xuICAgIGlmICgob2N0ZXQgJiAweDgwKSA9PT0gMHg4MCkge1xuICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX3N0YWdlICA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9sZW5ndGg7XG4gICAgICBkZWxldGUgdGhpcy5fc2tpcHBlZDtcbiAgICAgIHRoaXMuX2J1ZmZlciA9IFtdO1xuICAgICAgdGhpcy5fc3RhZ2UgID0gMjtcbiAgICB9XG4gIH1cbn07XG5cbmZvciAodmFyIGtleSBpbiBpbnN0YW5jZSlcbiAgRHJhZnQ3NS5wcm90b3R5cGVba2V5XSA9IGluc3RhbmNlW2tleV07XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhZnQ3NTtcblxuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBFdmVudFRhcmdldCA9IHtcbiAgb25vcGVuOiAgICAgbnVsbCxcbiAgb25tZXNzYWdlOiAgbnVsbCxcbiAgb25lcnJvcjogICAgbnVsbCxcbiAgb25jbG9zZTogICAgbnVsbCxcblxuICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gICAgdGhpcy5vbihldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgfSxcblxuICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuICAgIGV2ZW50LmV2ZW50UGhhc2UgPSBFdmVudC5BVF9UQVJHRVQ7XG5cbiAgICBpZiAodGhpc1snb24nICsgZXZlbnQudHlwZV0pXG4gICAgICB0aGlzWydvbicgKyBldmVudC50eXBlXShldmVudCk7XG5cbiAgICB0aGlzLmVtaXQoZXZlbnQudHlwZSwgZXZlbnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0O1xuXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIENvcHlyaWdodCAoQykgMjAxNiBEbWl0cnkgQ2hlc3RueWtoXG4vLyBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBmb3IgZGV0YWlscy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUGFja2FnZSB1dGY4IGltcGxlbWVudHMgVVRGLTggZW5jb2RpbmcgYW5kIGRlY29kaW5nLlxuICovXG52YXIgSU5WQUxJRF9VVEYxNiA9IFwidXRmODogaW52YWxpZCBzdHJpbmdcIjtcbnZhciBJTlZBTElEX1VURjggPSBcInV0Zjg6IGludmFsaWQgc291cmNlIGVuY29kaW5nXCI7XG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHN0cmluZyBpbnRvIFVURi04IGJ5dGUgYXJyYXkuXG4gKiBUaHJvd3MgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaGFzIGludmFsaWQgVVRGLTE2IGVuY29kaW5nLlxuICovXG5mdW5jdGlvbiBlbmNvZGUocykge1xuICAgIC8vIENhbGN1bGF0ZSByZXN1bHQgbGVuZ3RoIGFuZCBhbGxvY2F0ZSBvdXRwdXQgYXJyYXkuXG4gICAgLy8gZW5jb2RlZExlbmd0aCgpIGFsc28gdmFsaWRhdGVzIHN0cmluZyBhbmQgdGhyb3dzIGVycm9ycyxcbiAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHJlcGVhdCB2YWxpZGF0aW9uIGhlcmUuXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGVuY29kZWRMZW5ndGgocykpO1xuICAgIHZhciBwb3MgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweGMwIHwgYyA+PiA2O1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHhkODAwKSB7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHhlMCB8IGMgPj4gMTI7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHg4MCB8IChjID4+IDYpICYgMHgzZjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgYyAmIDB4M2Y7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpKys7IC8vIGdldCBvbmUgbW9yZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGMgPSAoYyAmIDB4M2ZmKSA8PCAxMDtcbiAgICAgICAgICAgIGMgfD0gcy5jaGFyQ29kZUF0KGkpICYgMHgzZmY7XG4gICAgICAgICAgICBjICs9IDB4MTAwMDA7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHhmMCB8IGMgPj4gMTg7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHg4MCB8IChjID4+IDEyKSAmIDB4M2Y7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHg4MCB8IChjID4+IDYpICYgMHgzZjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgYyAmIDB4M2Y7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQgdG8gZW5jb2RlIHRoZSBnaXZlbiBzdHJpbmcgaW50byBVVEYtOC5cbiAqIFRocm93cyBpZiB0aGUgc291cmNlIHN0cmluZyBoYXMgaW52YWxpZCBVVEYtMTYgZW5jb2RpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZWRMZW5ndGgocykge1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweGQ4MDApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEYxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7IC8vIFwiZWF0XCIgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHJlc3VsdCArPSA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmVuY29kZWRMZW5ndGggPSBlbmNvZGVkTGVuZ3RoO1xuLyoqXG4gKiBEZWNvZGVzIHRoZSBnaXZlbiBieXRlIGFycmF5IGZyb20gVVRGLTggaW50byBhIHN0cmluZy5cbiAqIFRocm93cyBpZiBlbmNvZGluZyBpcyBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiBkZWNvZGUoYXJyKSB7XG4gICAgdmFyIGNoYXJzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGIgPSBhcnJbaV07XG4gICAgICAgIGlmIChiICYgMHg4MCkge1xuICAgICAgICAgICAgdmFyIG1pbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChiIDwgMHhlMCkge1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgMSBtb3JlIGJ5dGUuXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG4xID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgaWYgKChuMSAmIDB4YzApICE9PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiID0gKGIgJiAweDFmKSA8PCA2IHwgKG4xICYgMHgzZik7XG4gICAgICAgICAgICAgICAgbWluID0gMHg4MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPCAweGYwKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCAyIG1vcmUgYnl0ZXMuXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYXJyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuMSA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIHZhciBuMiA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIGlmICgobjEgJiAweGMwKSAhPT0gMHg4MCB8fCAobjIgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiA9IChiICYgMHgwZikgPDwgMTIgfCAobjEgJiAweDNmKSA8PCA2IHwgKG4yICYgMHgzZik7XG4gICAgICAgICAgICAgICAgbWluID0gMHg4MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiIDwgMHhmOCkge1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgMyBtb3JlIGJ5dGVzLlxuICAgICAgICAgICAgICAgIGlmIChpID49IGFyci5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbjEgPSBhcnJbKytpXTtcbiAgICAgICAgICAgICAgICB2YXIgbjIgPSBhcnJbKytpXTtcbiAgICAgICAgICAgICAgICB2YXIgbjMgPSBhcnJbKytpXTtcbiAgICAgICAgICAgICAgICBpZiAoKG4xICYgMHhjMCkgIT09IDB4ODAgfHwgKG4yICYgMHhjMCkgIT09IDB4ODAgfHwgKG4zICYgMHhjMCkgIT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIgPSAoYiAmIDB4MGYpIDw8IDE4IHwgKG4xICYgMHgzZikgPDwgMTIgfCAobjIgJiAweDNmKSA8PCA2IHwgKG4zICYgMHgzZik7XG4gICAgICAgICAgICAgICAgbWluID0gMHgxMDAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIgPCBtaW4gfHwgKGIgPj0gMHhkODAwICYmIGIgPD0gMHhkZmZmKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIgPj0gMHgxMDAwMCkge1xuICAgICAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICAgICAgICAgIGlmIChiID4gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgICAgICBjaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwIHwgKGIgPj4gMTApKSk7XG4gICAgICAgICAgICAgICAgYiA9IDB4ZGMwMCB8IChiICYgMHgzZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiKSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKFwiXCIpO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5cblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEFQSSByZWZlcmVuY2VzOlxuLy9cbi8vICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCNuZXR3b3JrXG4vLyAqIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jaW50ZXJmYWNlLWV2ZW50dGFyZ2V0XG4vLyAqIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jaW50ZXJmYWNlLWV2ZW50XG5cblxuXG52YXIgdXRpbCAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKSxcbiAgICBkcml2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpLFxuICAgIEFQSSAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgV2ViU29ja2V0ID0gZnVuY3Rpb24ocmVxdWVzdCwgc29ja2V0LCBib2R5LCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5fc3RyZWFtID0gc29ja2V0O1xuICB0aGlzLl9kcml2ZXIgPSBkcml2ZXIuaHR0cChyZXF1ZXN0LCB7bWF4TGVuZ3RoOiBvcHRpb25zLm1heExlbmd0aCwgcHJvdG9jb2xzOiBwcm90b2NvbHN9KTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICghdGhpcy5fc3RyZWFtIHx8ICF0aGlzLl9zdHJlYW0ud3JpdGFibGUpIHJldHVybjtcbiAgaWYgKCF0aGlzLl9zdHJlYW0ucmVhZGFibGUpIHJldHVybiB0aGlzLl9zdHJlYW0uZW5kKCk7XG5cbiAgdmFyIGNhdGNodXAgPSBmdW5jdGlvbigpIHsgc2VsZi5fc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgY2F0Y2h1cCkgfTtcbiAgdGhpcy5fc3RyZWFtLm9uKCdkYXRhJywgY2F0Y2h1cCk7XG5cbiAgQVBJLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9kcml2ZXIuc3RhcnQoKTtcbiAgICBzZWxmLl9kcml2ZXIuaW8ud3JpdGUoYm9keSk7XG4gIH0pO1xufTtcbnV0aWwuaW5oZXJpdHMoV2ViU29ja2V0LCBBUEkpO1xuXG5XZWJTb2NrZXQuaXNXZWJTb2NrZXQgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIHJldHVybiBkcml2ZXIuaXNXZWJTb2NrZXQocmVxdWVzdCk7XG59O1xuXG5XZWJTb2NrZXQudmFsaWRhdGVPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucywgdmFsaWRLZXlzKSB7XG4gIGRyaXZlci52YWxpZGF0ZU9wdGlvbnMob3B0aW9ucywgdmFsaWRLZXlzKTtcbn07XG5cbldlYlNvY2tldC5XZWJTb2NrZXQgICA9IFdlYlNvY2tldDtcbldlYlNvY2tldC5DbGllbnQgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuV2ViU29ja2V0LkV2ZW50U291cmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cbm1vZHVsZS5leHBvcnRzICAgICAgICA9IFdlYlNvY2tldDtcblxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogV3JhcHBlciBmb3IgYnVpbHQtaW4gaHR0cC5qcyB0byBlbXVsYXRlIHRoZSBicm93c2VyIFhNTEh0dHBSZXF1ZXN0IG9iamVjdC5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHdpdGggSlMgZGVzaWduZWQgZm9yIGJyb3dzZXJzIHRvIGltcHJvdmUgcmV1c2Ugb2YgY29kZSBhbmRcbiAqIGFsbG93IHRoZSB1c2Ugb2YgZXhpc3RpbmcgbGlicmFyaWVzLlxuICpcbiAqIFVzYWdlOiBpbmNsdWRlKFwiWE1MSHR0cFJlcXVlc3QuanNcIikgYW5kIHVzZSBYTUxIdHRwUmVxdWVzdCBwZXIgVzNDIHNwZWNzLlxuICpcbiAqIEBhdXRob3IgRGFuIERlRmVsaXBwaSA8ZGFuQGRyaXZlcmRhbi5jb20+XG4gKiBAY29udHJpYnV0b3IgRGF2aWQgRWxsaXMgPGQuZi5lbGxpc0BpZWVlLm9yZz5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbnZhciBVcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIHNwYXduID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mykuc3Bhd247XG52YXIgZnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblxuZXhwb3J0cy5YTUxIdHRwUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICAvKipcbiAgICogUHJpdmF0ZSB2YXJpYWJsZXNcbiAgICovXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGh0dHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcbiAgdmFyIGh0dHBzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG5cbiAgLy8gSG9sZHMgaHR0cC5qcyBvYmplY3RzXG4gIHZhciByZXF1ZXN0O1xuICB2YXIgcmVzcG9uc2U7XG5cbiAgLy8gUmVxdWVzdCBzZXR0aW5nc1xuICB2YXIgc2V0dGluZ3MgPSB7fTtcblxuICAvLyBEaXNhYmxlIGhlYWRlciBibGFja2xpc3QuXG4gIC8vIE5vdCBwYXJ0IG9mIFhIUiBzcGVjcy5cbiAgdmFyIGRpc2FibGVIZWFkZXJDaGVjayA9IGZhbHNlO1xuXG4gIC8vIFNldCBzb21lIGRlZmF1bHQgaGVhZGVyc1xuICB2YXIgZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgXCJVc2VyLUFnZW50XCI6IFwibm9kZS1YTUxIdHRwUmVxdWVzdFwiLFxuICAgIFwiQWNjZXB0XCI6IFwiKi8qXCIsXG4gIH07XG5cbiAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgdmFyIGhlYWRlcnNDYXNlID0ge307XG5cbiAgLy8gVGhlc2UgaGVhZGVycyBhcmUgbm90IHVzZXIgc2V0YWJsZS5cbiAgLy8gVGhlIGZvbGxvd2luZyBhcmUgYWxsb3dlZCBidXQgYmFubmVkIGluIHRoZSBzcGVjOlxuICAvLyAqIHVzZXItYWdlbnRcbiAgdmFyIGZvcmJpZGRlblJlcXVlc3RIZWFkZXJzID0gW1xuICAgIFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgICBcImFjY2VwdC1lbmNvZGluZ1wiLFxuICAgIFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1oZWFkZXJzXCIsXG4gICAgXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZFwiLFxuICAgIFwiY29ubmVjdGlvblwiLFxuICAgIFwiY29udGVudC1sZW5ndGhcIixcbiAgICBcImNvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcImNvb2tpZVwiLFxuICAgIFwiY29va2llMlwiLFxuICAgIFwiZGF0ZVwiLFxuICAgIFwiZXhwZWN0XCIsXG4gICAgXCJob3N0XCIsXG4gICAgXCJrZWVwLWFsaXZlXCIsXG4gICAgXCJvcmlnaW5cIixcbiAgICBcInJlZmVyZXJcIixcbiAgICBcInRlXCIsXG4gICAgXCJ0cmFpbGVyXCIsXG4gICAgXCJ0cmFuc2Zlci1lbmNvZGluZ1wiLFxuICAgIFwidXBncmFkZVwiLFxuICAgIFwidmlhXCJcbiAgXTtcblxuICAvLyBUaGVzZSByZXF1ZXN0IG1ldGhvZHMgYXJlIG5vdCBhbGxvd2VkXG4gIHZhciBmb3JiaWRkZW5SZXF1ZXN0TWV0aG9kcyA9IFtcbiAgICBcIlRSQUNFXCIsXG4gICAgXCJUUkFDS1wiLFxuICAgIFwiQ09OTkVDVFwiXG4gIF07XG5cbiAgLy8gU2VuZCBmbGFnXG4gIHZhciBzZW5kRmxhZyA9IGZhbHNlO1xuICAvLyBFcnJvciBmbGFnLCB1c2VkIHdoZW4gZXJyb3JzIG9jY3VyIG9yIGFib3J0IGlzIGNhbGxlZFxuICB2YXIgZXJyb3JGbGFnID0gZmFsc2U7XG5cbiAgLy8gRXZlbnQgbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSB7fTtcblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIHRoaXMuVU5TRU5UID0gMDtcbiAgdGhpcy5PUEVORUQgPSAxO1xuICB0aGlzLkhFQURFUlNfUkVDRUlWRUQgPSAyO1xuICB0aGlzLkxPQURJTkcgPSAzO1xuICB0aGlzLkRPTkUgPSA0O1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgdmFyc1xuICAgKi9cblxuICAvLyBDdXJyZW50IHN0YXRlXG4gIHRoaXMucmVhZHlTdGF0ZSA9IHRoaXMuVU5TRU5UO1xuXG4gIC8vIGRlZmF1bHQgcmVhZHkgc3RhdGUgY2hhbmdlIGhhbmRsZXIgaW4gY2FzZSBvbmUgaXMgbm90IHNldCBvciBpcyBzZXQgbGF0ZVxuICB0aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cbiAgLy8gUmVzdWx0ICYgcmVzcG9uc2VcbiAgdGhpcy5yZXNwb25zZVRleHQgPSBcIlwiO1xuICB0aGlzLnJlc3BvbnNlWE1MID0gXCJcIjtcbiAgdGhpcy5zdGF0dXMgPSBudWxsO1xuICB0aGlzLnN0YXR1c1RleHQgPSBudWxsO1xuICBcbiAgLy8gV2hldGhlciBjcm9zcy1zaXRlIEFjY2Vzcy1Db250cm9sIHJlcXVlc3RzIHNob3VsZCBiZSBtYWRlIHVzaW5nXG4gIC8vIGNyZWRlbnRpYWxzIHN1Y2ggYXMgY29va2llcyBvciBhdXRob3JpemF0aW9uIGhlYWRlcnNcbiAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcblxuICAvKipcbiAgICogUHJpdmF0ZSBtZXRob2RzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc3BlY2lmaWVkIGhlYWRlciBpcyBhbGxvd2VkLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIGhlYWRlciBIZWFkZXIgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybiBib29sZWFuIEZhbHNlIGlmIG5vdCBhbGxvd2VkLCBvdGhlcndpc2UgdHJ1ZVxuICAgKi9cbiAgdmFyIGlzQWxsb3dlZEh0dHBIZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIpIHtcbiAgICByZXR1cm4gZGlzYWJsZUhlYWRlckNoZWNrIHx8IChoZWFkZXIgJiYgZm9yYmlkZGVuUmVxdWVzdEhlYWRlcnMuaW5kZXhPZihoZWFkZXIudG9Mb3dlckNhc2UoKSkgPT09IC0xKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHNwZWNpZmllZCBtZXRob2QgaXMgYWxsb3dlZC5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBtZXRob2QgUmVxdWVzdCBtZXRob2QgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybiBib29sZWFuIEZhbHNlIGlmIG5vdCBhbGxvd2VkLCBvdGhlcndpc2UgdHJ1ZVxuICAgKi9cbiAgdmFyIGlzQWxsb3dlZEh0dHBNZXRob2QgPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgICByZXR1cm4gKG1ldGhvZCAmJiBmb3JiaWRkZW5SZXF1ZXN0TWV0aG9kcy5pbmRleE9mKG1ldGhvZCkgPT09IC0xKTtcbiAgfTtcblxuICAvKipcbiAgICogUHVibGljIG1ldGhvZHNcbiAgICovXG5cbiAgLyoqXG4gICAqIE9wZW4gdGhlIGNvbm5lY3Rpb24uIEN1cnJlbnRseSBzdXBwb3J0cyBsb2NhbCBzZXJ2ZXIgcmVxdWVzdHMuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgbWV0aG9kIENvbm5lY3Rpb24gbWV0aG9kIChlZyBHRVQsIFBPU1QpXG4gICAqIEBwYXJhbSBzdHJpbmcgdXJsIFVSTCBmb3IgdGhlIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSBib29sZWFuIGFzeW5jIEFzeW5jaHJvbm91cyBjb25uZWN0aW9uLiBEZWZhdWx0IGlzIHRydWUuXG4gICAqIEBwYXJhbSBzdHJpbmcgdXNlciBVc2VybmFtZSBmb3IgYmFzaWMgYXV0aGVudGljYXRpb24gKG9wdGlvbmFsKVxuICAgKiBAcGFyYW0gc3RyaW5nIHBhc3N3b3JkIFBhc3N3b3JkIGZvciBiYXNpYyBhdXRoZW50aWNhdGlvbiAob3B0aW9uYWwpXG4gICAqL1xuICB0aGlzLm9wZW4gPSBmdW5jdGlvbihtZXRob2QsIHVybCwgYXN5bmMsIHVzZXIsIHBhc3N3b3JkKSB7XG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIGVycm9yRmxhZyA9IGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgZm9yIHZhbGlkIHJlcXVlc3QgbWV0aG9kXG4gICAgaWYgKCFpc0FsbG93ZWRIdHRwTWV0aG9kKG1ldGhvZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlY3VyaXR5RXJyb3I6IFJlcXVlc3QgbWV0aG9kIG5vdCBhbGxvd2VkXCIpO1xuICAgIH1cblxuICAgIHNldHRpbmdzID0ge1xuICAgICAgXCJtZXRob2RcIjogbWV0aG9kLFxuICAgICAgXCJ1cmxcIjogdXJsLnRvU3RyaW5nKCksXG4gICAgICBcImFzeW5jXCI6ICh0eXBlb2YgYXN5bmMgIT09IFwiYm9vbGVhblwiID8gdHJ1ZSA6IGFzeW5jKSxcbiAgICAgIFwidXNlclwiOiB1c2VyIHx8IG51bGwsXG4gICAgICBcInBhc3N3b3JkXCI6IHBhc3N3b3JkIHx8IG51bGxcbiAgICB9O1xuXG4gICAgc2V0U3RhdGUodGhpcy5PUEVORUQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlcyBvciBlbmFibGVzIGlzQWxsb3dlZEh0dHBIZWFkZXIoKSBjaGVjayB0aGUgcmVxdWVzdC4gRW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKiBUaGlzIGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIFczQyBzcGVjLlxuICAgKlxuICAgKiBAcGFyYW0gYm9vbGVhbiBzdGF0ZSBFbmFibGUgb3IgZGlzYWJsZSBoZWFkZXIgY2hlY2tpbmcuXG4gICAqL1xuICB0aGlzLnNldERpc2FibGVIZWFkZXJDaGVjayA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgZGlzYWJsZUhlYWRlckNoZWNrID0gc3RhdGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgYSBoZWFkZXIgZm9yIHRoZSByZXF1ZXN0IG9yIGFwcGVuZHMgdGhlIHZhbHVlIGlmIG9uZSBpcyBhbHJlYWR5IHNldC5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBoZWFkZXIgSGVhZGVyIG5hbWVcbiAgICogQHBhcmFtIHN0cmluZyB2YWx1ZSBIZWFkZXIgdmFsdWVcbiAgICovXG4gIHRoaXMuc2V0UmVxdWVzdEhlYWRlciA9IGZ1bmN0aW9uKGhlYWRlciwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLk9QRU5FRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRF9TVEFURV9FUlI6IHNldFJlcXVlc3RIZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIHdoZW4gc3RhdGUgaXMgT1BFTlwiKTtcbiAgICB9XG4gICAgaWYgKCFpc0FsbG93ZWRIdHRwSGVhZGVyKGhlYWRlcikpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlJlZnVzZWQgdG8gc2V0IHVuc2FmZSBoZWFkZXIgXFxcIlwiICsgaGVhZGVyICsgXCJcXFwiXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklOVkFMSURfU1RBVEVfRVJSOiBzZW5kIGZsYWcgaXMgdHJ1ZVwiKTtcbiAgICB9XG4gICAgaGVhZGVyID0gaGVhZGVyc0Nhc2VbaGVhZGVyLnRvTG93ZXJDYXNlKCldIHx8IGhlYWRlcjtcbiAgICBoZWFkZXJzQ2FzZVtoZWFkZXIudG9Mb3dlckNhc2UoKV0gPSBoZWFkZXI7XG4gICAgaGVhZGVyc1toZWFkZXJdID0gaGVhZGVyc1toZWFkZXJdID8gaGVhZGVyc1toZWFkZXJdICsgJywgJyArIHZhbHVlIDogdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYSBoZWFkZXIgZnJvbSB0aGUgc2VydmVyIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIGhlYWRlciBOYW1lIG9mIGhlYWRlciB0byBnZXQuXG4gICAqIEByZXR1cm4gc3RyaW5nIFRleHQgb2YgdGhlIGhlYWRlciBvciBudWxsIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICB0aGlzLmdldFJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBoZWFkZXIgPT09IFwic3RyaW5nXCJcbiAgICAgICYmIHRoaXMucmVhZHlTdGF0ZSA+IHRoaXMuT1BFTkVEXG4gICAgICAmJiByZXNwb25zZVxuICAgICAgJiYgcmVzcG9uc2UuaGVhZGVyc1xuICAgICAgJiYgcmVzcG9uc2UuaGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV1cbiAgICAgICYmICFlcnJvckZsYWdcbiAgICApIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5oZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhbGwgdGhlIHJlc3BvbnNlIGhlYWRlcnMuXG4gICAqXG4gICAqIEByZXR1cm4gc3RyaW5nIEEgc3RyaW5nIHdpdGggYWxsIHJlc3BvbnNlIGhlYWRlcnMgc2VwYXJhdGVkIGJ5IENSK0xGXG4gICAqL1xuICB0aGlzLmdldEFsbFJlc3BvbnNlSGVhZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPCB0aGlzLkhFQURFUlNfUkVDRUlWRUQgfHwgZXJyb3JGbGFnKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cbiAgICBmb3IgKHZhciBpIGluIHJlc3BvbnNlLmhlYWRlcnMpIHtcbiAgICAgIC8vIENvb2tpZSBoZWFkZXJzIGFyZSBleGNsdWRlZFxuICAgICAgaWYgKGkgIT09IFwic2V0LWNvb2tpZVwiICYmIGkgIT09IFwic2V0LWNvb2tpZTJcIikge1xuICAgICAgICByZXN1bHQgKz0gaSArIFwiOiBcIiArIHJlc3BvbnNlLmhlYWRlcnNbaV0gKyBcIlxcclxcblwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnN1YnN0cigwLCByZXN1bHQubGVuZ3RoIC0gMik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYSByZXF1ZXN0IGhlYWRlclxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIG5hbWUgTmFtZSBvZiBoZWFkZXIgdG8gZ2V0XG4gICAqIEByZXR1cm4gc3RyaW5nIFJldHVybnMgdGhlIHJlcXVlc3QgaGVhZGVyIG9yIGVtcHR5IHN0cmluZyBpZiBub3Qgc2V0XG4gICAqL1xuICB0aGlzLmdldFJlcXVlc3RIZWFkZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmIGhlYWRlcnNDYXNlW25hbWUudG9Mb3dlckNhc2UoKV0pIHtcbiAgICAgIHJldHVybiBoZWFkZXJzW2hlYWRlcnNDYXNlW25hbWUudG9Mb3dlckNhc2UoKV1dO1xuICAgIH1cblxuICAgIHJldHVybiBcIlwiO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgcmVxdWVzdCB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIGRhdGEgT3B0aW9uYWwgZGF0YSB0byBzZW5kIGFzIHJlcXVlc3QgYm9keS5cbiAgICovXG4gIHRoaXMuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLk9QRU5FRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRF9TVEFURV9FUlI6IGNvbm5lY3Rpb24gbXVzdCBiZSBvcGVuZWQgYmVmb3JlIHNlbmQoKSBpcyBjYWxsZWRcIik7XG4gICAgfVxuXG4gICAgaWYgKHNlbmRGbGFnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEX1NUQVRFX0VSUjogc2VuZCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG5cbiAgICB2YXIgc3NsID0gZmFsc2UsIGxvY2FsID0gZmFsc2U7XG4gICAgdmFyIHVybCA9IFVybC5wYXJzZShzZXR0aW5ncy51cmwpO1xuICAgIHZhciBob3N0O1xuICAgIC8vIERldGVybWluZSB0aGUgc2VydmVyXG4gICAgc3dpdGNoICh1cmwucHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgXCJodHRwczpcIjpcbiAgICAgICAgc3NsID0gdHJ1ZTtcbiAgICAgICAgLy8gU1NMICYgbm9uLVNTTCBib3RoIG5lZWQgaG9zdCwgbm8gYnJlYWsgaGVyZS5cbiAgICAgIGNhc2UgXCJodHRwOlwiOlxuICAgICAgICBob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImZpbGU6XCI6XG4gICAgICAgIGxvY2FsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgY2FzZSBudWxsOlxuICAgICAgY2FzZSBcIlwiOlxuICAgICAgICBob3N0ID0gXCJsb2NhbGhvc3RcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3RvY29sIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cblxuICAgIC8vIExvYWQgZmlsZXMgb2ZmIHRoZSBsb2NhbCBmaWxlc3lzdGVtIChmaWxlOi8vKVxuICAgIGlmIChsb2NhbCkge1xuICAgICAgaWYgKHNldHRpbmdzLm1ldGhvZCAhPT0gXCJHRVRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJYTUxIdHRwUmVxdWVzdDogT25seSBHRVQgbWV0aG9kIGlzIHN1cHBvcnRlZFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNldHRpbmdzLmFzeW5jKSB7XG4gICAgICAgIGZzLnJlYWRGaWxlKHVybC5wYXRobmFtZSwgXCJ1dGY4XCIsIGZ1bmN0aW9uKGVycm9yLCBkYXRhKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBzZWxmLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5zdGF0dXMgPSAyMDA7XG4gICAgICAgICAgICBzZWxmLnJlc3BvbnNlVGV4dCA9IGRhdGE7XG4gICAgICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gZnMucmVhZEZpbGVTeW5jKHVybC5wYXRobmFtZSwgXCJ1dGY4XCIpO1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gMjAwO1xuICAgICAgICAgIHNldFN0YXRlKHNlbGYuRE9ORSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gcG9ydCA4MC4gSWYgYWNjZXNzaW5nIGxvY2FsaG9zdCBvbiBhbm90aGVyIHBvcnQgYmUgc3VyZVxuICAgIC8vIHRvIHVzZSBodHRwOi8vbG9jYWxob3N0OnBvcnQvcGF0aFxuICAgIHZhciBwb3J0ID0gdXJsLnBvcnQgfHwgKHNzbCA/IDQ0MyA6IDgwKTtcbiAgICAvLyBBZGQgcXVlcnkgc3RyaW5nIGlmIG9uZSBpcyB1c2VkXG4gICAgdmFyIHVyaSA9IHVybC5wYXRobmFtZSArICh1cmwuc2VhcmNoID8gdXJsLnNlYXJjaCA6IFwiXCIpO1xuXG4gICAgLy8gU2V0IHRoZSBkZWZhdWx0cyBpZiB0aGV5IGhhdmVuJ3QgYmVlbiBzZXRcbiAgICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRIZWFkZXJzKSB7XG4gICAgICBpZiAoIWhlYWRlcnNDYXNlW25hbWUudG9Mb3dlckNhc2UoKV0pIHtcbiAgICAgICAgaGVhZGVyc1tuYW1lXSA9IGRlZmF1bHRIZWFkZXJzW25hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCB0aGUgSG9zdCBoZWFkZXIgb3IgdGhlIHNlcnZlciBtYXkgcmVqZWN0IHRoZSByZXF1ZXN0XG4gICAgaGVhZGVycy5Ib3N0ID0gaG9zdDtcbiAgICBpZiAoISgoc3NsICYmIHBvcnQgPT09IDQ0MykgfHwgcG9ydCA9PT0gODApKSB7XG4gICAgICBoZWFkZXJzLkhvc3QgKz0gXCI6XCIgKyB1cmwucG9ydDtcbiAgICB9XG5cbiAgICAvLyBTZXQgQmFzaWMgQXV0aCBpZiBuZWNlc3NhcnlcbiAgICBpZiAoc2V0dGluZ3MudXNlcikge1xuICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5wYXNzd29yZCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzZXR0aW5ncy5wYXNzd29yZCA9IFwiXCI7XG4gICAgICB9XG4gICAgICB2YXIgYXV0aEJ1ZiA9IG5ldyBCdWZmZXIoc2V0dGluZ3MudXNlciArIFwiOlwiICsgc2V0dGluZ3MucGFzc3dvcmQpO1xuICAgICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gXCJCYXNpYyBcIiArIGF1dGhCdWYudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuXG4gICAgLy8gU2V0IGNvbnRlbnQgbGVuZ3RoIGhlYWRlclxuICAgIGlmIChzZXR0aW5ncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgc2V0dGluZ3MubWV0aG9kID09PSBcIkhFQURcIikge1xuICAgICAgZGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChkYXRhKSB7XG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPSBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgPyBkYXRhLmxlbmd0aCA6IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuXG4gICAgICBpZiAoIWhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pIHtcbiAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04XCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncy5tZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICAvLyBGb3IgYSBwb3N0IHdpdGggbm8gZGF0YSBzZXQgQ29udGVudC1MZW5ndGg6IDAuXG4gICAgICAvLyBUaGlzIGlzIHJlcXVpcmVkIGJ5IGJ1Z2d5IHNlcnZlcnMgdGhhdCBkb24ndCBtZWV0IHRoZSBzcGVjcy5cbiAgICAgIGhlYWRlcnNbXCJDb250ZW50LUxlbmd0aFwiXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBob3N0OiBob3N0LFxuICAgICAgcG9ydDogcG9ydCxcbiAgICAgIHBhdGg6IHVyaSxcbiAgICAgIG1ldGhvZDogc2V0dGluZ3MubWV0aG9kLFxuICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgIGFnZW50OiBmYWxzZSxcbiAgICAgIHdpdGhDcmVkZW50aWFsczogc2VsZi53aXRoQ3JlZGVudGlhbHNcbiAgICB9O1xuXG4gICAgLy8gUmVzZXQgZXJyb3IgZmxhZ1xuICAgIGVycm9yRmxhZyA9IGZhbHNlO1xuXG4gICAgLy8gSGFuZGxlIGFzeW5jIHJlcXVlc3RzXG4gICAgaWYgKHNldHRpbmdzLmFzeW5jKSB7XG4gICAgICAvLyBVc2UgdGhlIHByb3BlciBwcm90b2NvbFxuICAgICAgdmFyIGRvUmVxdWVzdCA9IHNzbCA/IGh0dHBzLnJlcXVlc3QgOiBodHRwLnJlcXVlc3Q7XG5cbiAgICAgIC8vIFJlcXVlc3QgaXMgYmVpbmcgc2VudCwgc2V0IHNlbmQgZmxhZ1xuICAgICAgc2VuZEZsYWcgPSB0cnVlO1xuXG4gICAgICAvLyBBcyBwZXIgc3BlYywgdGhpcyBpcyBjYWxsZWQgaGVyZSBmb3IgaGlzdG9yaWNhbCByZWFzb25zLlxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwicmVhZHlzdGF0ZWNoYW5nZVwiKTtcblxuICAgICAgLy8gSGFuZGxlciBmb3IgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIYW5kbGVyID0gZnVuY3Rpb24gcmVzcG9uc2VIYW5kbGVyKHJlc3ApIHtcbiAgICAgICAgLy8gU2V0IHJlc3BvbnNlIHZhciB0byB0aGUgcmVzcG9uc2Ugd2UgZ290IGJhY2tcbiAgICAgICAgLy8gVGhpcyBpcyBzbyBpdCByZW1haW5zIGFjY2Vzc2FibGUgb3V0c2lkZSB0aGlzIHNjb3BlXG4gICAgICAgIHJlc3BvbnNlID0gcmVzcDtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHJlZGlyZWN0XG4gICAgICAgIC8vIEBUT0RPIFByZXZlbnQgbG9vcGVkIHJlZGlyZWN0c1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMiB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDMgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzA3KSB7XG4gICAgICAgICAgLy8gQ2hhbmdlIFVSTCB0byB0aGUgcmVkaXJlY3QgbG9jYXRpb25cbiAgICAgICAgICBzZXR0aW5ncy51cmwgPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uO1xuICAgICAgICAgIHZhciB1cmwgPSBVcmwucGFyc2Uoc2V0dGluZ3MudXJsKTtcbiAgICAgICAgICAvLyBTZXQgaG9zdCB2YXIgaW4gY2FzZSBpdCdzIHVzZWQgbGF0ZXJcbiAgICAgICAgICBob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICAgIC8vIE9wdGlvbnMgZm9yIHRoZSBuZXcgcmVxdWVzdFxuICAgICAgICAgIHZhciBuZXdPcHRpb25zID0ge1xuICAgICAgICAgICAgaG9zdG5hbWU6IHVybC5ob3N0bmFtZSxcbiAgICAgICAgICAgIHBvcnQ6IHVybC5wb3J0LFxuICAgICAgICAgICAgcGF0aDogdXJsLnBhdGgsXG4gICAgICAgICAgICBtZXRob2Q6IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMyA/IFwiR0VUXCIgOiBzZXR0aW5ncy5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLndpdGhDcmVkZW50aWFsc1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBJc3N1ZSB0aGUgbmV3IHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0ID0gZG9SZXF1ZXN0KG5ld09wdGlvbnMsIHJlc3BvbnNlSGFuZGxlcikub24oXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICAgICAgLy8gQFRPRE8gQ2hlY2sgaWYgYW4gWEhSIGV2ZW50IG5lZWRzIHRvIGJlIGZpcmVkIGhlcmVcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXNwb25zZS5zZXRFbmNvZGluZyhcInV0ZjhcIik7XG5cbiAgICAgICAgc2V0U3RhdGUoc2VsZi5IRUFERVJTX1JFQ0VJVkVEKTtcbiAgICAgICAgc2VsZi5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuXG4gICAgICAgIHJlc3BvbnNlLm9uKFwiZGF0YVwiLCBmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSdzIHNvbWUgZGF0YVxuICAgICAgICAgIGlmIChjaHVuaykge1xuICAgICAgICAgICAgc2VsZi5yZXNwb25zZVRleHQgKz0gY2h1bms7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIERvbid0IGVtaXQgc3RhdGUgY2hhbmdlcyBpZiB0aGUgY29ubmVjdGlvbiBoYXMgYmVlbiBhYm9ydGVkLlxuICAgICAgICAgIGlmIChzZW5kRmxhZykge1xuICAgICAgICAgICAgc2V0U3RhdGUoc2VsZi5MT0FESU5HKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3BvbnNlLm9uKFwiZW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChzZW5kRmxhZykge1xuICAgICAgICAgICAgLy8gRGlzY2FyZCB0aGUgZW5kIGV2ZW50IGlmIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIGFib3J0ZWRcbiAgICAgICAgICAgIHNldFN0YXRlKHNlbGYuRE9ORSk7XG4gICAgICAgICAgICBzZW5kRmxhZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzcG9uc2Uub24oXCJlcnJvclwiLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIHNlbGYuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEVycm9yIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0XG4gICAgICB2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gZXJyb3JIYW5kbGVyKGVycm9yKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgfTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gZG9SZXF1ZXN0KG9wdGlvbnMsIHJlc3BvbnNlSGFuZGxlcikub24oXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuXG4gICAgICAvLyBOb2RlIDAuNCBhbmQgbGF0ZXIgd29uJ3QgYWNjZXB0IGVtcHR5IGRhdGEuIE1ha2Ugc3VyZSBpdCdzIG5lZWRlZC5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHJlcXVlc3Qud3JpdGUoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuZW5kKCk7XG5cbiAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcImxvYWRzdGFydFwiKTtcbiAgICB9IGVsc2UgeyAvLyBTeW5jaHJvbm91c1xuICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGZpbGUgZm9yIGNvbW11bmljYXRpb24gd2l0aCB0aGUgb3RoZXIgTm9kZSBwcm9jZXNzXG4gICAgICB2YXIgY29udGVudEZpbGUgPSBcIi5ub2RlLXhtbGh0dHByZXF1ZXN0LWNvbnRlbnQtXCIgKyBwcm9jZXNzLnBpZDtcbiAgICAgIHZhciBzeW5jRmlsZSA9IFwiLm5vZGUteG1saHR0cHJlcXVlc3Qtc3luYy1cIiArIHByb2Nlc3MucGlkO1xuICAgICAgZnMud3JpdGVGaWxlU3luYyhzeW5jRmlsZSwgXCJcIiwgXCJ1dGY4XCIpO1xuICAgICAgLy8gVGhlIGFzeW5jIHJlcXVlc3QgdGhlIG90aGVyIE5vZGUgcHJvY2VzcyBleGVjdXRlc1xuICAgICAgdmFyIGV4ZWNTdHJpbmcgPSBcInZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpLCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyksIGZzID0gcmVxdWlyZSgnZnMnKTtcIlxuICAgICAgICArIFwidmFyIGRvUmVxdWVzdCA9IGh0dHBcIiArIChzc2wgPyBcInNcIiA6IFwiXCIpICsgXCIucmVxdWVzdDtcIlxuICAgICAgICArIFwidmFyIG9wdGlvbnMgPSBcIiArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpICsgXCI7XCJcbiAgICAgICAgKyBcInZhciByZXNwb25zZVRleHQgPSAnJztcIlxuICAgICAgICArIFwidmFyIHJlcSA9IGRvUmVxdWVzdChvcHRpb25zLCBmdW5jdGlvbihyZXNwb25zZSkge1wiXG4gICAgICAgICsgXCJyZXNwb25zZS5zZXRFbmNvZGluZygndXRmOCcpO1wiXG4gICAgICAgICsgXCJyZXNwb25zZS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XCJcbiAgICAgICAgKyBcIiAgcmVzcG9uc2VUZXh0ICs9IGNodW5rO1wiXG4gICAgICAgICsgXCJ9KTtcIlxuICAgICAgICArIFwicmVzcG9uc2Uub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1wiXG4gICAgICAgICsgXCJmcy53cml0ZUZpbGVTeW5jKCdcIiArIGNvbnRlbnRGaWxlICsgXCInLCBKU09OLnN0cmluZ2lmeSh7ZXJyOiBudWxsLCBkYXRhOiB7c3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzQ29kZSwgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycywgdGV4dDogcmVzcG9uc2VUZXh0fX0pLCAndXRmOCcpO1wiXG4gICAgICAgICsgXCJmcy51bmxpbmtTeW5jKCdcIiArIHN5bmNGaWxlICsgXCInKTtcIlxuICAgICAgICArIFwifSk7XCJcbiAgICAgICAgKyBcInJlc3BvbnNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XCJcbiAgICAgICAgKyBcImZzLndyaXRlRmlsZVN5bmMoJ1wiICsgY29udGVudEZpbGUgKyBcIicsIEpTT04uc3RyaW5naWZ5KHtlcnI6IGVycm9yfSksICd1dGY4Jyk7XCJcbiAgICAgICAgKyBcImZzLnVubGlua1N5bmMoJ1wiICsgc3luY0ZpbGUgKyBcIicpO1wiXG4gICAgICAgICsgXCJ9KTtcIlxuICAgICAgICArIFwifSkub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcIlxuICAgICAgICArIFwiZnMud3JpdGVGaWxlU3luYygnXCIgKyBjb250ZW50RmlsZSArIFwiJywgSlNPTi5zdHJpbmdpZnkoe2VycjogZXJyb3J9KSwgJ3V0ZjgnKTtcIlxuICAgICAgICArIFwiZnMudW5saW5rU3luYygnXCIgKyBzeW5jRmlsZSArIFwiJyk7XCJcbiAgICAgICAgKyBcIn0pO1wiXG4gICAgICAgICsgKGRhdGEgPyBcInJlcS53cml0ZSgnXCIgKyBKU09OLnN0cmluZ2lmeShkYXRhKS5zbGljZSgxLC0xKS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIikgKyBcIicpO1wiOlwiXCIpXG4gICAgICAgICsgXCJyZXEuZW5kKCk7XCI7XG4gICAgICAvLyBTdGFydCB0aGUgb3RoZXIgTm9kZSBQcm9jZXNzLCBleGVjdXRpbmcgdGhpcyBzdHJpbmdcbiAgICAgIHZhciBzeW5jUHJvYyA9IHNwYXduKHByb2Nlc3MuYXJndlswXSwgW1wiLWVcIiwgZXhlY1N0cmluZ10pO1xuICAgICAgd2hpbGUoZnMuZXhpc3RzU3luYyhzeW5jRmlsZSkpIHtcbiAgICAgICAgLy8gV2FpdCB3aGlsZSB0aGUgc3luYyBmaWxlIGlzIGVtcHR5XG4gICAgICB9XG4gICAgICB2YXIgcmVzcCA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKGNvbnRlbnRGaWxlLCAndXRmOCcpKTtcbiAgICAgIC8vIEtpbGwgdGhlIGNoaWxkIHByb2Nlc3Mgb25jZSB0aGUgZmlsZSBoYXMgZGF0YVxuICAgICAgc3luY1Byb2Muc3RkaW4uZW5kKCk7XG4gICAgICAvLyBSZW1vdmUgdGhlIHRlbXBvcmFyeSBmaWxlXG4gICAgICBmcy51bmxpbmtTeW5jKGNvbnRlbnRGaWxlKTtcblxuICAgICAgaWYgKHJlc3AuZXJyKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlRXJyb3IocmVzcC5lcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcG9uc2UgPSByZXNwLmRhdGE7XG4gICAgICAgIHNlbGYuc3RhdHVzID0gcmVzcC5kYXRhLnN0YXR1c0NvZGU7XG4gICAgICAgIHNlbGYucmVzcG9uc2VUZXh0ID0gcmVzcC5kYXRhLnRleHQ7XG4gICAgICAgIHNldFN0YXRlKHNlbGYuRE9ORSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCB0byBkZWFsIHdpdGggaXQuXG4gICAqL1xuICB0aGlzLmhhbmRsZUVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICB0aGlzLnN0YXR1cyA9IDA7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gZXJyb3I7XG4gICAgdGhpcy5yZXNwb25zZVRleHQgPSBlcnJvci5zdGFjaztcbiAgICBlcnJvckZsYWcgPSB0cnVlO1xuICAgIHNldFN0YXRlKHRoaXMuRE9ORSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdlcnJvcicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBYm9ydHMgYSByZXF1ZXN0LlxuICAgKi9cbiAgdGhpcy5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBoZWFkZXJzID0gZGVmYXVsdEhlYWRlcnM7XG4gICAgdGhpcy5zdGF0dXMgPSAwO1xuICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gXCJcIjtcbiAgICB0aGlzLnJlc3BvbnNlWE1MID0gXCJcIjtcblxuICAgIGVycm9yRmxhZyA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLlVOU0VOVFxuICAgICAgICAmJiAodGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLk9QRU5FRCB8fCBzZW5kRmxhZylcbiAgICAgICAgJiYgdGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLkRPTkUpIHtcbiAgICAgIHNlbmRGbGFnID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSh0aGlzLkRPTkUpO1xuICAgIH1cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSB0aGlzLlVOU0VOVDtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2Fib3J0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIuIFByZWZlcnJlZCBtZXRob2Qgb2YgYmluZGluZyB0byBldmVudHMuXG4gICAqL1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIShldmVudCBpbiBsaXN0ZW5lcnMpKSB7XG4gICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgfVxuICAgIC8vIEN1cnJlbnRseSBhbGxvd3MgZHVwbGljYXRlIGNhbGxiYWNrcy4gU2hvdWxkIGl0P1xuICAgIGxpc3RlbmVyc1tldmVudF0ucHVzaChjYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBjYWxsYmFjayB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gYm91bmQuXG4gICAqIE9ubHkgd29ya3Mgb24gdGhlIG1hdGNoaW5nIGZ1bmNpdG9uLCBjYW5ub3QgYmUgYSBjb3B5LlxuICAgKi9cbiAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGV2ZW50IGluIGxpc3RlbmVycykge1xuICAgICAgLy8gRmlsdGVyIHdpbGwgcmV0dXJuIGEgbmV3IGFycmF5IHdpdGggdGhlIGNhbGxiYWNrIHJlbW92ZWRcbiAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBsaXN0ZW5lcnNbZXZlbnRdLmZpbHRlcihmdW5jdGlvbihldikge1xuICAgICAgICByZXR1cm4gZXYgIT09IGNhbGxiYWNrO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhbnkgZXZlbnRzLCBpbmNsdWRpbmcgYm90aCBcIm9uXCIgbWV0aG9kcyBhbmQgZXZlbnRzIGF0dGFjaGVkIHVzaW5nIGFkZEV2ZW50TGlzdGVuZXIuXG4gICAqL1xuICB0aGlzLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZltcIm9uXCIgKyBldmVudF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgc2VsZltcIm9uXCIgKyBldmVudF0oKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50IGluIGxpc3RlbmVycykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVyc1tldmVudF0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGlzdGVuZXJzW2V2ZW50XVtpXS5jYWxsKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hhbmdlcyByZWFkeVN0YXRlIGFuZCBjYWxscyBvbnJlYWR5c3RhdGVjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBpbnQgc3RhdGUgTmV3IHN0YXRlXG4gICAqL1xuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9PSBzZWxmLkxPQURJTkcgfHwgc2VsZi5yZWFkeVN0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgc2VsZi5yZWFkeVN0YXRlID0gc3RhdGU7XG5cbiAgICAgIGlmIChzZXR0aW5ncy5hc3luYyB8fCBzZWxmLnJlYWR5U3RhdGUgPCBzZWxmLk9QRU5FRCB8fCBzZWxmLnJlYWR5U3RhdGUgPT09IHNlbGYuRE9ORSkge1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJyZWFkeXN0YXRlY2hhbmdlXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5yZWFkeVN0YXRlID09PSBzZWxmLkRPTkUgJiYgIWVycm9yRmxhZykge1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJsb2FkXCIpO1xuICAgICAgICAvLyBAVE9ETyBmaWd1cmUgb3V0IEluc3BlY3Rvckluc3RydW1lbnRhdGlvbjo6ZGlkTG9hZFhIUihjb29raWUpXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcImxvYWRlbmRcIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbihmdW5jdGlvbihuYWNsKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFBvcnRlZCBpbiAyMDE0IGJ5IERtaXRyeSBDaGVzdG55a2ggYW5kIERldmkgTWFuZGlyaS5cbi8vIFB1YmxpYyBkb21haW4uXG4vL1xuLy8gSW1wbGVtZW50YXRpb24gZGVyaXZlZCBmcm9tIFR3ZWV0TmFDbCB2ZXJzaW9uIDIwMTQwNDI3LlxuLy8gU2VlIGZvciBkZXRhaWxzOiBodHRwOi8vdHdlZXRuYWNsLmNyLnlwLnRvL1xuXG52YXIgZ2YgPSBmdW5jdGlvbihpbml0KSB7XG4gIHZhciBpLCByID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gIGlmIChpbml0KSBmb3IgKGkgPSAwOyBpIDwgaW5pdC5sZW5ndGg7IGkrKykgcltpXSA9IGluaXRbaV07XG4gIHJldHVybiByO1xufTtcblxuLy8gIFBsdWdnYWJsZSwgaW5pdGlhbGl6ZWQgaW4gaGlnaC1sZXZlbCBBUEkgYmVsb3cuXG52YXIgcmFuZG9tYnl0ZXMgPSBmdW5jdGlvbigvKiB4LCBuICovKSB7IHRocm93IG5ldyBFcnJvcignbm8gUFJORycpOyB9O1xuXG52YXIgXzAgPSBuZXcgVWludDhBcnJheSgxNik7XG52YXIgXzkgPSBuZXcgVWludDhBcnJheSgzMik7IF85WzBdID0gOTtcblxudmFyIGdmMCA9IGdmKCksXG4gICAgZ2YxID0gZ2YoWzFdKSxcbiAgICBfMTIxNjY1ID0gZ2YoWzB4ZGI0MSwgMV0pLFxuICAgIEQgPSBnZihbMHg3OGEzLCAweDEzNTksIDB4NGRjYSwgMHg3NWViLCAweGQ4YWIsIDB4NDE0MSwgMHgwYTRkLCAweDAwNzAsIDB4ZTg5OCwgMHg3Nzc5LCAweDQwNzksIDB4OGNjNywgMHhmZTczLCAweDJiNmYsIDB4NmNlZSwgMHg1MjAzXSksXG4gICAgRDIgPSBnZihbMHhmMTU5LCAweDI2YjIsIDB4OWI5NCwgMHhlYmQ2LCAweGIxNTYsIDB4ODI4MywgMHgxNDlhLCAweDAwZTAsIDB4ZDEzMCwgMHhlZWYzLCAweDgwZjIsIDB4MTk4ZSwgMHhmY2U3LCAweDU2ZGYsIDB4ZDlkYywgMHgyNDA2XSksXG4gICAgWCA9IGdmKFsweGQ1MWEsIDB4OGYyNSwgMHgyZDYwLCAweGM5NTYsIDB4YTdiMiwgMHg5NTI1LCAweGM3NjAsIDB4NjkyYywgMHhkYzVjLCAweGZkZDYsIDB4ZTIzMSwgMHhjMGE0LCAweDUzZmUsIDB4Y2Q2ZSwgMHgzNmQzLCAweDIxNjldKSxcbiAgICBZID0gZ2YoWzB4NjY1OCwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2Nl0pLFxuICAgIEkgPSBnZihbMHhhMGIwLCAweDRhMGUsIDB4MWIyNywgMHhjNGVlLCAweGU0NzgsIDB4YWQyZiwgMHgxODA2LCAweDJmNDMsIDB4ZDdhNywgMHgzZGZiLCAweDAwOTksIDB4MmI0ZCwgMHhkZjBiLCAweDRmYzEsIDB4MjQ4MCwgMHgyYjgzXSk7XG5cbmZ1bmN0aW9uIHRzNjQoeCwgaSwgaCwgbCkge1xuICB4W2ldICAgPSAoaCA+PiAyNCkgJiAweGZmO1xuICB4W2krMV0gPSAoaCA+PiAxNikgJiAweGZmO1xuICB4W2krMl0gPSAoaCA+PiAgOCkgJiAweGZmO1xuICB4W2krM10gPSBoICYgMHhmZjtcbiAgeFtpKzRdID0gKGwgPj4gMjQpICAmIDB4ZmY7XG4gIHhbaSs1XSA9IChsID4+IDE2KSAgJiAweGZmO1xuICB4W2krNl0gPSAobCA+PiAgOCkgICYgMHhmZjtcbiAgeFtpKzddID0gbCAmIDB4ZmY7XG59XG5cbmZ1bmN0aW9uIHZuKHgsIHhpLCB5LCB5aSwgbikge1xuICB2YXIgaSxkID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgZCB8PSB4W3hpK2ldXnlbeWkraV07XG4gIHJldHVybiAoMSAmICgoZCAtIDEpID4+PiA4KSkgLSAxO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fdmVyaWZ5XzE2KHgsIHhpLCB5LCB5aSkge1xuICByZXR1cm4gdm4oeCx4aSx5LHlpLDE2KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3ZlcmlmeV8zMih4LCB4aSwgeSwgeWkpIHtcbiAgcmV0dXJuIHZuKHgseGkseSx5aSwzMik7XG59XG5cbmZ1bmN0aW9uIGNvcmVfc2Fsc2EyMChvLCBwLCBrLCBjKSB7XG4gIHZhciBqMCAgPSBjWyAwXSAmIDB4ZmYgfCAoY1sgMV0gJiAweGZmKTw8OCB8IChjWyAyXSAmIDB4ZmYpPDwxNiB8IChjWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxICA9IGtbIDBdICYgMHhmZiB8IChrWyAxXSAmIDB4ZmYpPDw4IHwgKGtbIDJdICYgMHhmZik8PDE2IHwgKGtbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajIgID0ga1sgNF0gJiAweGZmIHwgKGtbIDVdICYgMHhmZik8PDggfCAoa1sgNl0gJiAweGZmKTw8MTYgfCAoa1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqMyAgPSBrWyA4XSAmIDB4ZmYgfCAoa1sgOV0gJiAweGZmKTw8OCB8IChrWzEwXSAmIDB4ZmYpPDwxNiB8IChrWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo0ICA9IGtbMTJdICYgMHhmZiB8IChrWzEzXSAmIDB4ZmYpPDw4IHwgKGtbMTRdICYgMHhmZik8PDE2IHwgKGtbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajUgID0gY1sgNF0gJiAweGZmIHwgKGNbIDVdICYgMHhmZik8PDggfCAoY1sgNl0gJiAweGZmKTw8MTYgfCAoY1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqNiAgPSBwWyAwXSAmIDB4ZmYgfCAocFsgMV0gJiAweGZmKTw8OCB8IChwWyAyXSAmIDB4ZmYpPDwxNiB8IChwWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo3ICA9IHBbIDRdICYgMHhmZiB8IChwWyA1XSAmIDB4ZmYpPDw4IHwgKHBbIDZdICYgMHhmZik8PDE2IHwgKHBbIDddICYgMHhmZik8PDI0LFxuICAgICAgajggID0gcFsgOF0gJiAweGZmIHwgKHBbIDldICYgMHhmZik8PDggfCAocFsxMF0gJiAweGZmKTw8MTYgfCAocFsxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqOSAgPSBwWzEyXSAmIDB4ZmYgfCAocFsxM10gJiAweGZmKTw8OCB8IChwWzE0XSAmIDB4ZmYpPDwxNiB8IChwWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMCA9IGNbIDhdICYgMHhmZiB8IChjWyA5XSAmIDB4ZmYpPDw4IHwgKGNbMTBdICYgMHhmZik8PDE2IHwgKGNbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajExID0ga1sxNl0gJiAweGZmIHwgKGtbMTddICYgMHhmZik8PDggfCAoa1sxOF0gJiAweGZmKTw8MTYgfCAoa1sxOV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTIgPSBrWzIwXSAmIDB4ZmYgfCAoa1syMV0gJiAweGZmKTw8OCB8IChrWzIyXSAmIDB4ZmYpPDwxNiB8IChrWzIzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMyA9IGtbMjRdICYgMHhmZiB8IChrWzI1XSAmIDB4ZmYpPDw4IHwgKGtbMjZdICYgMHhmZik8PDE2IHwgKGtbMjddICYgMHhmZik8PDI0LFxuICAgICAgajE0ID0ga1syOF0gJiAweGZmIHwgKGtbMjldICYgMHhmZik8PDggfCAoa1szMF0gJiAweGZmKTw8MTYgfCAoa1szMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTUgPSBjWzEyXSAmIDB4ZmYgfCAoY1sxM10gJiAweGZmKTw8OCB8IChjWzE0XSAmIDB4ZmYpPDwxNiB8IChjWzE1XSAmIDB4ZmYpPDwyNDtcblxuICB2YXIgeDAgPSBqMCwgeDEgPSBqMSwgeDIgPSBqMiwgeDMgPSBqMywgeDQgPSBqNCwgeDUgPSBqNSwgeDYgPSBqNiwgeDcgPSBqNyxcbiAgICAgIHg4ID0gajgsIHg5ID0gajksIHgxMCA9IGoxMCwgeDExID0gajExLCB4MTIgPSBqMTIsIHgxMyA9IGoxMywgeDE0ID0gajE0LFxuICAgICAgeDE1ID0gajE1LCB1O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkgKz0gMikge1xuICAgIHUgPSB4MCArIHgxMiB8IDA7XG4gICAgeDQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg0ICsgeDAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHg0IHwgMDtcbiAgICB4MTIgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEyICsgeDggfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4MSB8IDA7XG4gICAgeDkgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg5ICsgeDUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDkgfCAwO1xuICAgIHgxIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxICsgeDEzIHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg2IHwgMDtcbiAgICB4MTQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxNCArIHgxMCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDE0IHwgMDtcbiAgICB4NiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NiArIHgyIHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTEgfCAwO1xuICAgIHgzIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MyArIHgxNSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDMgfCAwO1xuICAgIHgxMSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTEgKyB4NyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDAgKyB4MyB8IDA7XG4gICAgeDEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxICsgeDAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxIHwgMDtcbiAgICB4MyBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MyArIHgyIHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDQgfCAwO1xuICAgIHg2IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NiArIHg1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4NiB8IDA7XG4gICAgeDQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDQgKyB4NyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4OSB8IDA7XG4gICAgeDExIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTEgKyB4MTAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHgxMSB8IDA7XG4gICAgeDkgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDkgKyB4OCB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDE0IHwgMDtcbiAgICB4MTIgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMiArIHgxNSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4MTIgfCAwO1xuICAgIHgxNCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTQgKyB4MTMgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuICB9XG4gICB4MCA9ICB4MCArICBqMCB8IDA7XG4gICB4MSA9ICB4MSArICBqMSB8IDA7XG4gICB4MiA9ICB4MiArICBqMiB8IDA7XG4gICB4MyA9ICB4MyArICBqMyB8IDA7XG4gICB4NCA9ICB4NCArICBqNCB8IDA7XG4gICB4NSA9ICB4NSArICBqNSB8IDA7XG4gICB4NiA9ICB4NiArICBqNiB8IDA7XG4gICB4NyA9ICB4NyArICBqNyB8IDA7XG4gICB4OCA9ICB4OCArICBqOCB8IDA7XG4gICB4OSA9ICB4OSArICBqOSB8IDA7XG4gIHgxMCA9IHgxMCArIGoxMCB8IDA7XG4gIHgxMSA9IHgxMSArIGoxMSB8IDA7XG4gIHgxMiA9IHgxMiArIGoxMiB8IDA7XG4gIHgxMyA9IHgxMyArIGoxMyB8IDA7XG4gIHgxNCA9IHgxNCArIGoxNCB8IDA7XG4gIHgxNSA9IHgxNSArIGoxNSB8IDA7XG5cbiAgb1sgMF0gPSB4MCA+Pj4gIDAgJiAweGZmO1xuICBvWyAxXSA9IHgwID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDJdID0geDAgPj4+IDE2ICYgMHhmZjtcbiAgb1sgM10gPSB4MCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDRdID0geDEgPj4+ICAwICYgMHhmZjtcbiAgb1sgNV0gPSB4MSA+Pj4gIDggJiAweGZmO1xuICBvWyA2XSA9IHgxID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDddID0geDEgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA4XSA9IHgyID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDldID0geDIgPj4+ICA4ICYgMHhmZjtcbiAgb1sxMF0gPSB4MiA+Pj4gMTYgJiAweGZmO1xuICBvWzExXSA9IHgyID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxMl0gPSB4MyA+Pj4gIDAgJiAweGZmO1xuICBvWzEzXSA9IHgzID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTRdID0geDMgPj4+IDE2ICYgMHhmZjtcbiAgb1sxNV0gPSB4MyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTZdID0geDQgPj4+ICAwICYgMHhmZjtcbiAgb1sxN10gPSB4NCA+Pj4gIDggJiAweGZmO1xuICBvWzE4XSA9IHg0ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTldID0geDQgPj4+IDI0ICYgMHhmZjtcblxuICBvWzIwXSA9IHg1ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjFdID0geDUgPj4+ICA4ICYgMHhmZjtcbiAgb1syMl0gPSB4NSA+Pj4gMTYgJiAweGZmO1xuICBvWzIzXSA9IHg1ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syNF0gPSB4NiA+Pj4gIDAgJiAweGZmO1xuICBvWzI1XSA9IHg2ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjZdID0geDYgPj4+IDE2ICYgMHhmZjtcbiAgb1syN10gPSB4NiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjhdID0geDcgPj4+ICAwICYgMHhmZjtcbiAgb1syOV0gPSB4NyA+Pj4gIDggJiAweGZmO1xuICBvWzMwXSA9IHg3ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMzFdID0geDcgPj4+IDI0ICYgMHhmZjtcblxuICBvWzMyXSA9IHg4ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMzNdID0geDggPj4+ICA4ICYgMHhmZjtcbiAgb1szNF0gPSB4OCA+Pj4gMTYgJiAweGZmO1xuICBvWzM1XSA9IHg4ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1szNl0gPSB4OSA+Pj4gIDAgJiAweGZmO1xuICBvWzM3XSA9IHg5ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzhdID0geDkgPj4+IDE2ICYgMHhmZjtcbiAgb1szOV0gPSB4OSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNDBdID0geDEwID4+PiAgMCAmIDB4ZmY7XG4gIG9bNDFdID0geDEwID4+PiAgOCAmIDB4ZmY7XG4gIG9bNDJdID0geDEwID4+PiAxNiAmIDB4ZmY7XG4gIG9bNDNdID0geDEwID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s0NF0gPSB4MTEgPj4+ICAwICYgMHhmZjtcbiAgb1s0NV0gPSB4MTEgPj4+ICA4ICYgMHhmZjtcbiAgb1s0Nl0gPSB4MTEgPj4+IDE2ICYgMHhmZjtcbiAgb1s0N10gPSB4MTEgPj4+IDI0ICYgMHhmZjtcblxuICBvWzQ4XSA9IHgxMiA+Pj4gIDAgJiAweGZmO1xuICBvWzQ5XSA9IHgxMiA+Pj4gIDggJiAweGZmO1xuICBvWzUwXSA9IHgxMiA+Pj4gMTYgJiAweGZmO1xuICBvWzUxXSA9IHgxMiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNTJdID0geDEzID4+PiAgMCAmIDB4ZmY7XG4gIG9bNTNdID0geDEzID4+PiAgOCAmIDB4ZmY7XG4gIG9bNTRdID0geDEzID4+PiAxNiAmIDB4ZmY7XG4gIG9bNTVdID0geDEzID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s1Nl0gPSB4MTQgPj4+ICAwICYgMHhmZjtcbiAgb1s1N10gPSB4MTQgPj4+ICA4ICYgMHhmZjtcbiAgb1s1OF0gPSB4MTQgPj4+IDE2ICYgMHhmZjtcbiAgb1s1OV0gPSB4MTQgPj4+IDI0ICYgMHhmZjtcblxuICBvWzYwXSA9IHgxNSA+Pj4gIDAgJiAweGZmO1xuICBvWzYxXSA9IHgxNSA+Pj4gIDggJiAweGZmO1xuICBvWzYyXSA9IHgxNSA+Pj4gMTYgJiAweGZmO1xuICBvWzYzXSA9IHgxNSA+Pj4gMjQgJiAweGZmO1xufVxuXG5mdW5jdGlvbiBjb3JlX2hzYWxzYTIwKG8scCxrLGMpIHtcbiAgdmFyIGowICA9IGNbIDBdICYgMHhmZiB8IChjWyAxXSAmIDB4ZmYpPDw4IHwgKGNbIDJdICYgMHhmZik8PDE2IHwgKGNbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajEgID0ga1sgMF0gJiAweGZmIHwgKGtbIDFdICYgMHhmZik8PDggfCAoa1sgMl0gJiAweGZmKTw8MTYgfCAoa1sgM10gJiAweGZmKTw8MjQsXG4gICAgICBqMiAgPSBrWyA0XSAmIDB4ZmYgfCAoa1sgNV0gJiAweGZmKTw8OCB8IChrWyA2XSAmIDB4ZmYpPDwxNiB8IChrWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGozICA9IGtbIDhdICYgMHhmZiB8IChrWyA5XSAmIDB4ZmYpPDw4IHwgKGtbMTBdICYgMHhmZik8PDE2IHwgKGtbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajQgID0ga1sxMl0gJiAweGZmIHwgKGtbMTNdICYgMHhmZik8PDggfCAoa1sxNF0gJiAweGZmKTw8MTYgfCAoa1sxNV0gJiAweGZmKTw8MjQsXG4gICAgICBqNSAgPSBjWyA0XSAmIDB4ZmYgfCAoY1sgNV0gJiAweGZmKTw8OCB8IChjWyA2XSAmIDB4ZmYpPDwxNiB8IChjWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo2ICA9IHBbIDBdICYgMHhmZiB8IChwWyAxXSAmIDB4ZmYpPDw4IHwgKHBbIDJdICYgMHhmZik8PDE2IHwgKHBbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajcgID0gcFsgNF0gJiAweGZmIHwgKHBbIDVdICYgMHhmZik8PDggfCAocFsgNl0gJiAweGZmKTw8MTYgfCAocFsgN10gJiAweGZmKTw8MjQsXG4gICAgICBqOCAgPSBwWyA4XSAmIDB4ZmYgfCAocFsgOV0gJiAweGZmKTw8OCB8IChwWzEwXSAmIDB4ZmYpPDwxNiB8IChwWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo5ICA9IHBbMTJdICYgMHhmZiB8IChwWzEzXSAmIDB4ZmYpPDw4IHwgKHBbMTRdICYgMHhmZik8PDE2IHwgKHBbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajEwID0gY1sgOF0gJiAweGZmIHwgKGNbIDldICYgMHhmZik8PDggfCAoY1sxMF0gJiAweGZmKTw8MTYgfCAoY1sxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTEgPSBrWzE2XSAmIDB4ZmYgfCAoa1sxN10gJiAweGZmKTw8OCB8IChrWzE4XSAmIDB4ZmYpPDwxNiB8IChrWzE5XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMiA9IGtbMjBdICYgMHhmZiB8IChrWzIxXSAmIDB4ZmYpPDw4IHwgKGtbMjJdICYgMHhmZik8PDE2IHwgKGtbMjNdICYgMHhmZik8PDI0LFxuICAgICAgajEzID0ga1syNF0gJiAweGZmIHwgKGtbMjVdICYgMHhmZik8PDggfCAoa1syNl0gJiAweGZmKTw8MTYgfCAoa1syN10gJiAweGZmKTw8MjQsXG4gICAgICBqMTQgPSBrWzI4XSAmIDB4ZmYgfCAoa1syOV0gJiAweGZmKTw8OCB8IChrWzMwXSAmIDB4ZmYpPDwxNiB8IChrWzMxXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxNSA9IGNbMTJdICYgMHhmZiB8IChjWzEzXSAmIDB4ZmYpPDw4IHwgKGNbMTRdICYgMHhmZik8PDE2IHwgKGNbMTVdICYgMHhmZik8PDI0O1xuXG4gIHZhciB4MCA9IGowLCB4MSA9IGoxLCB4MiA9IGoyLCB4MyA9IGozLCB4NCA9IGo0LCB4NSA9IGo1LCB4NiA9IGo2LCB4NyA9IGo3LFxuICAgICAgeDggPSBqOCwgeDkgPSBqOSwgeDEwID0gajEwLCB4MTEgPSBqMTEsIHgxMiA9IGoxMiwgeDEzID0gajEzLCB4MTQgPSBqMTQsXG4gICAgICB4MTUgPSBqMTUsIHU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDsgaSArPSAyKSB7XG4gICAgdSA9IHgwICsgeDEyIHwgMDtcbiAgICB4NCBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDQgKyB4MCB8IDA7XG4gICAgeDggXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg4ICsgeDQgfCAwO1xuICAgIHgxMiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTIgKyB4OCB8IDA7XG4gICAgeDAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4NSArIHgxIHwgMDtcbiAgICB4OSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDkgKyB4NSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4OSB8IDA7XG4gICAgeDEgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEgKyB4MTMgfCAwO1xuICAgIHg1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDEwICsgeDYgfCAwO1xuICAgIHgxNCBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDE0ICsgeDEwIHwgMDtcbiAgICB4MiBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDIgKyB4MTQgfCAwO1xuICAgIHg2IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg2ICsgeDIgfCAwO1xuICAgIHgxMCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxNSArIHgxMSB8IDA7XG4gICAgeDMgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgzICsgeDE1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4MyB8IDA7XG4gICAgeDExIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxMSArIHg3IHwgMDtcbiAgICB4MTUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MCArIHgzIHwgMDtcbiAgICB4MSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDEgKyB4MCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDEgfCAwO1xuICAgIHgzIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgzICsgeDIgfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4NCB8IDA7XG4gICAgeDYgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg2ICsgeDUgfCAwO1xuICAgIHg3IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4NyArIHg2IHwgMDtcbiAgICB4NCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NCArIHg3IHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg5IHwgMDtcbiAgICB4MTEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMSArIHgxMCB8IDA7XG4gICAgeDggXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg4ICsgeDExIHwgMDtcbiAgICB4OSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4OSArIHg4IHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTQgfCAwO1xuICAgIHgxMiBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDEyICsgeDE1IHwgMDtcbiAgICB4MTMgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgxMyArIHgxMiB8IDA7XG4gICAgeDE0IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxNCArIHgxMyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG4gIH1cblxuICBvWyAwXSA9IHgwID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDFdID0geDAgPj4+ICA4ICYgMHhmZjtcbiAgb1sgMl0gPSB4MCA+Pj4gMTYgJiAweGZmO1xuICBvWyAzXSA9IHgwID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sgNF0gPSB4NSA+Pj4gIDAgJiAweGZmO1xuICBvWyA1XSA9IHg1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDZdID0geDUgPj4+IDE2ICYgMHhmZjtcbiAgb1sgN10gPSB4NSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDhdID0geDEwID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDldID0geDEwID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTBdID0geDEwID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTFdID0geDEwID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxMl0gPSB4MTUgPj4+ICAwICYgMHhmZjtcbiAgb1sxM10gPSB4MTUgPj4+ICA4ICYgMHhmZjtcbiAgb1sxNF0gPSB4MTUgPj4+IDE2ICYgMHhmZjtcbiAgb1sxNV0gPSB4MTUgPj4+IDI0ICYgMHhmZjtcblxuICBvWzE2XSA9IHg2ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTddID0geDYgPj4+ICA4ICYgMHhmZjtcbiAgb1sxOF0gPSB4NiA+Pj4gMTYgJiAweGZmO1xuICBvWzE5XSA9IHg2ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syMF0gPSB4NyA+Pj4gIDAgJiAweGZmO1xuICBvWzIxXSA9IHg3ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjJdID0geDcgPj4+IDE2ICYgMHhmZjtcbiAgb1syM10gPSB4NyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjRdID0geDggPj4+ICAwICYgMHhmZjtcbiAgb1syNV0gPSB4OCA+Pj4gIDggJiAweGZmO1xuICBvWzI2XSA9IHg4ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjddID0geDggPj4+IDI0ICYgMHhmZjtcblxuICBvWzI4XSA9IHg5ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjldID0geDkgPj4+ICA4ICYgMHhmZjtcbiAgb1szMF0gPSB4OSA+Pj4gMTYgJiAweGZmO1xuICBvWzMxXSA9IHg5ID4+PiAyNCAmIDB4ZmY7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19jb3JlX3NhbHNhMjAob3V0LGlucCxrLGMpIHtcbiAgY29yZV9zYWxzYTIwKG91dCxpbnAsayxjKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2NvcmVfaHNhbHNhMjAob3V0LGlucCxrLGMpIHtcbiAgY29yZV9oc2Fsc2EyMChvdXQsaW5wLGssYyk7XG59XG5cbnZhciBzaWdtYSA9IG5ldyBVaW50OEFycmF5KFsxMDEsIDEyMCwgMTEyLCA5NywgMTEwLCAxMDAsIDMyLCA1MSwgNTAsIDQ1LCA5OCwgMTIxLCAxMTYsIDEwMSwgMzIsIDEwN10pO1xuICAgICAgICAgICAgLy8gXCJleHBhbmQgMzItYnl0ZSBrXCJcblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcihjLGNwb3MsbSxtcG9zLGIsbixrKSB7XG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMTYpLCB4ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgdSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHpbaV0gPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB6W2ldID0gbltpXTtcbiAgd2hpbGUgKGIgPj0gNjQpIHtcbiAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgseixrLHNpZ21hKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgY1tjcG9zK2ldID0gbVttcG9zK2ldIF4geFtpXTtcbiAgICB1ID0gMTtcbiAgICBmb3IgKGkgPSA4OyBpIDwgMTY7IGkrKykge1xuICAgICAgdSA9IHUgKyAoeltpXSAmIDB4ZmYpIHwgMDtcbiAgICAgIHpbaV0gPSB1ICYgMHhmZjtcbiAgICAgIHUgPj4+PSA4O1xuICAgIH1cbiAgICBiIC09IDY0O1xuICAgIGNwb3MgKz0gNjQ7XG4gICAgbXBvcyArPSA2NDtcbiAgfVxuICBpZiAoYiA+IDApIHtcbiAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgseixrLHNpZ21hKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYjsgaSsrKSBjW2Nwb3MraV0gPSBtW21wb3MraV0gXiB4W2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtX3NhbHNhMjAoYyxjcG9zLGIsbixrKSB7XG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMTYpLCB4ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgdSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHpbaV0gPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB6W2ldID0gbltpXTtcbiAgd2hpbGUgKGIgPj0gNjQpIHtcbiAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgseixrLHNpZ21hKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgY1tjcG9zK2ldID0geFtpXTtcbiAgICB1ID0gMTtcbiAgICBmb3IgKGkgPSA4OyBpIDwgMTY7IGkrKykge1xuICAgICAgdSA9IHUgKyAoeltpXSAmIDB4ZmYpIHwgMDtcbiAgICAgIHpbaV0gPSB1ICYgMHhmZjtcbiAgICAgIHUgPj4+PSA4O1xuICAgIH1cbiAgICBiIC09IDY0O1xuICAgIGNwb3MgKz0gNjQ7XG4gIH1cbiAgaWYgKGIgPiAwKSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGI7IGkrKykgY1tjcG9zK2ldID0geFtpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbShjLGNwb3MsZCxuLGspIHtcbiAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19jb3JlX2hzYWxzYTIwKHMsbixrLHNpZ21hKTtcbiAgdmFyIHNuID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBzbltpXSA9IG5baSsxNl07XG4gIHJldHVybiBjcnlwdG9fc3RyZWFtX3NhbHNhMjAoYyxjcG9zLGQsc24scyk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW1feG9yKGMsY3BvcyxtLG1wb3MsZCxuLGspIHtcbiAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19jb3JlX2hzYWxzYTIwKHMsbixrLHNpZ21hKTtcbiAgdmFyIHNuID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBzbltpXSA9IG5baSsxNl07XG4gIHJldHVybiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yKGMsY3BvcyxtLG1wb3MsZCxzbixzKTtcbn1cblxuLypcbiogUG9ydCBvZiBBbmRyZXcgTW9vbidzIFBvbHkxMzA1LWRvbm5hLTE2LiBQdWJsaWMgZG9tYWluLlxuKiBodHRwczovL2dpdGh1Yi5jb20vZmxvb2R5YmVycnkvcG9seTEzMDUtZG9ubmFcbiovXG5cbnZhciBwb2x5MTMwNSA9IGZ1bmN0aW9uKGtleSkge1xuICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgdGhpcy5yID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdGhpcy5oID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdGhpcy5wYWQgPSBuZXcgVWludDE2QXJyYXkoOCk7XG4gIHRoaXMubGVmdG92ZXIgPSAwO1xuICB0aGlzLmZpbiA9IDA7XG5cbiAgdmFyIHQwLCB0MSwgdDIsIHQzLCB0NCwgdDUsIHQ2LCB0NztcblxuICB0MCA9IGtleVsgMF0gJiAweGZmIHwgKGtleVsgMV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbMF0gPSAoIHQwICAgICAgICAgICAgICAgICAgICAgKSAmIDB4MWZmZjtcbiAgdDEgPSBrZXlbIDJdICYgMHhmZiB8IChrZXlbIDNdICYgMHhmZikgPDwgODsgdGhpcy5yWzFdID0gKCh0MCA+Pj4gMTMpIHwgKHQxIDw8ICAzKSkgJiAweDFmZmY7XG4gIHQyID0ga2V5WyA0XSAmIDB4ZmYgfCAoa2V5WyA1XSAmIDB4ZmYpIDw8IDg7IHRoaXMuclsyXSA9ICgodDEgPj4+IDEwKSB8ICh0MiA8PCAgNikpICYgMHgxZjAzO1xuICB0MyA9IGtleVsgNl0gJiAweGZmIHwgKGtleVsgN10gJiAweGZmKSA8PCA4OyB0aGlzLnJbM10gPSAoKHQyID4+PiAgNykgfCAodDMgPDwgIDkpKSAmIDB4MWZmZjtcbiAgdDQgPSBrZXlbIDhdICYgMHhmZiB8IChrZXlbIDldICYgMHhmZikgPDwgODsgdGhpcy5yWzRdID0gKCh0MyA+Pj4gIDQpIHwgKHQ0IDw8IDEyKSkgJiAweDAwZmY7XG4gIHRoaXMucls1XSA9ICgodDQgPj4+ICAxKSkgJiAweDFmZmU7XG4gIHQ1ID0ga2V5WzEwXSAmIDB4ZmYgfCAoa2V5WzExXSAmIDB4ZmYpIDw8IDg7IHRoaXMucls2XSA9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAgMikpICYgMHgxZmZmO1xuICB0NiA9IGtleVsxMl0gJiAweGZmIHwgKGtleVsxM10gJiAweGZmKSA8PCA4OyB0aGlzLnJbN10gPSAoKHQ1ID4+PiAxMSkgfCAodDYgPDwgIDUpKSAmIDB4MWY4MTtcbiAgdDcgPSBrZXlbMTRdICYgMHhmZiB8IChrZXlbMTVdICYgMHhmZikgPDwgODsgdGhpcy5yWzhdID0gKCh0NiA+Pj4gIDgpIHwgKHQ3IDw8ICA4KSkgJiAweDFmZmY7XG4gIHRoaXMucls5XSA9ICgodDcgPj4+ICA1KSkgJiAweDAwN2Y7XG5cbiAgdGhpcy5wYWRbMF0gPSBrZXlbMTZdICYgMHhmZiB8IChrZXlbMTddICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbMV0gPSBrZXlbMThdICYgMHhmZiB8IChrZXlbMTldICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbMl0gPSBrZXlbMjBdICYgMHhmZiB8IChrZXlbMjFdICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbM10gPSBrZXlbMjJdICYgMHhmZiB8IChrZXlbMjNdICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbNF0gPSBrZXlbMjRdICYgMHhmZiB8IChrZXlbMjVdICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbNV0gPSBrZXlbMjZdICYgMHhmZiB8IChrZXlbMjddICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbNl0gPSBrZXlbMjhdICYgMHhmZiB8IChrZXlbMjldICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbN10gPSBrZXlbMzBdICYgMHhmZiB8IChrZXlbMzFdICYgMHhmZikgPDwgODtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS5ibG9ja3MgPSBmdW5jdGlvbihtLCBtcG9zLCBieXRlcykge1xuICB2YXIgaGliaXQgPSB0aGlzLmZpbiA/IDAgOiAoMSA8PCAxMSk7XG4gIHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1LCB0NiwgdDcsIGM7XG4gIHZhciBkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOTtcblxuICB2YXIgaDAgPSB0aGlzLmhbMF0sXG4gICAgICBoMSA9IHRoaXMuaFsxXSxcbiAgICAgIGgyID0gdGhpcy5oWzJdLFxuICAgICAgaDMgPSB0aGlzLmhbM10sXG4gICAgICBoNCA9IHRoaXMuaFs0XSxcbiAgICAgIGg1ID0gdGhpcy5oWzVdLFxuICAgICAgaDYgPSB0aGlzLmhbNl0sXG4gICAgICBoNyA9IHRoaXMuaFs3XSxcbiAgICAgIGg4ID0gdGhpcy5oWzhdLFxuICAgICAgaDkgPSB0aGlzLmhbOV07XG5cbiAgdmFyIHIwID0gdGhpcy5yWzBdLFxuICAgICAgcjEgPSB0aGlzLnJbMV0sXG4gICAgICByMiA9IHRoaXMuclsyXSxcbiAgICAgIHIzID0gdGhpcy5yWzNdLFxuICAgICAgcjQgPSB0aGlzLnJbNF0sXG4gICAgICByNSA9IHRoaXMucls1XSxcbiAgICAgIHI2ID0gdGhpcy5yWzZdLFxuICAgICAgcjcgPSB0aGlzLnJbN10sXG4gICAgICByOCA9IHRoaXMucls4XSxcbiAgICAgIHI5ID0gdGhpcy5yWzldO1xuXG4gIHdoaWxlIChieXRlcyA+PSAxNikge1xuICAgIHQwID0gbVttcG9zKyAwXSAmIDB4ZmYgfCAobVttcG9zKyAxXSAmIDB4ZmYpIDw8IDg7IGgwICs9ICggdDAgICAgICAgICAgICAgICAgICAgICApICYgMHgxZmZmO1xuICAgIHQxID0gbVttcG9zKyAyXSAmIDB4ZmYgfCAobVttcG9zKyAzXSAmIDB4ZmYpIDw8IDg7IGgxICs9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAgMykpICYgMHgxZmZmO1xuICAgIHQyID0gbVttcG9zKyA0XSAmIDB4ZmYgfCAobVttcG9zKyA1XSAmIDB4ZmYpIDw8IDg7IGgyICs9ICgodDEgPj4+IDEwKSB8ICh0MiA8PCAgNikpICYgMHgxZmZmO1xuICAgIHQzID0gbVttcG9zKyA2XSAmIDB4ZmYgfCAobVttcG9zKyA3XSAmIDB4ZmYpIDw8IDg7IGgzICs9ICgodDIgPj4+ICA3KSB8ICh0MyA8PCAgOSkpICYgMHgxZmZmO1xuICAgIHQ0ID0gbVttcG9zKyA4XSAmIDB4ZmYgfCAobVttcG9zKyA5XSAmIDB4ZmYpIDw8IDg7IGg0ICs9ICgodDMgPj4+ICA0KSB8ICh0NCA8PCAxMikpICYgMHgxZmZmO1xuICAgIGg1ICs9ICgodDQgPj4+ICAxKSkgJiAweDFmZmY7XG4gICAgdDUgPSBtW21wb3MrMTBdICYgMHhmZiB8IChtW21wb3MrMTFdICYgMHhmZikgPDwgODsgaDYgKz0gKCh0NCA+Pj4gMTQpIHwgKHQ1IDw8ICAyKSkgJiAweDFmZmY7XG4gICAgdDYgPSBtW21wb3MrMTJdICYgMHhmZiB8IChtW21wb3MrMTNdICYgMHhmZikgPDwgODsgaDcgKz0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8ICA1KSkgJiAweDFmZmY7XG4gICAgdDcgPSBtW21wb3MrMTRdICYgMHhmZiB8IChtW21wb3MrMTVdICYgMHhmZikgPDwgODsgaDggKz0gKCh0NiA+Pj4gIDgpIHwgKHQ3IDw8ICA4KSkgJiAweDFmZmY7XG4gICAgaDkgKz0gKCh0NyA+Pj4gNSkpIHwgaGliaXQ7XG5cbiAgICBjID0gMDtcblxuICAgIGQwID0gYztcbiAgICBkMCArPSBoMCAqIHIwO1xuICAgIGQwICs9IGgxICogKDUgKiByOSk7XG4gICAgZDAgKz0gaDIgKiAoNSAqIHI4KTtcbiAgICBkMCArPSBoMyAqICg1ICogcjcpO1xuICAgIGQwICs9IGg0ICogKDUgKiByNik7XG4gICAgYyA9IChkMCA+Pj4gMTMpOyBkMCAmPSAweDFmZmY7XG4gICAgZDAgKz0gaDUgKiAoNSAqIHI1KTtcbiAgICBkMCArPSBoNiAqICg1ICogcjQpO1xuICAgIGQwICs9IGg3ICogKDUgKiByMyk7XG4gICAgZDAgKz0gaDggKiAoNSAqIHIyKTtcbiAgICBkMCArPSBoOSAqICg1ICogcjEpO1xuICAgIGMgKz0gKGQwID4+PiAxMyk7IGQwICY9IDB4MWZmZjtcblxuICAgIGQxID0gYztcbiAgICBkMSArPSBoMCAqIHIxO1xuICAgIGQxICs9IGgxICogcjA7XG4gICAgZDEgKz0gaDIgKiAoNSAqIHI5KTtcbiAgICBkMSArPSBoMyAqICg1ICogcjgpO1xuICAgIGQxICs9IGg0ICogKDUgKiByNyk7XG4gICAgYyA9IChkMSA+Pj4gMTMpOyBkMSAmPSAweDFmZmY7XG4gICAgZDEgKz0gaDUgKiAoNSAqIHI2KTtcbiAgICBkMSArPSBoNiAqICg1ICogcjUpO1xuICAgIGQxICs9IGg3ICogKDUgKiByNCk7XG4gICAgZDEgKz0gaDggKiAoNSAqIHIzKTtcbiAgICBkMSArPSBoOSAqICg1ICogcjIpO1xuICAgIGMgKz0gKGQxID4+PiAxMyk7IGQxICY9IDB4MWZmZjtcblxuICAgIGQyID0gYztcbiAgICBkMiArPSBoMCAqIHIyO1xuICAgIGQyICs9IGgxICogcjE7XG4gICAgZDIgKz0gaDIgKiByMDtcbiAgICBkMiArPSBoMyAqICg1ICogcjkpO1xuICAgIGQyICs9IGg0ICogKDUgKiByOCk7XG4gICAgYyA9IChkMiA+Pj4gMTMpOyBkMiAmPSAweDFmZmY7XG4gICAgZDIgKz0gaDUgKiAoNSAqIHI3KTtcbiAgICBkMiArPSBoNiAqICg1ICogcjYpO1xuICAgIGQyICs9IGg3ICogKDUgKiByNSk7XG4gICAgZDIgKz0gaDggKiAoNSAqIHI0KTtcbiAgICBkMiArPSBoOSAqICg1ICogcjMpO1xuICAgIGMgKz0gKGQyID4+PiAxMyk7IGQyICY9IDB4MWZmZjtcblxuICAgIGQzID0gYztcbiAgICBkMyArPSBoMCAqIHIzO1xuICAgIGQzICs9IGgxICogcjI7XG4gICAgZDMgKz0gaDIgKiByMTtcbiAgICBkMyArPSBoMyAqIHIwO1xuICAgIGQzICs9IGg0ICogKDUgKiByOSk7XG4gICAgYyA9IChkMyA+Pj4gMTMpOyBkMyAmPSAweDFmZmY7XG4gICAgZDMgKz0gaDUgKiAoNSAqIHI4KTtcbiAgICBkMyArPSBoNiAqICg1ICogcjcpO1xuICAgIGQzICs9IGg3ICogKDUgKiByNik7XG4gICAgZDMgKz0gaDggKiAoNSAqIHI1KTtcbiAgICBkMyArPSBoOSAqICg1ICogcjQpO1xuICAgIGMgKz0gKGQzID4+PiAxMyk7IGQzICY9IDB4MWZmZjtcblxuICAgIGQ0ID0gYztcbiAgICBkNCArPSBoMCAqIHI0O1xuICAgIGQ0ICs9IGgxICogcjM7XG4gICAgZDQgKz0gaDIgKiByMjtcbiAgICBkNCArPSBoMyAqIHIxO1xuICAgIGQ0ICs9IGg0ICogcjA7XG4gICAgYyA9IChkNCA+Pj4gMTMpOyBkNCAmPSAweDFmZmY7XG4gICAgZDQgKz0gaDUgKiAoNSAqIHI5KTtcbiAgICBkNCArPSBoNiAqICg1ICogcjgpO1xuICAgIGQ0ICs9IGg3ICogKDUgKiByNyk7XG4gICAgZDQgKz0gaDggKiAoNSAqIHI2KTtcbiAgICBkNCArPSBoOSAqICg1ICogcjUpO1xuICAgIGMgKz0gKGQ0ID4+PiAxMyk7IGQ0ICY9IDB4MWZmZjtcblxuICAgIGQ1ID0gYztcbiAgICBkNSArPSBoMCAqIHI1O1xuICAgIGQ1ICs9IGgxICogcjQ7XG4gICAgZDUgKz0gaDIgKiByMztcbiAgICBkNSArPSBoMyAqIHIyO1xuICAgIGQ1ICs9IGg0ICogcjE7XG4gICAgYyA9IChkNSA+Pj4gMTMpOyBkNSAmPSAweDFmZmY7XG4gICAgZDUgKz0gaDUgKiByMDtcbiAgICBkNSArPSBoNiAqICg1ICogcjkpO1xuICAgIGQ1ICs9IGg3ICogKDUgKiByOCk7XG4gICAgZDUgKz0gaDggKiAoNSAqIHI3KTtcbiAgICBkNSArPSBoOSAqICg1ICogcjYpO1xuICAgIGMgKz0gKGQ1ID4+PiAxMyk7IGQ1ICY9IDB4MWZmZjtcblxuICAgIGQ2ID0gYztcbiAgICBkNiArPSBoMCAqIHI2O1xuICAgIGQ2ICs9IGgxICogcjU7XG4gICAgZDYgKz0gaDIgKiByNDtcbiAgICBkNiArPSBoMyAqIHIzO1xuICAgIGQ2ICs9IGg0ICogcjI7XG4gICAgYyA9IChkNiA+Pj4gMTMpOyBkNiAmPSAweDFmZmY7XG4gICAgZDYgKz0gaDUgKiByMTtcbiAgICBkNiArPSBoNiAqIHIwO1xuICAgIGQ2ICs9IGg3ICogKDUgKiByOSk7XG4gICAgZDYgKz0gaDggKiAoNSAqIHI4KTtcbiAgICBkNiArPSBoOSAqICg1ICogcjcpO1xuICAgIGMgKz0gKGQ2ID4+PiAxMyk7IGQ2ICY9IDB4MWZmZjtcblxuICAgIGQ3ID0gYztcbiAgICBkNyArPSBoMCAqIHI3O1xuICAgIGQ3ICs9IGgxICogcjY7XG4gICAgZDcgKz0gaDIgKiByNTtcbiAgICBkNyArPSBoMyAqIHI0O1xuICAgIGQ3ICs9IGg0ICogcjM7XG4gICAgYyA9IChkNyA+Pj4gMTMpOyBkNyAmPSAweDFmZmY7XG4gICAgZDcgKz0gaDUgKiByMjtcbiAgICBkNyArPSBoNiAqIHIxO1xuICAgIGQ3ICs9IGg3ICogcjA7XG4gICAgZDcgKz0gaDggKiAoNSAqIHI5KTtcbiAgICBkNyArPSBoOSAqICg1ICogcjgpO1xuICAgIGMgKz0gKGQ3ID4+PiAxMyk7IGQ3ICY9IDB4MWZmZjtcblxuICAgIGQ4ID0gYztcbiAgICBkOCArPSBoMCAqIHI4O1xuICAgIGQ4ICs9IGgxICogcjc7XG4gICAgZDggKz0gaDIgKiByNjtcbiAgICBkOCArPSBoMyAqIHI1O1xuICAgIGQ4ICs9IGg0ICogcjQ7XG4gICAgYyA9IChkOCA+Pj4gMTMpOyBkOCAmPSAweDFmZmY7XG4gICAgZDggKz0gaDUgKiByMztcbiAgICBkOCArPSBoNiAqIHIyO1xuICAgIGQ4ICs9IGg3ICogcjE7XG4gICAgZDggKz0gaDggKiByMDtcbiAgICBkOCArPSBoOSAqICg1ICogcjkpO1xuICAgIGMgKz0gKGQ4ID4+PiAxMyk7IGQ4ICY9IDB4MWZmZjtcblxuICAgIGQ5ID0gYztcbiAgICBkOSArPSBoMCAqIHI5O1xuICAgIGQ5ICs9IGgxICogcjg7XG4gICAgZDkgKz0gaDIgKiByNztcbiAgICBkOSArPSBoMyAqIHI2O1xuICAgIGQ5ICs9IGg0ICogcjU7XG4gICAgYyA9IChkOSA+Pj4gMTMpOyBkOSAmPSAweDFmZmY7XG4gICAgZDkgKz0gaDUgKiByNDtcbiAgICBkOSArPSBoNiAqIHIzO1xuICAgIGQ5ICs9IGg3ICogcjI7XG4gICAgZDkgKz0gaDggKiByMTtcbiAgICBkOSArPSBoOSAqIHIwO1xuICAgIGMgKz0gKGQ5ID4+PiAxMyk7IGQ5ICY9IDB4MWZmZjtcblxuICAgIGMgPSAoKChjIDw8IDIpICsgYykpIHwgMDtcbiAgICBjID0gKGMgKyBkMCkgfCAwO1xuICAgIGQwID0gYyAmIDB4MWZmZjtcbiAgICBjID0gKGMgPj4+IDEzKTtcbiAgICBkMSArPSBjO1xuXG4gICAgaDAgPSBkMDtcbiAgICBoMSA9IGQxO1xuICAgIGgyID0gZDI7XG4gICAgaDMgPSBkMztcbiAgICBoNCA9IGQ0O1xuICAgIGg1ID0gZDU7XG4gICAgaDYgPSBkNjtcbiAgICBoNyA9IGQ3O1xuICAgIGg4ID0gZDg7XG4gICAgaDkgPSBkOTtcblxuICAgIG1wb3MgKz0gMTY7XG4gICAgYnl0ZXMgLT0gMTY7XG4gIH1cbiAgdGhpcy5oWzBdID0gaDA7XG4gIHRoaXMuaFsxXSA9IGgxO1xuICB0aGlzLmhbMl0gPSBoMjtcbiAgdGhpcy5oWzNdID0gaDM7XG4gIHRoaXMuaFs0XSA9IGg0O1xuICB0aGlzLmhbNV0gPSBoNTtcbiAgdGhpcy5oWzZdID0gaDY7XG4gIHRoaXMuaFs3XSA9IGg3O1xuICB0aGlzLmhbOF0gPSBoODtcbiAgdGhpcy5oWzldID0gaDk7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24obWFjLCBtYWNwb3MpIHtcbiAgdmFyIGcgPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICB2YXIgYywgbWFzaywgZiwgaTtcblxuICBpZiAodGhpcy5sZWZ0b3Zlcikge1xuICAgIGkgPSB0aGlzLmxlZnRvdmVyO1xuICAgIHRoaXMuYnVmZmVyW2krK10gPSAxO1xuICAgIGZvciAoOyBpIDwgMTY7IGkrKykgdGhpcy5idWZmZXJbaV0gPSAwO1xuICAgIHRoaXMuZmluID0gMTtcbiAgICB0aGlzLmJsb2Nrcyh0aGlzLmJ1ZmZlciwgMCwgMTYpO1xuICB9XG5cbiAgYyA9IHRoaXMuaFsxXSA+Pj4gMTM7XG4gIHRoaXMuaFsxXSAmPSAweDFmZmY7XG4gIGZvciAoaSA9IDI7IGkgPCAxMDsgaSsrKSB7XG4gICAgdGhpcy5oW2ldICs9IGM7XG4gICAgYyA9IHRoaXMuaFtpXSA+Pj4gMTM7XG4gICAgdGhpcy5oW2ldICY9IDB4MWZmZjtcbiAgfVxuICB0aGlzLmhbMF0gKz0gKGMgKiA1KTtcbiAgYyA9IHRoaXMuaFswXSA+Pj4gMTM7XG4gIHRoaXMuaFswXSAmPSAweDFmZmY7XG4gIHRoaXMuaFsxXSArPSBjO1xuICBjID0gdGhpcy5oWzFdID4+PiAxMztcbiAgdGhpcy5oWzFdICY9IDB4MWZmZjtcbiAgdGhpcy5oWzJdICs9IGM7XG5cbiAgZ1swXSA9IHRoaXMuaFswXSArIDU7XG4gIGMgPSBnWzBdID4+PiAxMztcbiAgZ1swXSAmPSAweDFmZmY7XG4gIGZvciAoaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgZ1tpXSA9IHRoaXMuaFtpXSArIGM7XG4gICAgYyA9IGdbaV0gPj4+IDEzO1xuICAgIGdbaV0gJj0gMHgxZmZmO1xuICB9XG4gIGdbOV0gLT0gKDEgPDwgMTMpO1xuXG4gIG1hc2sgPSAoYyBeIDEpIC0gMTtcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIGdbaV0gJj0gbWFzaztcbiAgbWFzayA9IH5tYXNrO1xuICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykgdGhpcy5oW2ldID0gKHRoaXMuaFtpXSAmIG1hc2spIHwgZ1tpXTtcblxuICB0aGlzLmhbMF0gPSAoKHRoaXMuaFswXSAgICAgICApIHwgKHRoaXMuaFsxXSA8PCAxMykgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFsxXSA9ICgodGhpcy5oWzFdID4+PiAgMykgfCAodGhpcy5oWzJdIDw8IDEwKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzJdID0gKCh0aGlzLmhbMl0gPj4+ICA2KSB8ICh0aGlzLmhbM10gPDwgIDcpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbM10gPSAoKHRoaXMuaFszXSA+Pj4gIDkpIHwgKHRoaXMuaFs0XSA8PCAgNCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFs0XSA9ICgodGhpcy5oWzRdID4+PiAxMikgfCAodGhpcy5oWzVdIDw8ICAxKSB8ICh0aGlzLmhbNl0gPDwgMTQpKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzVdID0gKCh0aGlzLmhbNl0gPj4+ICAyKSB8ICh0aGlzLmhbN10gPDwgMTEpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbNl0gPSAoKHRoaXMuaFs3XSA+Pj4gIDUpIHwgKHRoaXMuaFs4XSA8PCAgOCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFs3XSA9ICgodGhpcy5oWzhdID4+PiAgOCkgfCAodGhpcy5oWzldIDw8ICA1KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcblxuICBmID0gdGhpcy5oWzBdICsgdGhpcy5wYWRbMF07XG4gIHRoaXMuaFswXSA9IGYgJiAweGZmZmY7XG4gIGZvciAoaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICBmID0gKCgodGhpcy5oW2ldICsgdGhpcy5wYWRbaV0pIHwgMCkgKyAoZiA+Pj4gMTYpKSB8IDA7XG4gICAgdGhpcy5oW2ldID0gZiAmIDB4ZmZmZjtcbiAgfVxuXG4gIG1hY1ttYWNwb3MrIDBdID0gKHRoaXMuaFswXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAxXSA9ICh0aGlzLmhbMF0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgMl0gPSAodGhpcy5oWzFdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDNdID0gKHRoaXMuaFsxXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA0XSA9ICh0aGlzLmhbMl0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNV0gPSAodGhpcy5oWzJdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDZdID0gKHRoaXMuaFszXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA3XSA9ICh0aGlzLmhbM10gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgOF0gPSAodGhpcy5oWzRdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDldID0gKHRoaXMuaFs0XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEwXSA9ICh0aGlzLmhbNV0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMV0gPSAodGhpcy5oWzVdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTJdID0gKHRoaXMuaFs2XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEzXSA9ICh0aGlzLmhbNl0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxNF0gPSAodGhpcy5oWzddID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTVdID0gKHRoaXMuaFs3XSA+Pj4gOCkgJiAweGZmO1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG0sIG1wb3MsIGJ5dGVzKSB7XG4gIHZhciBpLCB3YW50O1xuXG4gIGlmICh0aGlzLmxlZnRvdmVyKSB7XG4gICAgd2FudCA9ICgxNiAtIHRoaXMubGVmdG92ZXIpO1xuICAgIGlmICh3YW50ID4gYnl0ZXMpXG4gICAgICB3YW50ID0gYnl0ZXM7XG4gICAgZm9yIChpID0gMDsgaSA8IHdhbnQ7IGkrKylcbiAgICAgIHRoaXMuYnVmZmVyW3RoaXMubGVmdG92ZXIgKyBpXSA9IG1bbXBvcytpXTtcbiAgICBieXRlcyAtPSB3YW50O1xuICAgIG1wb3MgKz0gd2FudDtcbiAgICB0aGlzLmxlZnRvdmVyICs9IHdhbnQ7XG4gICAgaWYgKHRoaXMubGVmdG92ZXIgPCAxNilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmJsb2Nrcyh0aGlzLmJ1ZmZlciwgMCwgMTYpO1xuICAgIHRoaXMubGVmdG92ZXIgPSAwO1xuICB9XG5cbiAgaWYgKGJ5dGVzID49IDE2KSB7XG4gICAgd2FudCA9IGJ5dGVzIC0gKGJ5dGVzICUgMTYpO1xuICAgIHRoaXMuYmxvY2tzKG0sIG1wb3MsIHdhbnQpO1xuICAgIG1wb3MgKz0gd2FudDtcbiAgICBieXRlcyAtPSB3YW50O1xuICB9XG5cbiAgaWYgKGJ5dGVzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGJ5dGVzOyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlclt0aGlzLmxlZnRvdmVyICsgaV0gPSBtW21wb3MraV07XG4gICAgdGhpcy5sZWZ0b3ZlciArPSBieXRlcztcbiAgfVxufTtcblxuZnVuY3Rpb24gY3J5cHRvX29uZXRpbWVhdXRoKG91dCwgb3V0cG9zLCBtLCBtcG9zLCBuLCBrKSB7XG4gIHZhciBzID0gbmV3IHBvbHkxMzA1KGspO1xuICBzLnVwZGF0ZShtLCBtcG9zLCBuKTtcbiAgcy5maW5pc2gob3V0LCBvdXRwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeShoLCBocG9zLCBtLCBtcG9zLCBuLCBrKSB7XG4gIHZhciB4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBjcnlwdG9fb25ldGltZWF1dGgoeCwwLG0sbXBvcyxuLGspO1xuICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8xNihoLGhwb3MseCwwKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NlY3JldGJveChjLG0sZCxuLGspIHtcbiAgdmFyIGk7XG4gIGlmIChkIDwgMzIpIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbV94b3IoYywwLG0sMCxkLG4sayk7XG4gIGNyeXB0b19vbmV0aW1lYXV0aChjLCAxNiwgYywgMzIsIGQgLSAzMiwgYyk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSBjW2ldID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3hfb3BlbihtLGMsZCxuLGspIHtcbiAgdmFyIGk7XG4gIHZhciB4ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBpZiAoZCA8IDMyKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW0oeCwwLDMyLG4sayk7XG4gIGlmIChjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5KGMsIDE2LGMsIDMyLGQgLSAzMix4KSAhPT0gMCkgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtX3hvcihtLDAsYywwLGQsbixrKTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIG1baV0gPSAwO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gc2V0MjU1MTkociwgYSkge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHJbaV0gPSBhW2ldfDA7XG59XG5cbmZ1bmN0aW9uIGNhcjI1NTE5KG8pIHtcbiAgdmFyIGksIHYsIGMgPSAxO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHYgPSBvW2ldICsgYyArIDY1NTM1O1xuICAgIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7XG4gICAgb1tpXSA9IHYgLSBjICogNjU1MzY7XG4gIH1cbiAgb1swXSArPSBjLTEgKyAzNyAqIChjLTEpO1xufVxuXG5mdW5jdGlvbiBzZWwyNTUxOShwLCBxLCBiKSB7XG4gIHZhciB0LCBjID0gfihiLTEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB0ID0gYyAmIChwW2ldIF4gcVtpXSk7XG4gICAgcFtpXSBePSB0O1xuICAgIHFbaV0gXj0gdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYWNrMjU1MTkobywgbikge1xuICB2YXIgaSwgaiwgYjtcbiAgdmFyIG0gPSBnZigpLCB0ID0gZ2YoKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHRbaV0gPSBuW2ldO1xuICBjYXIyNTUxOSh0KTtcbiAgY2FyMjU1MTkodCk7XG4gIGNhcjI1NTE5KHQpO1xuICBmb3IgKGogPSAwOyBqIDwgMjsgaisrKSB7XG4gICAgbVswXSA9IHRbMF0gLSAweGZmZWQ7XG4gICAgZm9yIChpID0gMTsgaSA8IDE1OyBpKyspIHtcbiAgICAgIG1baV0gPSB0W2ldIC0gMHhmZmZmIC0gKChtW2ktMV0+PjE2KSAmIDEpO1xuICAgICAgbVtpLTFdICY9IDB4ZmZmZjtcbiAgICB9XG4gICAgbVsxNV0gPSB0WzE1XSAtIDB4N2ZmZiAtICgobVsxNF0+PjE2KSAmIDEpO1xuICAgIGIgPSAobVsxNV0+PjE2KSAmIDE7XG4gICAgbVsxNF0gJj0gMHhmZmZmO1xuICAgIHNlbDI1NTE5KHQsIG0sIDEtYik7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBvWzIqaV0gPSB0W2ldICYgMHhmZjtcbiAgICBvWzIqaSsxXSA9IHRbaV0+Pjg7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmVxMjU1MTkoYSwgYikge1xuICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KDMyKSwgZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgcGFjazI1NTE5KGMsIGEpO1xuICBwYWNrMjU1MTkoZCwgYik7XG4gIHJldHVybiBjcnlwdG9fdmVyaWZ5XzMyKGMsIDAsIGQsIDApO1xufVxuXG5mdW5jdGlvbiBwYXIyNTUxOShhKSB7XG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBwYWNrMjU1MTkoZCwgYSk7XG4gIHJldHVybiBkWzBdICYgMTtcbn1cblxuZnVuY3Rpb24gdW5wYWNrMjU1MTkobywgbikge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBuWzIqaV0gKyAoblsyKmkrMV0gPDwgOCk7XG4gIG9bMTVdICY9IDB4N2ZmZjtcbn1cblxuZnVuY3Rpb24gQShvLCBhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IGFbaV0gKyBiW2ldO1xufVxuXG5mdW5jdGlvbiBaKG8sIGEsIGIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gYVtpXSAtIGJbaV07XG59XG5cbmZ1bmN0aW9uIE0obywgYSwgYikge1xuICB2YXIgdiwgYyxcbiAgICAgdDAgPSAwLCAgdDEgPSAwLCAgdDIgPSAwLCAgdDMgPSAwLCAgdDQgPSAwLCAgdDUgPSAwLCAgdDYgPSAwLCAgdDcgPSAwLFxuICAgICB0OCA9IDAsICB0OSA9IDAsIHQxMCA9IDAsIHQxMSA9IDAsIHQxMiA9IDAsIHQxMyA9IDAsIHQxNCA9IDAsIHQxNSA9IDAsXG4gICAgdDE2ID0gMCwgdDE3ID0gMCwgdDE4ID0gMCwgdDE5ID0gMCwgdDIwID0gMCwgdDIxID0gMCwgdDIyID0gMCwgdDIzID0gMCxcbiAgICB0MjQgPSAwLCB0MjUgPSAwLCB0MjYgPSAwLCB0MjcgPSAwLCB0MjggPSAwLCB0MjkgPSAwLCB0MzAgPSAwLFxuICAgIGIwID0gYlswXSxcbiAgICBiMSA9IGJbMV0sXG4gICAgYjIgPSBiWzJdLFxuICAgIGIzID0gYlszXSxcbiAgICBiNCA9IGJbNF0sXG4gICAgYjUgPSBiWzVdLFxuICAgIGI2ID0gYls2XSxcbiAgICBiNyA9IGJbN10sXG4gICAgYjggPSBiWzhdLFxuICAgIGI5ID0gYls5XSxcbiAgICBiMTAgPSBiWzEwXSxcbiAgICBiMTEgPSBiWzExXSxcbiAgICBiMTIgPSBiWzEyXSxcbiAgICBiMTMgPSBiWzEzXSxcbiAgICBiMTQgPSBiWzE0XSxcbiAgICBiMTUgPSBiWzE1XTtcblxuICB2ID0gYVswXTtcbiAgdDAgKz0gdiAqIGIwO1xuICB0MSArPSB2ICogYjE7XG4gIHQyICs9IHYgKiBiMjtcbiAgdDMgKz0gdiAqIGIzO1xuICB0NCArPSB2ICogYjQ7XG4gIHQ1ICs9IHYgKiBiNTtcbiAgdDYgKz0gdiAqIGI2O1xuICB0NyArPSB2ICogYjc7XG4gIHQ4ICs9IHYgKiBiODtcbiAgdDkgKz0gdiAqIGI5O1xuICB0MTAgKz0gdiAqIGIxMDtcbiAgdDExICs9IHYgKiBiMTE7XG4gIHQxMiArPSB2ICogYjEyO1xuICB0MTMgKz0gdiAqIGIxMztcbiAgdDE0ICs9IHYgKiBiMTQ7XG4gIHQxNSArPSB2ICogYjE1O1xuICB2ID0gYVsxXTtcbiAgdDEgKz0gdiAqIGIwO1xuICB0MiArPSB2ICogYjE7XG4gIHQzICs9IHYgKiBiMjtcbiAgdDQgKz0gdiAqIGIzO1xuICB0NSArPSB2ICogYjQ7XG4gIHQ2ICs9IHYgKiBiNTtcbiAgdDcgKz0gdiAqIGI2O1xuICB0OCArPSB2ICogYjc7XG4gIHQ5ICs9IHYgKiBiODtcbiAgdDEwICs9IHYgKiBiOTtcbiAgdDExICs9IHYgKiBiMTA7XG4gIHQxMiArPSB2ICogYjExO1xuICB0MTMgKz0gdiAqIGIxMjtcbiAgdDE0ICs9IHYgKiBiMTM7XG4gIHQxNSArPSB2ICogYjE0O1xuICB0MTYgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMl07XG4gIHQyICs9IHYgKiBiMDtcbiAgdDMgKz0gdiAqIGIxO1xuICB0NCArPSB2ICogYjI7XG4gIHQ1ICs9IHYgKiBiMztcbiAgdDYgKz0gdiAqIGI0O1xuICB0NyArPSB2ICogYjU7XG4gIHQ4ICs9IHYgKiBiNjtcbiAgdDkgKz0gdiAqIGI3O1xuICB0MTAgKz0gdiAqIGI4O1xuICB0MTEgKz0gdiAqIGI5O1xuICB0MTIgKz0gdiAqIGIxMDtcbiAgdDEzICs9IHYgKiBiMTE7XG4gIHQxNCArPSB2ICogYjEyO1xuICB0MTUgKz0gdiAqIGIxMztcbiAgdDE2ICs9IHYgKiBiMTQ7XG4gIHQxNyArPSB2ICogYjE1O1xuICB2ID0gYVszXTtcbiAgdDMgKz0gdiAqIGIwO1xuICB0NCArPSB2ICogYjE7XG4gIHQ1ICs9IHYgKiBiMjtcbiAgdDYgKz0gdiAqIGIzO1xuICB0NyArPSB2ICogYjQ7XG4gIHQ4ICs9IHYgKiBiNTtcbiAgdDkgKz0gdiAqIGI2O1xuICB0MTAgKz0gdiAqIGI3O1xuICB0MTEgKz0gdiAqIGI4O1xuICB0MTIgKz0gdiAqIGI5O1xuICB0MTMgKz0gdiAqIGIxMDtcbiAgdDE0ICs9IHYgKiBiMTE7XG4gIHQxNSArPSB2ICogYjEyO1xuICB0MTYgKz0gdiAqIGIxMztcbiAgdDE3ICs9IHYgKiBiMTQ7XG4gIHQxOCArPSB2ICogYjE1O1xuICB2ID0gYVs0XTtcbiAgdDQgKz0gdiAqIGIwO1xuICB0NSArPSB2ICogYjE7XG4gIHQ2ICs9IHYgKiBiMjtcbiAgdDcgKz0gdiAqIGIzO1xuICB0OCArPSB2ICogYjQ7XG4gIHQ5ICs9IHYgKiBiNTtcbiAgdDEwICs9IHYgKiBiNjtcbiAgdDExICs9IHYgKiBiNztcbiAgdDEyICs9IHYgKiBiODtcbiAgdDEzICs9IHYgKiBiOTtcbiAgdDE0ICs9IHYgKiBiMTA7XG4gIHQxNSArPSB2ICogYjExO1xuICB0MTYgKz0gdiAqIGIxMjtcbiAgdDE3ICs9IHYgKiBiMTM7XG4gIHQxOCArPSB2ICogYjE0O1xuICB0MTkgKz0gdiAqIGIxNTtcbiAgdiA9IGFbNV07XG4gIHQ1ICs9IHYgKiBiMDtcbiAgdDYgKz0gdiAqIGIxO1xuICB0NyArPSB2ICogYjI7XG4gIHQ4ICs9IHYgKiBiMztcbiAgdDkgKz0gdiAqIGI0O1xuICB0MTAgKz0gdiAqIGI1O1xuICB0MTEgKz0gdiAqIGI2O1xuICB0MTIgKz0gdiAqIGI3O1xuICB0MTMgKz0gdiAqIGI4O1xuICB0MTQgKz0gdiAqIGI5O1xuICB0MTUgKz0gdiAqIGIxMDtcbiAgdDE2ICs9IHYgKiBiMTE7XG4gIHQxNyArPSB2ICogYjEyO1xuICB0MTggKz0gdiAqIGIxMztcbiAgdDE5ICs9IHYgKiBiMTQ7XG4gIHQyMCArPSB2ICogYjE1O1xuICB2ID0gYVs2XTtcbiAgdDYgKz0gdiAqIGIwO1xuICB0NyArPSB2ICogYjE7XG4gIHQ4ICs9IHYgKiBiMjtcbiAgdDkgKz0gdiAqIGIzO1xuICB0MTAgKz0gdiAqIGI0O1xuICB0MTEgKz0gdiAqIGI1O1xuICB0MTIgKz0gdiAqIGI2O1xuICB0MTMgKz0gdiAqIGI3O1xuICB0MTQgKz0gdiAqIGI4O1xuICB0MTUgKz0gdiAqIGI5O1xuICB0MTYgKz0gdiAqIGIxMDtcbiAgdDE3ICs9IHYgKiBiMTE7XG4gIHQxOCArPSB2ICogYjEyO1xuICB0MTkgKz0gdiAqIGIxMztcbiAgdDIwICs9IHYgKiBiMTQ7XG4gIHQyMSArPSB2ICogYjE1O1xuICB2ID0gYVs3XTtcbiAgdDcgKz0gdiAqIGIwO1xuICB0OCArPSB2ICogYjE7XG4gIHQ5ICs9IHYgKiBiMjtcbiAgdDEwICs9IHYgKiBiMztcbiAgdDExICs9IHYgKiBiNDtcbiAgdDEyICs9IHYgKiBiNTtcbiAgdDEzICs9IHYgKiBiNjtcbiAgdDE0ICs9IHYgKiBiNztcbiAgdDE1ICs9IHYgKiBiODtcbiAgdDE2ICs9IHYgKiBiOTtcbiAgdDE3ICs9IHYgKiBiMTA7XG4gIHQxOCArPSB2ICogYjExO1xuICB0MTkgKz0gdiAqIGIxMjtcbiAgdDIwICs9IHYgKiBiMTM7XG4gIHQyMSArPSB2ICogYjE0O1xuICB0MjIgKz0gdiAqIGIxNTtcbiAgdiA9IGFbOF07XG4gIHQ4ICs9IHYgKiBiMDtcbiAgdDkgKz0gdiAqIGIxO1xuICB0MTAgKz0gdiAqIGIyO1xuICB0MTEgKz0gdiAqIGIzO1xuICB0MTIgKz0gdiAqIGI0O1xuICB0MTMgKz0gdiAqIGI1O1xuICB0MTQgKz0gdiAqIGI2O1xuICB0MTUgKz0gdiAqIGI3O1xuICB0MTYgKz0gdiAqIGI4O1xuICB0MTcgKz0gdiAqIGI5O1xuICB0MTggKz0gdiAqIGIxMDtcbiAgdDE5ICs9IHYgKiBiMTE7XG4gIHQyMCArPSB2ICogYjEyO1xuICB0MjEgKz0gdiAqIGIxMztcbiAgdDIyICs9IHYgKiBiMTQ7XG4gIHQyMyArPSB2ICogYjE1O1xuICB2ID0gYVs5XTtcbiAgdDkgKz0gdiAqIGIwO1xuICB0MTAgKz0gdiAqIGIxO1xuICB0MTEgKz0gdiAqIGIyO1xuICB0MTIgKz0gdiAqIGIzO1xuICB0MTMgKz0gdiAqIGI0O1xuICB0MTQgKz0gdiAqIGI1O1xuICB0MTUgKz0gdiAqIGI2O1xuICB0MTYgKz0gdiAqIGI3O1xuICB0MTcgKz0gdiAqIGI4O1xuICB0MTggKz0gdiAqIGI5O1xuICB0MTkgKz0gdiAqIGIxMDtcbiAgdDIwICs9IHYgKiBiMTE7XG4gIHQyMSArPSB2ICogYjEyO1xuICB0MjIgKz0gdiAqIGIxMztcbiAgdDIzICs9IHYgKiBiMTQ7XG4gIHQyNCArPSB2ICogYjE1O1xuICB2ID0gYVsxMF07XG4gIHQxMCArPSB2ICogYjA7XG4gIHQxMSArPSB2ICogYjE7XG4gIHQxMiArPSB2ICogYjI7XG4gIHQxMyArPSB2ICogYjM7XG4gIHQxNCArPSB2ICogYjQ7XG4gIHQxNSArPSB2ICogYjU7XG4gIHQxNiArPSB2ICogYjY7XG4gIHQxNyArPSB2ICogYjc7XG4gIHQxOCArPSB2ICogYjg7XG4gIHQxOSArPSB2ICogYjk7XG4gIHQyMCArPSB2ICogYjEwO1xuICB0MjEgKz0gdiAqIGIxMTtcbiAgdDIyICs9IHYgKiBiMTI7XG4gIHQyMyArPSB2ICogYjEzO1xuICB0MjQgKz0gdiAqIGIxNDtcbiAgdDI1ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzExXTtcbiAgdDExICs9IHYgKiBiMDtcbiAgdDEyICs9IHYgKiBiMTtcbiAgdDEzICs9IHYgKiBiMjtcbiAgdDE0ICs9IHYgKiBiMztcbiAgdDE1ICs9IHYgKiBiNDtcbiAgdDE2ICs9IHYgKiBiNTtcbiAgdDE3ICs9IHYgKiBiNjtcbiAgdDE4ICs9IHYgKiBiNztcbiAgdDE5ICs9IHYgKiBiODtcbiAgdDIwICs9IHYgKiBiOTtcbiAgdDIxICs9IHYgKiBiMTA7XG4gIHQyMiArPSB2ICogYjExO1xuICB0MjMgKz0gdiAqIGIxMjtcbiAgdDI0ICs9IHYgKiBiMTM7XG4gIHQyNSArPSB2ICogYjE0O1xuICB0MjYgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTJdO1xuICB0MTIgKz0gdiAqIGIwO1xuICB0MTMgKz0gdiAqIGIxO1xuICB0MTQgKz0gdiAqIGIyO1xuICB0MTUgKz0gdiAqIGIzO1xuICB0MTYgKz0gdiAqIGI0O1xuICB0MTcgKz0gdiAqIGI1O1xuICB0MTggKz0gdiAqIGI2O1xuICB0MTkgKz0gdiAqIGI3O1xuICB0MjAgKz0gdiAqIGI4O1xuICB0MjEgKz0gdiAqIGI5O1xuICB0MjIgKz0gdiAqIGIxMDtcbiAgdDIzICs9IHYgKiBiMTE7XG4gIHQyNCArPSB2ICogYjEyO1xuICB0MjUgKz0gdiAqIGIxMztcbiAgdDI2ICs9IHYgKiBiMTQ7XG4gIHQyNyArPSB2ICogYjE1O1xuICB2ID0gYVsxM107XG4gIHQxMyArPSB2ICogYjA7XG4gIHQxNCArPSB2ICogYjE7XG4gIHQxNSArPSB2ICogYjI7XG4gIHQxNiArPSB2ICogYjM7XG4gIHQxNyArPSB2ICogYjQ7XG4gIHQxOCArPSB2ICogYjU7XG4gIHQxOSArPSB2ICogYjY7XG4gIHQyMCArPSB2ICogYjc7XG4gIHQyMSArPSB2ICogYjg7XG4gIHQyMiArPSB2ICogYjk7XG4gIHQyMyArPSB2ICogYjEwO1xuICB0MjQgKz0gdiAqIGIxMTtcbiAgdDI1ICs9IHYgKiBiMTI7XG4gIHQyNiArPSB2ICogYjEzO1xuICB0MjcgKz0gdiAqIGIxNDtcbiAgdDI4ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzE0XTtcbiAgdDE0ICs9IHYgKiBiMDtcbiAgdDE1ICs9IHYgKiBiMTtcbiAgdDE2ICs9IHYgKiBiMjtcbiAgdDE3ICs9IHYgKiBiMztcbiAgdDE4ICs9IHYgKiBiNDtcbiAgdDE5ICs9IHYgKiBiNTtcbiAgdDIwICs9IHYgKiBiNjtcbiAgdDIxICs9IHYgKiBiNztcbiAgdDIyICs9IHYgKiBiODtcbiAgdDIzICs9IHYgKiBiOTtcbiAgdDI0ICs9IHYgKiBiMTA7XG4gIHQyNSArPSB2ICogYjExO1xuICB0MjYgKz0gdiAqIGIxMjtcbiAgdDI3ICs9IHYgKiBiMTM7XG4gIHQyOCArPSB2ICogYjE0O1xuICB0MjkgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTVdO1xuICB0MTUgKz0gdiAqIGIwO1xuICB0MTYgKz0gdiAqIGIxO1xuICB0MTcgKz0gdiAqIGIyO1xuICB0MTggKz0gdiAqIGIzO1xuICB0MTkgKz0gdiAqIGI0O1xuICB0MjAgKz0gdiAqIGI1O1xuICB0MjEgKz0gdiAqIGI2O1xuICB0MjIgKz0gdiAqIGI3O1xuICB0MjMgKz0gdiAqIGI4O1xuICB0MjQgKz0gdiAqIGI5O1xuICB0MjUgKz0gdiAqIGIxMDtcbiAgdDI2ICs9IHYgKiBiMTE7XG4gIHQyNyArPSB2ICogYjEyO1xuICB0MjggKz0gdiAqIGIxMztcbiAgdDI5ICs9IHYgKiBiMTQ7XG4gIHQzMCArPSB2ICogYjE1O1xuXG4gIHQwICArPSAzOCAqIHQxNjtcbiAgdDEgICs9IDM4ICogdDE3O1xuICB0MiAgKz0gMzggKiB0MTg7XG4gIHQzICArPSAzOCAqIHQxOTtcbiAgdDQgICs9IDM4ICogdDIwO1xuICB0NSAgKz0gMzggKiB0MjE7XG4gIHQ2ICArPSAzOCAqIHQyMjtcbiAgdDcgICs9IDM4ICogdDIzO1xuICB0OCAgKz0gMzggKiB0MjQ7XG4gIHQ5ICArPSAzOCAqIHQyNTtcbiAgdDEwICs9IDM4ICogdDI2O1xuICB0MTEgKz0gMzggKiB0Mjc7XG4gIHQxMiArPSAzOCAqIHQyODtcbiAgdDEzICs9IDM4ICogdDI5O1xuICB0MTQgKz0gMzggKiB0MzA7XG4gIC8vIHQxNSBsZWZ0IGFzIGlzXG5cbiAgLy8gZmlyc3QgY2FyXG4gIGMgPSAxO1xuICB2ID0gIHQwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQxICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDUgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ2ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDYgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ3ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDcgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ4ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDggPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ5ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDkgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDExICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTUgPSB2IC0gYyAqIDY1NTM2O1xuICB0MCArPSBjLTEgKyAzNyAqIChjLTEpO1xuXG4gIC8vIHNlY29uZCBjYXJcbiAgYyA9IDE7XG4gIHYgPSAgdDAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDYgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDcgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDggKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDkgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNSA9IHYgLSBjICogNjU1MzY7XG4gIHQwICs9IGMtMSArIDM3ICogKGMtMSk7XG5cbiAgb1sgMF0gPSB0MDtcbiAgb1sgMV0gPSB0MTtcbiAgb1sgMl0gPSB0MjtcbiAgb1sgM10gPSB0MztcbiAgb1sgNF0gPSB0NDtcbiAgb1sgNV0gPSB0NTtcbiAgb1sgNl0gPSB0NjtcbiAgb1sgN10gPSB0NztcbiAgb1sgOF0gPSB0ODtcbiAgb1sgOV0gPSB0OTtcbiAgb1sxMF0gPSB0MTA7XG4gIG9bMTFdID0gdDExO1xuICBvWzEyXSA9IHQxMjtcbiAgb1sxM10gPSB0MTM7XG4gIG9bMTRdID0gdDE0O1xuICBvWzE1XSA9IHQxNTtcbn1cblxuZnVuY3Rpb24gUyhvLCBhKSB7XG4gIE0obywgYSwgYSk7XG59XG5cbmZ1bmN0aW9uIGludjI1NTE5KG8sIGkpIHtcbiAgdmFyIGMgPSBnZigpO1xuICB2YXIgYTtcbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIGNbYV0gPSBpW2FdO1xuICBmb3IgKGEgPSAyNTM7IGEgPj0gMDsgYS0tKSB7XG4gICAgUyhjLCBjKTtcbiAgICBpZihhICE9PSAyICYmIGEgIT09IDQpIE0oYywgYywgaSk7XG4gIH1cbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIG9bYV0gPSBjW2FdO1xufVxuXG5mdW5jdGlvbiBwb3cyNTIzKG8sIGkpIHtcbiAgdmFyIGMgPSBnZigpO1xuICB2YXIgYTtcbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIGNbYV0gPSBpW2FdO1xuICBmb3IgKGEgPSAyNTA7IGEgPj0gMDsgYS0tKSB7XG4gICAgICBTKGMsIGMpO1xuICAgICAgaWYoYSAhPT0gMSkgTShjLCBjLCBpKTtcbiAgfVxuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKykgb1thXSA9IGNbYV07XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIHApIHtcbiAgdmFyIHogPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHZhciB4ID0gbmV3IEZsb2F0NjRBcnJheSg4MCksIHIsIGk7XG4gIHZhciBhID0gZ2YoKSwgYiA9IGdmKCksIGMgPSBnZigpLFxuICAgICAgZCA9IGdmKCksIGUgPSBnZigpLCBmID0gZ2YoKTtcbiAgZm9yIChpID0gMDsgaSA8IDMxOyBpKyspIHpbaV0gPSBuW2ldO1xuICB6WzMxXT0oblszMV0mMTI3KXw2NDtcbiAgelswXSY9MjQ4O1xuICB1bnBhY2syNTUxOSh4LHApO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGJbaV09eFtpXTtcbiAgICBkW2ldPWFbaV09Y1tpXT0wO1xuICB9XG4gIGFbMF09ZFswXT0xO1xuICBmb3IgKGk9MjU0OyBpPj0wOyAtLWkpIHtcbiAgICByPSh6W2k+Pj4zXT4+PihpJjcpKSYxO1xuICAgIHNlbDI1NTE5KGEsYixyKTtcbiAgICBzZWwyNTUxOShjLGQscik7XG4gICAgQShlLGEsYyk7XG4gICAgWihhLGEsYyk7XG4gICAgQShjLGIsZCk7XG4gICAgWihiLGIsZCk7XG4gICAgUyhkLGUpO1xuICAgIFMoZixhKTtcbiAgICBNKGEsYyxhKTtcbiAgICBNKGMsYixlKTtcbiAgICBBKGUsYSxjKTtcbiAgICBaKGEsYSxjKTtcbiAgICBTKGIsYSk7XG4gICAgWihjLGQsZik7XG4gICAgTShhLGMsXzEyMTY2NSk7XG4gICAgQShhLGEsZCk7XG4gICAgTShjLGMsYSk7XG4gICAgTShhLGQsZik7XG4gICAgTShkLGIseCk7XG4gICAgUyhiLGUpO1xuICAgIHNlbDI1NTE5KGEsYixyKTtcbiAgICBzZWwyNTUxOShjLGQscik7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB4W2krMTZdPWFbaV07XG4gICAgeFtpKzMyXT1jW2ldO1xuICAgIHhbaSs0OF09YltpXTtcbiAgICB4W2krNjRdPWRbaV07XG4gIH1cbiAgdmFyIHgzMiA9IHguc3ViYXJyYXkoMzIpO1xuICB2YXIgeDE2ID0geC5zdWJhcnJheSgxNik7XG4gIGludjI1NTE5KHgzMix4MzIpO1xuICBNKHgxNix4MTYseDMyKTtcbiAgcGFjazI1NTE5KHEseDE2KTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocSwgbikge1xuICByZXR1cm4gY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgXzkpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fYm94X2tleXBhaXIoeSwgeCkge1xuICByYW5kb21ieXRlcyh4LCAzMik7XG4gIHJldHVybiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHksIHgpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpIHtcbiAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19zY2FsYXJtdWx0KHMsIHgsIHkpO1xuICByZXR1cm4gY3J5cHRvX2NvcmVfaHNhbHNhMjAoaywgXzAsIHMsIHNpZ21hKTtcbn1cblxudmFyIGNyeXB0b19ib3hfYWZ0ZXJubSA9IGNyeXB0b19zZWNyZXRib3g7XG52YXIgY3J5cHRvX2JveF9vcGVuX2FmdGVybm0gPSBjcnlwdG9fc2VjcmV0Ym94X29wZW47XG5cbmZ1bmN0aW9uIGNyeXB0b19ib3goYywgbSwgZCwgbiwgeSwgeCkge1xuICB2YXIgayA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KTtcbiAgcmV0dXJuIGNyeXB0b19ib3hfYWZ0ZXJubShjLCBtLCBkLCBuLCBrKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9vcGVuKG0sIGMsIGQsIG4sIHksIHgpIHtcbiAgdmFyIGsgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCk7XG4gIHJldHVybiBjcnlwdG9fYm94X29wZW5fYWZ0ZXJubShtLCBjLCBkLCBuLCBrKTtcbn1cblxudmFyIEsgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl07XG5cbmZ1bmN0aW9uIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgbSwgbikge1xuICB2YXIgd2ggPSBuZXcgSW50MzJBcnJheSgxNiksIHdsID0gbmV3IEludDMyQXJyYXkoMTYpLFxuICAgICAgYmgwLCBiaDEsIGJoMiwgYmgzLCBiaDQsIGJoNSwgYmg2LCBiaDcsXG4gICAgICBibDAsIGJsMSwgYmwyLCBibDMsIGJsNCwgYmw1LCBibDYsIGJsNyxcbiAgICAgIHRoLCB0bCwgaSwgaiwgaCwgbCwgYSwgYiwgYywgZDtcblxuICB2YXIgYWgwID0gaGhbMF0sXG4gICAgICBhaDEgPSBoaFsxXSxcbiAgICAgIGFoMiA9IGhoWzJdLFxuICAgICAgYWgzID0gaGhbM10sXG4gICAgICBhaDQgPSBoaFs0XSxcbiAgICAgIGFoNSA9IGhoWzVdLFxuICAgICAgYWg2ID0gaGhbNl0sXG4gICAgICBhaDcgPSBoaFs3XSxcblxuICAgICAgYWwwID0gaGxbMF0sXG4gICAgICBhbDEgPSBobFsxXSxcbiAgICAgIGFsMiA9IGhsWzJdLFxuICAgICAgYWwzID0gaGxbM10sXG4gICAgICBhbDQgPSBobFs0XSxcbiAgICAgIGFsNSA9IGhsWzVdLFxuICAgICAgYWw2ID0gaGxbNl0sXG4gICAgICBhbDcgPSBobFs3XTtcblxuICB2YXIgcG9zID0gMDtcbiAgd2hpbGUgKG4gPj0gMTI4KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGogPSA4ICogaSArIHBvcztcbiAgICAgIHdoW2ldID0gKG1baiswXSA8PCAyNCkgfCAobVtqKzFdIDw8IDE2KSB8IChtW2orMl0gPDwgOCkgfCBtW2orM107XG4gICAgICB3bFtpXSA9IChtW2orNF0gPDwgMjQpIHwgKG1bais1XSA8PCAxNikgfCAobVtqKzZdIDw8IDgpIHwgbVtqKzddO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgYmgwID0gYWgwO1xuICAgICAgYmgxID0gYWgxO1xuICAgICAgYmgyID0gYWgyO1xuICAgICAgYmgzID0gYWgzO1xuICAgICAgYmg0ID0gYWg0O1xuICAgICAgYmg1ID0gYWg1O1xuICAgICAgYmg2ID0gYWg2O1xuICAgICAgYmg3ID0gYWg3O1xuXG4gICAgICBibDAgPSBhbDA7XG4gICAgICBibDEgPSBhbDE7XG4gICAgICBibDIgPSBhbDI7XG4gICAgICBibDMgPSBhbDM7XG4gICAgICBibDQgPSBhbDQ7XG4gICAgICBibDUgPSBhbDU7XG4gICAgICBibDYgPSBhbDY7XG4gICAgICBibDcgPSBhbDc7XG5cbiAgICAgIC8vIGFkZFxuICAgICAgaCA9IGFoNztcbiAgICAgIGwgPSBhbDc7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAvLyBTaWdtYTFcbiAgICAgIGggPSAoKGFoNCA+Pj4gMTQpIHwgKGFsNCA8PCAoMzItMTQpKSkgXiAoKGFoNCA+Pj4gMTgpIHwgKGFsNCA8PCAoMzItMTgpKSkgXiAoKGFsNCA+Pj4gKDQxLTMyKSkgfCAoYWg0IDw8ICgzMi0oNDEtMzIpKSkpO1xuICAgICAgbCA9ICgoYWw0ID4+PiAxNCkgfCAoYWg0IDw8ICgzMi0xNCkpKSBeICgoYWw0ID4+PiAxOCkgfCAoYWg0IDw8ICgzMi0xOCkpKSBeICgoYWg0ID4+PiAoNDEtMzIpKSB8IChhbDQgPDwgKDMyLSg0MS0zMikpKSk7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gQ2hcbiAgICAgIGggPSAoYWg0ICYgYWg1KSBeICh+YWg0ICYgYWg2KTtcbiAgICAgIGwgPSAoYWw0ICYgYWw1KSBeICh+YWw0ICYgYWw2KTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBLXG4gICAgICBoID0gS1tpKjJdO1xuICAgICAgbCA9IEtbaSoyKzFdO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIHdcbiAgICAgIGggPSB3aFtpJTE2XTtcbiAgICAgIGwgPSB3bFtpJTE2XTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICAgIHRoID0gYyAmIDB4ZmZmZiB8IGQgPDwgMTY7XG4gICAgICB0bCA9IGEgJiAweGZmZmYgfCBiIDw8IDE2O1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSB0aDtcbiAgICAgIGwgPSB0bDtcblxuICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIFNpZ21hMFxuICAgICAgaCA9ICgoYWgwID4+PiAyOCkgfCAoYWwwIDw8ICgzMi0yOCkpKSBeICgoYWwwID4+PiAoMzQtMzIpKSB8IChhaDAgPDwgKDMyLSgzNC0zMikpKSkgXiAoKGFsMCA+Pj4gKDM5LTMyKSkgfCAoYWgwIDw8ICgzMi0oMzktMzIpKSkpO1xuICAgICAgbCA9ICgoYWwwID4+PiAyOCkgfCAoYWgwIDw8ICgzMi0yOCkpKSBeICgoYWgwID4+PiAoMzQtMzIpKSB8IChhbDAgPDwgKDMyLSgzNC0zMikpKSkgXiAoKGFoMCA+Pj4gKDM5LTMyKSkgfCAoYWwwIDw8ICgzMi0oMzktMzIpKSkpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIE1halxuICAgICAgaCA9IChhaDAgJiBhaDEpIF4gKGFoMCAmIGFoMikgXiAoYWgxICYgYWgyKTtcbiAgICAgIGwgPSAoYWwwICYgYWwxKSBeIChhbDAgJiBhbDIpIF4gKGFsMSAmIGFsMik7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICBiaDcgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgICBibDcgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICAgIC8vIGFkZFxuICAgICAgaCA9IGJoMztcbiAgICAgIGwgPSBibDM7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICBoID0gdGg7XG4gICAgICBsID0gdGw7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICBiaDMgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgICBibDMgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICAgIGFoMSA9IGJoMDtcbiAgICAgIGFoMiA9IGJoMTtcbiAgICAgIGFoMyA9IGJoMjtcbiAgICAgIGFoNCA9IGJoMztcbiAgICAgIGFoNSA9IGJoNDtcbiAgICAgIGFoNiA9IGJoNTtcbiAgICAgIGFoNyA9IGJoNjtcbiAgICAgIGFoMCA9IGJoNztcblxuICAgICAgYWwxID0gYmwwO1xuICAgICAgYWwyID0gYmwxO1xuICAgICAgYWwzID0gYmwyO1xuICAgICAgYWw0ID0gYmwzO1xuICAgICAgYWw1ID0gYmw0O1xuICAgICAgYWw2ID0gYmw1O1xuICAgICAgYWw3ID0gYmw2O1xuICAgICAgYWwwID0gYmw3O1xuXG4gICAgICBpZiAoaSUxNiA9PT0gMTUpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAvLyBhZGRcbiAgICAgICAgICBoID0gd2hbal07XG4gICAgICAgICAgbCA9IHdsW2pdO1xuXG4gICAgICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAgICAgaCA9IHdoWyhqKzkpJTE2XTtcbiAgICAgICAgICBsID0gd2xbKGorOSklMTZdO1xuXG4gICAgICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgICAgIC8vIHNpZ21hMFxuICAgICAgICAgIHRoID0gd2hbKGorMSklMTZdO1xuICAgICAgICAgIHRsID0gd2xbKGorMSklMTZdO1xuICAgICAgICAgIGggPSAoKHRoID4+PiAxKSB8ICh0bCA8PCAoMzItMSkpKSBeICgodGggPj4+IDgpIHwgKHRsIDw8ICgzMi04KSkpIF4gKHRoID4+PiA3KTtcbiAgICAgICAgICBsID0gKCh0bCA+Pj4gMSkgfCAodGggPDwgKDMyLTEpKSkgXiAoKHRsID4+PiA4KSB8ICh0aCA8PCAoMzItOCkpKSBeICgodGwgPj4+IDcpIHwgKHRoIDw8ICgzMi03KSkpO1xuXG4gICAgICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgICAgIC8vIHNpZ21hMVxuICAgICAgICAgIHRoID0gd2hbKGorMTQpJTE2XTtcbiAgICAgICAgICB0bCA9IHdsWyhqKzE0KSUxNl07XG4gICAgICAgICAgaCA9ICgodGggPj4+IDE5KSB8ICh0bCA8PCAoMzItMTkpKSkgXiAoKHRsID4+PiAoNjEtMzIpKSB8ICh0aCA8PCAoMzItKDYxLTMyKSkpKSBeICh0aCA+Pj4gNik7XG4gICAgICAgICAgbCA9ICgodGwgPj4+IDE5KSB8ICh0aCA8PCAoMzItMTkpKSkgXiAoKHRoID4+PiAoNjEtMzIpKSB8ICh0bCA8PCAoMzItKDYxLTMyKSkpKSBeICgodGwgPj4+IDYpIHwgKHRoIDw8ICgzMi02KSkpO1xuXG4gICAgICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICAgICAgd2hbal0gPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgICAgICAgd2xbal0gPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGRcbiAgICBoID0gYWgwO1xuICAgIGwgPSBhbDA7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbMF07XG4gICAgbCA9IGhsWzBdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbMF0gPSBhaDAgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbMF0gPSBhbDAgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWgxO1xuICAgIGwgPSBhbDE7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbMV07XG4gICAgbCA9IGhsWzFdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbMV0gPSBhaDEgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbMV0gPSBhbDEgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWgyO1xuICAgIGwgPSBhbDI7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbMl07XG4gICAgbCA9IGhsWzJdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbMl0gPSBhaDIgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbMl0gPSBhbDIgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWgzO1xuICAgIGwgPSBhbDM7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbM107XG4gICAgbCA9IGhsWzNdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbM10gPSBhaDMgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbM10gPSBhbDMgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg0O1xuICAgIGwgPSBhbDQ7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbNF07XG4gICAgbCA9IGhsWzRdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbNF0gPSBhaDQgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbNF0gPSBhbDQgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg1O1xuICAgIGwgPSBhbDU7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbNV07XG4gICAgbCA9IGhsWzVdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbNV0gPSBhaDUgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbNV0gPSBhbDUgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg2O1xuICAgIGwgPSBhbDY7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbNl07XG4gICAgbCA9IGhsWzZdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbNl0gPSBhaDYgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbNl0gPSBhbDYgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg3O1xuICAgIGwgPSBhbDc7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbN107XG4gICAgbCA9IGhsWzddO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbN10gPSBhaDcgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbN10gPSBhbDcgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBwb3MgKz0gMTI4O1xuICAgIG4gLT0gMTI4O1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19oYXNoKG91dCwgbSwgbikge1xuICB2YXIgaGggPSBuZXcgSW50MzJBcnJheSg4KSxcbiAgICAgIGhsID0gbmV3IEludDMyQXJyYXkoOCksXG4gICAgICB4ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KSxcbiAgICAgIGksIGIgPSBuO1xuXG4gIGhoWzBdID0gMHg2YTA5ZTY2NztcbiAgaGhbMV0gPSAweGJiNjdhZTg1O1xuICBoaFsyXSA9IDB4M2M2ZWYzNzI7XG4gIGhoWzNdID0gMHhhNTRmZjUzYTtcbiAgaGhbNF0gPSAweDUxMGU1MjdmO1xuICBoaFs1XSA9IDB4OWIwNTY4OGM7XG4gIGhoWzZdID0gMHgxZjgzZDlhYjtcbiAgaGhbN10gPSAweDViZTBjZDE5O1xuXG4gIGhsWzBdID0gMHhmM2JjYzkwODtcbiAgaGxbMV0gPSAweDg0Y2FhNzNiO1xuICBobFsyXSA9IDB4ZmU5NGY4MmI7XG4gIGhsWzNdID0gMHg1ZjFkMzZmMTtcbiAgaGxbNF0gPSAweGFkZTY4MmQxO1xuICBobFs1XSA9IDB4MmIzZTZjMWY7XG4gIGhsWzZdID0gMHhmYjQxYmQ2YjtcbiAgaGxbN10gPSAweDEzN2UyMTc5O1xuXG4gIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgbSwgbik7XG4gIG4gJT0gMTI4O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHhbaV0gPSBtW2ItbitpXTtcbiAgeFtuXSA9IDEyODtcblxuICBuID0gMjU2LTEyOCoobjwxMTI/MTowKTtcbiAgeFtuLTldID0gMDtcbiAgdHM2NCh4LCBuLTgsICAoYiAvIDB4MjAwMDAwMDApIHwgMCwgYiA8PCAzKTtcbiAgY3J5cHRvX2hhc2hibG9ja3NfaGwoaGgsIGhsLCB4LCBuKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB0czY0KG91dCwgOCppLCBoaFtpXSwgaGxbaV0pO1xuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBhZGQocCwgcSkge1xuICB2YXIgYSA9IGdmKCksIGIgPSBnZigpLCBjID0gZ2YoKSxcbiAgICAgIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCksXG4gICAgICBnID0gZ2YoKSwgaCA9IGdmKCksIHQgPSBnZigpO1xuXG4gIFooYSwgcFsxXSwgcFswXSk7XG4gIFoodCwgcVsxXSwgcVswXSk7XG4gIE0oYSwgYSwgdCk7XG4gIEEoYiwgcFswXSwgcFsxXSk7XG4gIEEodCwgcVswXSwgcVsxXSk7XG4gIE0oYiwgYiwgdCk7XG4gIE0oYywgcFszXSwgcVszXSk7XG4gIE0oYywgYywgRDIpO1xuICBNKGQsIHBbMl0sIHFbMl0pO1xuICBBKGQsIGQsIGQpO1xuICBaKGUsIGIsIGEpO1xuICBaKGYsIGQsIGMpO1xuICBBKGcsIGQsIGMpO1xuICBBKGgsIGIsIGEpO1xuXG4gIE0ocFswXSwgZSwgZik7XG4gIE0ocFsxXSwgaCwgZyk7XG4gIE0ocFsyXSwgZywgZik7XG4gIE0ocFszXSwgZSwgaCk7XG59XG5cbmZ1bmN0aW9uIGNzd2FwKHAsIHEsIGIpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBzZWwyNTUxOShwW2ldLCBxW2ldLCBiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYWNrKHIsIHApIHtcbiAgdmFyIHR4ID0gZ2YoKSwgdHkgPSBnZigpLCB6aSA9IGdmKCk7XG4gIGludjI1NTE5KHppLCBwWzJdKTtcbiAgTSh0eCwgcFswXSwgemkpO1xuICBNKHR5LCBwWzFdLCB6aSk7XG4gIHBhY2syNTUxOShyLCB0eSk7XG4gIHJbMzFdIF49IHBhcjI1NTE5KHR4KSA8PCA3O1xufVxuXG5mdW5jdGlvbiBzY2FsYXJtdWx0KHAsIHEsIHMpIHtcbiAgdmFyIGIsIGk7XG4gIHNldDI1NTE5KHBbMF0sIGdmMCk7XG4gIHNldDI1NTE5KHBbMV0sIGdmMSk7XG4gIHNldDI1NTE5KHBbMl0sIGdmMSk7XG4gIHNldDI1NTE5KHBbM10sIGdmMCk7XG4gIGZvciAoaSA9IDI1NTsgaSA+PSAwOyAtLWkpIHtcbiAgICBiID0gKHNbKGkvOCl8MF0gPj4gKGkmNykpICYgMTtcbiAgICBjc3dhcChwLCBxLCBiKTtcbiAgICBhZGQocSwgcCk7XG4gICAgYWRkKHAsIHApO1xuICAgIGNzd2FwKHAsIHEsIGIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjYWxhcmJhc2UocCwgcykge1xuICB2YXIgcSA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcbiAgc2V0MjU1MTkocVswXSwgWCk7XG4gIHNldDI1NTE5KHFbMV0sIFkpO1xuICBzZXQyNTUxOShxWzJdLCBnZjEpO1xuICBNKHFbM10sIFgsIFkpO1xuICBzY2FsYXJtdWx0KHAsIHEsIHMpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgc2VlZGVkKSB7XG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcbiAgdmFyIGk7XG5cbiAgaWYgKCFzZWVkZWQpIHJhbmRvbWJ5dGVzKHNrLCAzMik7XG4gIGNyeXB0b19oYXNoKGQsIHNrLCAzMik7XG4gIGRbMF0gJj0gMjQ4O1xuICBkWzMxXSAmPSAxMjc7XG4gIGRbMzFdIHw9IDY0O1xuXG4gIHNjYWxhcmJhc2UocCwgZCk7XG4gIHBhY2socGssIHApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBza1tpKzMyXSA9IHBrW2ldO1xuICByZXR1cm4gMDtcbn1cblxudmFyIEwgPSBuZXcgRmxvYXQ2NEFycmF5KFsweGVkLCAweGQzLCAweGY1LCAweDVjLCAweDFhLCAweDYzLCAweDEyLCAweDU4LCAweGQ2LCAweDljLCAweGY3LCAweGEyLCAweGRlLCAweGY5LCAweGRlLCAweDE0LCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDEwXSk7XG5cbmZ1bmN0aW9uIG1vZEwociwgeCkge1xuICB2YXIgY2FycnksIGksIGosIGs7XG4gIGZvciAoaSA9IDYzOyBpID49IDMyOyAtLWkpIHtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChqID0gaSAtIDMyLCBrID0gaSAtIDEyOyBqIDwgazsgKytqKSB7XG4gICAgICB4W2pdICs9IGNhcnJ5IC0gMTYgKiB4W2ldICogTFtqIC0gKGkgLSAzMildO1xuICAgICAgY2FycnkgPSBNYXRoLmZsb29yKCh4W2pdICsgMTI4KSAvIDI1Nik7XG4gICAgICB4W2pdIC09IGNhcnJ5ICogMjU2O1xuICAgIH1cbiAgICB4W2pdICs9IGNhcnJ5O1xuICAgIHhbaV0gPSAwO1xuICB9XG4gIGNhcnJ5ID0gMDtcbiAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHtcbiAgICB4W2pdICs9IGNhcnJ5IC0gKHhbMzFdID4+IDQpICogTFtqXTtcbiAgICBjYXJyeSA9IHhbal0gPj4gODtcbiAgICB4W2pdICY9IDI1NTtcbiAgfVxuICBmb3IgKGogPSAwOyBqIDwgMzI7IGorKykgeFtqXSAtPSBjYXJyeSAqIExbal07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgeFtpKzFdICs9IHhbaV0gPj4gODtcbiAgICByW2ldID0geFtpXSAmIDI1NTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2Uocikge1xuICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpLCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgeFtpXSA9IHJbaV07XG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSByW2ldID0gMDtcbiAgbW9kTChyLCB4KTtcbn1cblxuLy8gTm90ZTogZGlmZmVyZW5jZSBmcm9tIEMgLSBzbWxlbiByZXR1cm5lZCwgbm90IHBhc3NlZCBhcyBhcmd1bWVudC5cbmZ1bmN0aW9uIGNyeXB0b19zaWduKHNtLCBtLCBuLCBzaykge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDY0KSwgaCA9IG5ldyBVaW50OEFycmF5KDY0KSwgciA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIGksIGosIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG5cbiAgY3J5cHRvX2hhc2goZCwgc2ssIDMyKTtcbiAgZFswXSAmPSAyNDg7XG4gIGRbMzFdICY9IDEyNztcbiAgZFszMV0gfD0gNjQ7XG5cbiAgdmFyIHNtbGVuID0gbiArIDY0O1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBzbVs2NCArIGldID0gbVtpXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHNtWzMyICsgaV0gPSBkWzMyICsgaV07XG5cbiAgY3J5cHRvX2hhc2gociwgc20uc3ViYXJyYXkoMzIpLCBuKzMyKTtcbiAgcmVkdWNlKHIpO1xuICBzY2FsYXJiYXNlKHAsIHIpO1xuICBwYWNrKHNtLCBwKTtcblxuICBmb3IgKGkgPSAzMjsgaSA8IDY0OyBpKyspIHNtW2ldID0gc2tbaV07XG4gIGNyeXB0b19oYXNoKGgsIHNtLCBuICsgNjQpO1xuICByZWR1Y2UoaCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHhbaV0gPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgeFtpXSA9IHJbaV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHtcbiAgICAgIHhbaStqXSArPSBoW2ldICogZFtqXTtcbiAgICB9XG4gIH1cblxuICBtb2RMKHNtLnN1YmFycmF5KDMyKSwgeCk7XG4gIHJldHVybiBzbWxlbjtcbn1cblxuZnVuY3Rpb24gdW5wYWNrbmVnKHIsIHApIHtcbiAgdmFyIHQgPSBnZigpLCBjaGsgPSBnZigpLCBudW0gPSBnZigpLFxuICAgICAgZGVuID0gZ2YoKSwgZGVuMiA9IGdmKCksIGRlbjQgPSBnZigpLFxuICAgICAgZGVuNiA9IGdmKCk7XG5cbiAgc2V0MjU1MTkoclsyXSwgZ2YxKTtcbiAgdW5wYWNrMjU1MTkoclsxXSwgcCk7XG4gIFMobnVtLCByWzFdKTtcbiAgTShkZW4sIG51bSwgRCk7XG4gIFoobnVtLCBudW0sIHJbMl0pO1xuICBBKGRlbiwgclsyXSwgZGVuKTtcblxuICBTKGRlbjIsIGRlbik7XG4gIFMoZGVuNCwgZGVuMik7XG4gIE0oZGVuNiwgZGVuNCwgZGVuMik7XG4gIE0odCwgZGVuNiwgbnVtKTtcbiAgTSh0LCB0LCBkZW4pO1xuXG4gIHBvdzI1MjModCwgdCk7XG4gIE0odCwgdCwgbnVtKTtcbiAgTSh0LCB0LCBkZW4pO1xuICBNKHQsIHQsIGRlbik7XG4gIE0oclswXSwgdCwgZGVuKTtcblxuICBTKGNoaywgclswXSk7XG4gIE0oY2hrLCBjaGssIGRlbik7XG4gIGlmIChuZXEyNTUxOShjaGssIG51bSkpIE0oclswXSwgclswXSwgSSk7XG5cbiAgUyhjaGssIHJbMF0pO1xuICBNKGNoaywgY2hrLCBkZW4pO1xuICBpZiAobmVxMjU1MTkoY2hrLCBudW0pKSByZXR1cm4gLTE7XG5cbiAgaWYgKHBhcjI1NTE5KHJbMF0pID09PSAocFszMV0+PjcpKSBaKHJbMF0sIGdmMCwgclswXSk7XG5cbiAgTShyWzNdLCByWzBdLCByWzFdKTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zaWduX29wZW4obSwgc20sIG4sIHBrKSB7XG4gIHZhciBpO1xuICB2YXIgdCA9IG5ldyBVaW50OEFycmF5KDMyKSwgaCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV0sXG4gICAgICBxID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuXG4gIGlmIChuIDwgNjQpIHJldHVybiAtMTtcblxuICBpZiAodW5wYWNrbmVnKHEsIHBrKSkgcmV0dXJuIC0xO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIG1baV0gPSBzbVtpXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIG1baSszMl0gPSBwa1tpXTtcbiAgY3J5cHRvX2hhc2goaCwgbSwgbik7XG4gIHJlZHVjZShoKTtcbiAgc2NhbGFybXVsdChwLCBxLCBoKTtcblxuICBzY2FsYXJiYXNlKHEsIHNtLnN1YmFycmF5KDMyKSk7XG4gIGFkZChwLCBxKTtcbiAgcGFjayh0LCBwKTtcblxuICBuIC09IDY0O1xuICBpZiAoY3J5cHRvX3ZlcmlmeV8zMihzbSwgMCwgdCwgMCkpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBtW2ldID0gMDtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBtW2ldID0gc21baSArIDY0XTtcbiAgcmV0dXJuIG47XG59XG5cbnZhciBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTID0gMjQsXG4gICAgY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyA9IDE2LFxuICAgIGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfTk9OQ0VCWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyxcbiAgICBjcnlwdG9fYm94X1pFUk9CWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTLFxuICAgIGNyeXB0b19ib3hfQk9YWkVST0JZVEVTID0gY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMsXG4gICAgY3J5cHRvX3NpZ25fQllURVMgPSA2NCxcbiAgICBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTID0gNjQsXG4gICAgY3J5cHRvX3NpZ25fU0VFREJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2hhc2hfQllURVMgPSA2NDtcblxubmFjbC5sb3dsZXZlbCA9IHtcbiAgY3J5cHRvX2NvcmVfaHNhbHNhMjA6IGNyeXB0b19jb3JlX2hzYWxzYTIwLFxuICBjcnlwdG9fc3RyZWFtX3hvcjogY3J5cHRvX3N0cmVhbV94b3IsXG4gIGNyeXB0b19zdHJlYW06IGNyeXB0b19zdHJlYW0sXG4gIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3I6IGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IsXG4gIGNyeXB0b19zdHJlYW1fc2Fsc2EyMDogY3J5cHRvX3N0cmVhbV9zYWxzYTIwLFxuICBjcnlwdG9fb25ldGltZWF1dGg6IGNyeXB0b19vbmV0aW1lYXV0aCxcbiAgY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeTogY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeSxcbiAgY3J5cHRvX3ZlcmlmeV8xNjogY3J5cHRvX3ZlcmlmeV8xNixcbiAgY3J5cHRvX3ZlcmlmeV8zMjogY3J5cHRvX3ZlcmlmeV8zMixcbiAgY3J5cHRvX3NlY3JldGJveDogY3J5cHRvX3NlY3JldGJveCxcbiAgY3J5cHRvX3NlY3JldGJveF9vcGVuOiBjcnlwdG9fc2VjcmV0Ym94X29wZW4sXG4gIGNyeXB0b19zY2FsYXJtdWx0OiBjcnlwdG9fc2NhbGFybXVsdCxcbiAgY3J5cHRvX3NjYWxhcm11bHRfYmFzZTogY3J5cHRvX3NjYWxhcm11bHRfYmFzZSxcbiAgY3J5cHRvX2JveF9iZWZvcmVubTogY3J5cHRvX2JveF9iZWZvcmVubSxcbiAgY3J5cHRvX2JveF9hZnRlcm5tOiBjcnlwdG9fYm94X2FmdGVybm0sXG4gIGNyeXB0b19ib3g6IGNyeXB0b19ib3gsXG4gIGNyeXB0b19ib3hfb3BlbjogY3J5cHRvX2JveF9vcGVuLFxuICBjcnlwdG9fYm94X2tleXBhaXI6IGNyeXB0b19ib3hfa2V5cGFpcixcbiAgY3J5cHRvX2hhc2g6IGNyeXB0b19oYXNoLFxuICBjcnlwdG9fc2lnbjogY3J5cHRvX3NpZ24sXG4gIGNyeXB0b19zaWduX2tleXBhaXI6IGNyeXB0b19zaWduX2tleXBhaXIsXG4gIGNyeXB0b19zaWduX29wZW46IGNyeXB0b19zaWduX29wZW4sXG5cbiAgY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUzogY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUyxcbiAgY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMsXG4gIGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyxcbiAgY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVM6IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTLFxuICBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUzogY3J5cHRvX3NjYWxhcm11bHRfQllURVMsXG4gIGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTOiBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUyxcbiAgY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUzogY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyxcbiAgY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUzogY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyxcbiAgY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTOiBjcnlwdG9fYm94X0JFRk9SRU5NQllURVMsXG4gIGNyeXB0b19ib3hfTk9OQ0VCWVRFUzogY3J5cHRvX2JveF9OT05DRUJZVEVTLFxuICBjcnlwdG9fYm94X1pFUk9CWVRFUzogY3J5cHRvX2JveF9aRVJPQllURVMsXG4gIGNyeXB0b19ib3hfQk9YWkVST0JZVEVTOiBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUyxcbiAgY3J5cHRvX3NpZ25fQllURVM6IGNyeXB0b19zaWduX0JZVEVTLFxuICBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUzogY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMsXG4gIGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTOiBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyxcbiAgY3J5cHRvX3NpZ25fU0VFREJZVEVTOiBjcnlwdG9fc2lnbl9TRUVEQllURVMsXG4gIGNyeXB0b19oYXNoX0JZVEVTOiBjcnlwdG9faGFzaF9CWVRFUyxcblxuICBnZjogZ2YsXG4gIEQ6IEQsXG4gIEw6IEwsXG4gIHBhY2syNTUxOTogcGFjazI1NTE5LFxuICB1bnBhY2syNTUxOTogdW5wYWNrMjU1MTksXG4gIE06IE0sXG4gIEE6IEEsXG4gIFM6IFMsXG4gIFo6IFosXG4gIHBvdzI1MjM6IHBvdzI1MjMsXG4gIGFkZDogYWRkLFxuICBzZXQyNTUxOTogc2V0MjU1MTksXG4gIG1vZEw6IG1vZEwsXG4gIHNjYWxhcm11bHQ6IHNjYWxhcm11bHQsXG4gIHNjYWxhcmJhc2U6IHNjYWxhcmJhc2UsXG59O1xuXG4vKiBIaWdoLWxldmVsIEFQSSAqL1xuXG5mdW5jdGlvbiBjaGVja0xlbmd0aHMoaywgbikge1xuICBpZiAoay5sZW5ndGggIT09IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIGtleSBzaXplJyk7XG4gIGlmIChuLmxlbmd0aCAhPT0gY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBub25jZSBzaXplJyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm94TGVuZ3Rocyhwaywgc2spIHtcbiAgaWYgKHBrLmxlbmd0aCAhPT0gY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgcHVibGljIGtleSBzaXplJyk7XG4gIGlmIChzay5sZW5ndGggIT09IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xufVxuXG5mdW5jdGlvbiBjaGVja0FycmF5VHlwZXMoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCEoYXJndW1lbnRzW2ldIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmV4cGVjdGVkIHR5cGUsIHVzZSBVaW50OEFycmF5Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW51cChhcnIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycltpXSA9IDA7XG59XG5cbm5hY2wucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gIHJhbmRvbWJ5dGVzKGIsIG4pO1xuICByZXR1cm4gYjtcbn07XG5cbm5hY2wuc2VjcmV0Ym94ID0gZnVuY3Rpb24obXNnLCBub25jZSwga2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIG5vbmNlLCBrZXkpO1xuICBjaGVja0xlbmd0aHMoa2V5LCBub25jZSk7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheShtLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSBtW2krY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVNdID0gbXNnW2ldO1xuICBjcnlwdG9fc2VjcmV0Ym94KGMsIG0sIG0ubGVuZ3RoLCBub25jZSwga2V5KTtcbiAgcmV0dXJuIGMuc3ViYXJyYXkoY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMpO1xufTtcblxubmFjbC5zZWNyZXRib3gub3BlbiA9IGZ1bmN0aW9uKGJveCwgbm9uY2UsIGtleSkge1xuICBjaGVja0FycmF5VHlwZXMoYm94LCBub25jZSwga2V5KTtcbiAgY2hlY2tMZW5ndGhzKGtleSwgbm9uY2UpO1xuICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTICsgYm94Lmxlbmd0aCk7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoYy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJveC5sZW5ndGg7IGkrKykgY1tpK2NyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTXSA9IGJveFtpXTtcbiAgaWYgKGMubGVuZ3RoIDwgMzIpIHJldHVybiBudWxsO1xuICBpZiAoY3J5cHRvX3NlY3JldGJveF9vcGVuKG0sIGMsIGMubGVuZ3RoLCBub25jZSwga2V5KSAhPT0gMCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBtLnN1YmFycmF5KGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTKTtcbn07XG5cbm5hY2wuc2VjcmV0Ym94LmtleUxlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVM7XG5uYWNsLnNlY3JldGJveC5ub25jZUxlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUztcbm5hY2wuc2VjcmV0Ym94Lm92ZXJoZWFkTGVuZ3RoID0gY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVM7XG5cbm5hY2wuc2NhbGFyTXVsdCA9IGZ1bmN0aW9uKG4sIHApIHtcbiAgY2hlY2tBcnJheVR5cGVzKG4sIHApO1xuICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBuIHNpemUnKTtcbiAgaWYgKHAubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgcCBzaXplJyk7XG4gIHZhciBxID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NjYWxhcm11bHRfQllURVMpO1xuICBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBwKTtcbiAgcmV0dXJuIHE7XG59O1xuXG5uYWNsLnNjYWxhck11bHQuYmFzZSA9IGZ1bmN0aW9uKG4pIHtcbiAgY2hlY2tBcnJheVR5cGVzKG4pO1xuICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBuIHNpemUnKTtcbiAgdmFyIHEgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyk7XG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocSwgbik7XG4gIHJldHVybiBxO1xufTtcblxubmFjbC5zY2FsYXJNdWx0LnNjYWxhckxlbmd0aCA9IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTO1xubmFjbC5zY2FsYXJNdWx0Lmdyb3VwRWxlbWVudExlbmd0aCA9IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTO1xuXG5uYWNsLmJveCA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIHZhciBrID0gbmFjbC5ib3guYmVmb3JlKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIG5hY2wuc2VjcmV0Ym94KG1zZywgbm9uY2UsIGspO1xufTtcblxubmFjbC5ib3guYmVmb3JlID0gZnVuY3Rpb24ocHVibGljS2V5LCBzZWNyZXRLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgY2hlY2tCb3hMZW5ndGhzKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgdmFyIGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X0JFRk9SRU5NQllURVMpO1xuICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIGs7XG59O1xuXG5uYWNsLmJveC5hZnRlciA9IG5hY2wuc2VjcmV0Ym94O1xuXG5uYWNsLmJveC5vcGVuID0gZnVuY3Rpb24obXNnLCBub25jZSwgcHVibGljS2V5LCBzZWNyZXRLZXkpIHtcbiAgdmFyIGsgPSBuYWNsLmJveC5iZWZvcmUocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICByZXR1cm4gbmFjbC5zZWNyZXRib3gub3Blbihtc2csIG5vbmNlLCBrKTtcbn07XG5cbm5hY2wuYm94Lm9wZW4uYWZ0ZXIgPSBuYWNsLnNlY3JldGJveC5vcGVuO1xuXG5uYWNsLmJveC5rZXlQYWlyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpO1xuICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKTtcbiAgY3J5cHRvX2JveF9rZXlwYWlyKHBrLCBzayk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBza307XG59O1xuXG5uYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkgPSBmdW5jdGlvbihzZWNyZXRLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNlY3JldEtleSk7XG4gIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKTtcbiAgY3J5cHRvX3NjYWxhcm11bHRfYmFzZShwaywgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIHtwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6IG5ldyBVaW50OEFycmF5KHNlY3JldEtleSl9O1xufTtcblxubmFjbC5ib3gucHVibGljS2V5TGVuZ3RoID0gY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUztcbm5hY2wuYm94LnNlY3JldEtleUxlbmd0aCA9IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVM7XG5uYWNsLmJveC5zaGFyZWRLZXlMZW5ndGggPSBjcnlwdG9fYm94X0JFRk9SRU5NQllURVM7XG5uYWNsLmJveC5ub25jZUxlbmd0aCA9IGNyeXB0b19ib3hfTk9OQ0VCWVRFUztcbm5hY2wuYm94Lm92ZXJoZWFkTGVuZ3RoID0gbmFjbC5zZWNyZXRib3gub3ZlcmhlYWRMZW5ndGg7XG5cbm5hY2wuc2lnbiA9IGZ1bmN0aW9uKG1zZywgc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIHNlY3JldEtleSk7XG4gIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgdmFyIHNpZ25lZE1zZyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTK21zZy5sZW5ndGgpO1xuICBjcnlwdG9fc2lnbihzaWduZWRNc2csIG1zZywgbXNnLmxlbmd0aCwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIHNpZ25lZE1zZztcbn07XG5cbm5hY2wuc2lnbi5vcGVuID0gZnVuY3Rpb24oc2lnbmVkTXNnLCBwdWJsaWNLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNpZ25lZE1zZywgcHVibGljS2V5KTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkoc2lnbmVkTXNnLmxlbmd0aCk7XG4gIHZhciBtbGVuID0gY3J5cHRvX3NpZ25fb3Blbih0bXAsIHNpZ25lZE1zZywgc2lnbmVkTXNnLmxlbmd0aCwgcHVibGljS2V5KTtcbiAgaWYgKG1sZW4gPCAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShtbGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBtW2ldID0gdG1wW2ldO1xuICByZXR1cm4gbTtcbn07XG5cbm5hY2wuc2lnbi5kZXRhY2hlZCA9IGZ1bmN0aW9uKG1zZywgc2VjcmV0S2V5KSB7XG4gIHZhciBzaWduZWRNc2cgPSBuYWNsLnNpZ24obXNnLCBzZWNyZXRLZXkpO1xuICB2YXIgc2lnID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZy5sZW5ndGg7IGkrKykgc2lnW2ldID0gc2lnbmVkTXNnW2ldO1xuICByZXR1cm4gc2lnO1xufTtcblxubmFjbC5zaWduLmRldGFjaGVkLnZlcmlmeSA9IGZ1bmN0aW9uKG1zZywgc2lnLCBwdWJsaWNLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKG1zZywgc2lnLCBwdWJsaWNLZXkpO1xuICBpZiAoc2lnLmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2lnbmF0dXJlIHNpemUnKTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICB2YXIgc20gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgY3J5cHRvX3NpZ25fQllURVM7IGkrKykgc21baV0gPSBzaWdbaV07XG4gIGZvciAoaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHNtW2krY3J5cHRvX3NpZ25fQllURVNdID0gbXNnW2ldO1xuICByZXR1cm4gKGNyeXB0b19zaWduX29wZW4obSwgc20sIHNtLmxlbmd0aCwgcHVibGljS2V5KSA+PSAwKTtcbn07XG5cbm5hY2wuc2lnbi5rZXlQYWlyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKTtcbiAgdmFyIHNrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpO1xuICBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzayk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBza307XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VjcmV0S2V5ID0gZnVuY3Rpb24oc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBway5sZW5ndGg7IGkrKykgcGtbaV0gPSBzZWNyZXRLZXlbMzIraV07XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBuZXcgVWludDhBcnJheShzZWNyZXRLZXkpfTtcbn07XG5cbm5hY2wuc2lnbi5rZXlQYWlyLmZyb21TZWVkID0gZnVuY3Rpb24oc2VlZCkge1xuICBjaGVja0FycmF5VHlwZXMoc2VlZCk7XG4gIGlmIChzZWVkLmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VFREJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlZWQgc2l6ZScpO1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSBza1tpXSA9IHNlZWRbaV07XG4gIGNyeXB0b19zaWduX2tleXBhaXIocGssIHNrLCB0cnVlKTtcbiAgcmV0dXJuIHtwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6IHNrfTtcbn07XG5cbm5hY2wuc2lnbi5wdWJsaWNLZXlMZW5ndGggPSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUztcbm5hY2wuc2lnbi5zZWNyZXRLZXlMZW5ndGggPSBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUztcbm5hY2wuc2lnbi5zZWVkTGVuZ3RoID0gY3J5cHRvX3NpZ25fU0VFREJZVEVTO1xubmFjbC5zaWduLnNpZ25hdHVyZUxlbmd0aCA9IGNyeXB0b19zaWduX0JZVEVTO1xuXG5uYWNsLmhhc2ggPSBmdW5jdGlvbihtc2cpIHtcbiAgY2hlY2tBcnJheVR5cGVzKG1zZyk7XG4gIHZhciBoID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2hhc2hfQllURVMpO1xuICBjcnlwdG9faGFzaChoLCBtc2csIG1zZy5sZW5ndGgpO1xuICByZXR1cm4gaDtcbn07XG5cbm5hY2wuaGFzaC5oYXNoTGVuZ3RoID0gY3J5cHRvX2hhc2hfQllURVM7XG5cbm5hY2wudmVyaWZ5ID0gZnVuY3Rpb24oeCwgeSkge1xuICBjaGVja0FycmF5VHlwZXMoeCwgeSk7XG4gIC8vIFplcm8gbGVuZ3RoIGFyZ3VtZW50cyBhcmUgY29uc2lkZXJlZCBub3QgZXF1YWwuXG4gIGlmICh4Lmxlbmd0aCA9PT0gMCB8fCB5Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoeC5sZW5ndGggIT09IHkubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAodm4oeCwgMCwgeSwgMCwgeC5sZW5ndGgpID09PSAwKSA/IHRydWUgOiBmYWxzZTtcbn07XG5cbm5hY2wuc2V0UFJORyA9IGZ1bmN0aW9uKGZuKSB7XG4gIHJhbmRvbWJ5dGVzID0gZm47XG59O1xuXG4oZnVuY3Rpb24oKSB7XG4gIC8vIEluaXRpYWxpemUgUFJORyBpZiBlbnZpcm9ubWVudCBwcm92aWRlcyBDU1BSTkcuXG4gIC8vIElmIG5vdCwgbWV0aG9kcyBjYWxsaW5nIHJhbmRvbWJ5dGVzIHdpbGwgdGhyb3cuXG4gIHZhciBjcnlwdG8gPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyAoc2VsZi5jcnlwdG8gfHwgc2VsZi5tc0NyeXB0bykgOiBudWxsO1xuICBpZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBCcm93c2Vycy5cbiAgICB2YXIgUVVPVEEgPSA2NTUzNjtcbiAgICBuYWNsLnNldFBSTkcoZnVuY3Rpb24oeCwgbikge1xuICAgICAgdmFyIGksIHYgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpICs9IFFVT1RBKSB7XG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModi5zdWJhcnJheShpLCBpICsgTWF0aC5taW4obiAtIGksIFFVT1RBKSkpO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgeFtpXSA9IHZbaV07XG4gICAgICBjbGVhbnVwKHYpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHRydWUpIHtcbiAgICAvLyBOb2RlLmpzLlxuICAgIGNyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4gICAgaWYgKGNyeXB0byAmJiBjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcbiAgICAgIG5hY2wuc2V0UFJORyhmdW5jdGlvbih4LCBuKSB7XG4gICAgICAgIHZhciBpLCB2ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKG4pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB4W2ldID0gdltpXTtcbiAgICAgICAgY2xlYW51cCh2KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSkoKTtcblxufSkoIHRydWUgJiYgbW9kdWxlLmV4cG9ydHMgPyBtb2R1bGUuZXhwb3J0cyA6IChzZWxmLm5hY2wgPSBzZWxmLm5hY2wgfHwge30pKTtcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NykuZGVmYXVsdDtcblxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG5cblN0cmVhbXMgaW4gYSBXZWJTb2NrZXQgY29ubmVjdGlvblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbldlIG1vZGVsIGEgV2ViU29ja2V0IGFzIHR3byBkdXBsZXggc3RyZWFtczogb25lIHN0cmVhbSBpcyBmb3IgdGhlIHdpcmUgcHJvdG9jb2xcbm92ZXIgYW4gSS9PIHNvY2tldCwgYW5kIHRoZSBvdGhlciBpcyBmb3IgaW5jb21pbmcvb3V0Z29pbmcgbWVzc2FnZXMuXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0rICAgICAgKy0tLS0tLS0tLSsgICAgICArLS0tLS0tLS0tLStcbiAgICBbMV0gd3JpdGUoY2h1bmspIC0tPnwgfn5+fn5+fn4gKy0tLS0tPnwgcGFyc2UoKSArLS0tLS0+fCB+fn5+fn5+fiArLS0+IGVtaXQoJ2RhdGEnKSBbMl1cbiAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICstLS0tKy0tLS0rICAgICAgfCAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgfCAgICBJTyAgICB8ICAgICAgICAgICB8IFs1XSAgICAgICB8IE1lc3NhZ2VzIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgICAgViAgICAgICAgICAgfCAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICArLS0tLS0tLS0tKyAgICAgIHwgICAgICAgICAgfFxuICAgIFs0XSBlbWl0KCdkYXRhJykgPC0tKyB+fn5+fn5+fiB8PC0tLS0tKyBmcmFtZSgpIHw8LS0tLS0rIH5+fn5+fn5+IHw8LS0gd3JpdGUoY2h1bmspIFszXVxuICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0rICAgICAgKy0tLS0tLS0tLSsgICAgICArLS0tLS0tLS0tLStcblxuXG5NZXNzYWdlIHRyYW5zZmVyIGluIGVhY2ggZGlyZWN0aW9uIGlzIHNpbXBsZTogSU8gcmVjZWl2ZXMgYSBieXRlIHN0cmVhbSBbMV0gYW5kXG5zZW5kcyB0aGlzIHN0cmVhbSBmb3IgcGFyc2luZy4gVGhlIHBhcnNlciB3aWxsIHBlcmlvZGljYWxseSBlbWl0IGEgY29tcGxldGVcbm1lc3NhZ2UgdGV4dCBvbiB0aGUgTWVzc2FnZXMgc3RyZWFtIFsyXS4gU2ltaWxhcmx5LCB3aGVuIG1lc3NhZ2VzIGFyZSB3cml0dGVuXG50byB0aGUgTWVzc2FnZXMgc3RyZWFtIFszXSwgdGhleSBhcmUgZnJhbWVkIHVzaW5nIHRoZSBXZWJTb2NrZXQgd2lyZSBmb3JtYXQgYW5kXG5lbWl0dGVkIHZpYSBJTyBbNF0uXG5cblRoZXJlIGlzIGEgZmVlZGJhY2sgbG9vcCB2aWEgWzVdIHNpbmNlIHNvbWUgaW5wdXQgZnJvbSBbMV0gd2lsbCBiZSB0aGluZ3MgbGlrZVxucGluZywgcG9uZyBhbmQgY2xvc2UgZnJhbWVzLiBJbiB0aGVzZSBjYXNlcyB0aGUgcHJvdG9jb2wgcmVzcG9uZHMgYnkgZW1pdHRpbmdcbnJlc3BvbnNlcyBkaXJlY3RseSBiYWNrIHRvIFs0XSByYXRoZXIgdGhhbiBlbWl0dGluZyBtZXNzYWdlcyB2aWEgWzJdLlxuXG5Gb3IgdGhlIHB1cnBvc2VzIG9mIGZsb3cgY29udHJvbCwgd2UgY29uc2lkZXIgdGhlIHNvdXJjZXMgb2YgZWFjaCBSZWFkYWJsZVxuc3RyZWFtIHRvIGJlIGFzIGZvbGxvd3M6XG5cbiogWzJdIHJlY2VpdmVzIGlucHV0IGZyb20gWzFdXG4qIFs0XSByZWNlaXZlcyBpbnB1dCBmcm9tIFsxXSBhbmQgWzNdXG5cblRoZSBjbGFzc2VzIGJlbG93IGV4cHJlc3MgdGhlIHJlbGF0aW9uc2hpcHMgZGVzY3JpYmVkIGFib3ZlIHdpdGhvdXQgcHJlc2NyaWJpbmdcbmFueXRoaW5nIGFib3V0IGhvdyBwYXJzZSgpIGFuZCBmcmFtZSgpIHdvcmssIG90aGVyIHRoYW4gYXNzdW1pbmcgdGhleSBlbWl0XG4nZGF0YScgZXZlbnRzIHRvIHRoZSBJTyBhbmQgTWVzc2FnZXMgc3RyZWFtcy4gVGhleSB3aWxsIHdvcmsgd2l0aCBhbnkgcHJvdG9jb2xcbmRyaXZlciBoYXZpbmcgdGhlc2UgdHdvIG1ldGhvZHMuXG4qKi9cblxuXG52YXIgU3RyZWFtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KS5TdHJlYW0sXG4gICAgdXRpbCAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG52YXIgSU8gPSBmdW5jdGlvbihkcml2ZXIpIHtcbiAgdGhpcy5yZWFkYWJsZSA9IHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLl9wYXVzZWQgID0gZmFsc2U7XG4gIHRoaXMuX2RyaXZlciAgPSBkcml2ZXI7XG59O1xudXRpbC5pbmhlcml0cyhJTywgU3RyZWFtKTtcblxuLy8gVGhlIElPIHBhdXNlKCkgYW5kIHJlc3VtZSgpIG1ldGhvZHMgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgc29ja2V0IHdlIGFyZVxuLy8gcGlwaW5nIHRvIGdldHMgYmFja2VkIHVwIGFuZCBkcmFpbnMuIFNpbmNlIElPIG91dHB1dCBbNF0gY29tZXMgZnJvbSBJTyBpbnB1dFxuLy8gWzFdIGFuZCBNZXNzYWdlcyBpbnB1dCBbM10sIHdlIG5lZWQgdG8gdGVsbCBib3RoIG9mIHRob3NlIHRvIHJldHVybiBmYWxzZVxuLy8gZnJvbSB3cml0ZSgpIHdoZW4gdGhpcyBzdHJlYW0gaXMgcGF1c2VkLlxuXG5JTy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgdGhpcy5fZHJpdmVyLm1lc3NhZ2VzLl9wYXVzZWQgPSB0cnVlO1xufTtcblxuSU8ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdkcmFpbicpO1xuXG4gIHZhciBtZXNzYWdlcyA9IHRoaXMuX2RyaXZlci5tZXNzYWdlcztcbiAgbWVzc2FnZXMuX3BhdXNlZCA9IGZhbHNlO1xuICBtZXNzYWdlcy5lbWl0KCdkcmFpbicpO1xufTtcblxuLy8gV2hlbiB3ZSByZWNlaXZlIGlucHV0IGZyb20gYSBzb2NrZXQsIHNlbmQgaXQgdG8gdGhlIHBhcnNlciBhbmQgdGVsbCB0aGVcbi8vIHNvdXJjZSB3aGV0aGVyIHRvIGJhY2sgb2ZmLlxuSU8ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgaWYgKCF0aGlzLndyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG4gIHRoaXMuX2RyaXZlci5wYXJzZShjaHVuayk7XG4gIHJldHVybiAhdGhpcy5fcGF1c2VkO1xufTtcblxuLy8gVGhlIElPIGVuZCgpIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBzb2NrZXQgcGlwaW5nIGludG8gaXQgZW1pdHNcbi8vICdjbG9zZScgb3IgJ2VuZCcsIGkuZS4gdGhlIHNvY2tldCBpcyBjbG9zZWQuIEluIHRoaXMgc2l0dWF0aW9uIHRoZSBNZXNzYWdlc1xuLy8gc3RyZWFtIHdpbGwgbm90IGVtaXQgYW55IG1vcmUgZGF0YSBzbyB3ZSBlbWl0ICdlbmQnLlxuSU8ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIGlmICghdGhpcy53cml0YWJsZSkgcmV0dXJuO1xuICBpZiAoY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuayk7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB2YXIgbWVzc2FnZXMgPSB0aGlzLl9kcml2ZXIubWVzc2FnZXM7XG4gIGlmIChtZXNzYWdlcy5yZWFkYWJsZSkge1xuICAgIG1lc3NhZ2VzLnJlYWRhYmxlID0gbWVzc2FnZXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICBtZXNzYWdlcy5lbWl0KCdlbmQnKTtcbiAgfVxufTtcblxuSU8ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbmQoKTtcbn07XG5cblxudmFyIE1lc3NhZ2VzID0gZnVuY3Rpb24oZHJpdmVyKSB7XG4gIHRoaXMucmVhZGFibGUgPSB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5fcGF1c2VkICA9IGZhbHNlO1xuICB0aGlzLl9kcml2ZXIgID0gZHJpdmVyO1xufTtcbnV0aWwuaW5oZXJpdHMoTWVzc2FnZXMsIFN0cmVhbSk7XG5cbi8vIFRoZSBNZXNzYWdlcyBwYXVzZSgpIGFuZCByZXN1bWUoKSBtZXRob2RzIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGFwcCB0aGF0J3Ncbi8vIHByb2Nlc3NpbmcgdGhlIG1lc3NhZ2VzIGdldHMgYmFja2VkIHVwIGFuZCBkcmFpbnMuIElmIHdlJ3JlIGVtaXR0aW5nXG4vLyBtZXNzYWdlcyB0b28gZmFzdCB3ZSBzaG91bGQgdGVsbCB0aGUgc291cmNlIHRvIHNsb3cgZG93bi4gTWVzc2FnZSBvdXRwdXQgWzJdXG4vLyBjb21lcyBmcm9tIElPIGlucHV0IFsxXS5cblxuTWVzc2FnZXMucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2RyaXZlci5pby5fcGF1c2VkID0gdHJ1ZTtcbn07XG5cbk1lc3NhZ2VzLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZHJpdmVyLmlvLl9wYXVzZWQgPSBmYWxzZTtcbiAgdGhpcy5fZHJpdmVyLmlvLmVtaXQoJ2RyYWluJyk7XG59O1xuXG4vLyBXaGVuIHdlIHJlY2VpdmUgbWVzc2FnZXMgZnJvbSB0aGUgdXNlciwgc2VuZCB0aGVtIHRvIHRoZSBmb3JtYXR0ZXIgYW5kIHRlbGxcbi8vIHRoZSBzb3VyY2Ugd2hldGhlciB0byBiYWNrIG9mZi5cbk1lc3NhZ2VzLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgaWYgKCF0aGlzLndyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHRoaXMuX2RyaXZlci50ZXh0KG1lc3NhZ2UpO1xuICBlbHNlIHRoaXMuX2RyaXZlci5iaW5hcnkobWVzc2FnZSk7XG4gIHJldHVybiAhdGhpcy5fcGF1c2VkO1xufTtcblxuLy8gVGhlIE1lc3NhZ2VzIGVuZCgpIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgc3RyZWFtIHBpcGluZyBpbnRvIGl0IGVtaXRzXG4vLyAnZW5kJy4gTWFueSBzdHJlYW1zIG1heSBiZSBwaXBlZCBpbnRvIHRoZSBXZWJTb2NrZXQgYW5kIG9uZSBvZiB0aGVtIGVuZGluZ1xuLy8gZG9lcyBub3QgbWVhbiB0aGUgd2hvbGUgc29ja2V0IGlzIGRvbmUsIHNvIGp1c3QgcHJvY2VzcyB0aGUgaW5wdXQgYW5kIG1vdmVcbi8vIG9uIGxlYXZpbmcgdGhlIHNvY2tldCBvcGVuLlxuTWVzc2FnZXMucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShtZXNzYWdlKTtcbn07XG5cbk1lc3NhZ2VzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7fTtcblxuXG5leHBvcnRzLklPID0gSU87XG5leHBvcnRzLk1lc3NhZ2VzID0gTWVzc2FnZXM7XG5cblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5CdWZmZXI7XG5cbnZhciBTdHJlYW1SZWFkZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcXVldWUgICAgID0gW107XG4gIHRoaXMuX3F1ZXVlU2l6ZSA9IDA7XG4gIHRoaXMuX29mZnNldCAgICA9IDA7XG59O1xuXG5TdHJlYW1SZWFkZXIucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICBpZiAoIWJ1ZmZlciB8fCBidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJ1ZmZlcik7XG4gIHRoaXMuX3F1ZXVlLnB1c2goYnVmZmVyKTtcbiAgdGhpcy5fcXVldWVTaXplICs9IGJ1ZmZlci5sZW5ndGg7XG59O1xuXG5TdHJlYW1SZWFkZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IHRoaXMuX3F1ZXVlU2l6ZSkgcmV0dXJuIG51bGw7XG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgdGhpcy5fcXVldWVTaXplIC09IGxlbmd0aDtcblxuICB2YXIgcXVldWUgID0gdGhpcy5fcXVldWUsXG4gICAgICByZW1haW4gPSBsZW5ndGgsXG4gICAgICBmaXJzdCAgPSBxdWV1ZVswXSxcbiAgICAgIGJ1ZmZlcnMsIGJ1ZmZlcjtcblxuICBpZiAoZmlyc3QubGVuZ3RoID49IGxlbmd0aCkge1xuICAgIGlmIChmaXJzdC5sZW5ndGggPT09IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHF1ZXVlLnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlciA9IGZpcnN0LnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICBxdWV1ZVswXSA9IGZpcnN0LnNsaWNlKGxlbmd0aCk7XG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gcXVldWUubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgaWYgKHJlbWFpbiA8IHF1ZXVlW2ldLmxlbmd0aCkgYnJlYWs7XG4gICAgcmVtYWluIC09IHF1ZXVlW2ldLmxlbmd0aDtcbiAgfVxuICBidWZmZXJzID0gcXVldWUuc3BsaWNlKDAsIGkpO1xuXG4gIGlmIChyZW1haW4gPiAwICYmIHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICBidWZmZXJzLnB1c2gocXVldWVbMF0uc2xpY2UoMCwgcmVtYWluKSk7XG4gICAgcXVldWVbMF0gPSBxdWV1ZVswXS5zbGljZShyZW1haW4pO1xuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIGxlbmd0aCk7XG59O1xuXG5TdHJlYW1SZWFkZXIucHJvdG90eXBlLmVhY2hCeXRlID0gZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgdmFyIGJ1ZmZlciwgbiwgaW5kZXg7XG5cbiAgd2hpbGUgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICBidWZmZXIgPSB0aGlzLl9xdWV1ZVswXTtcbiAgICBuID0gYnVmZmVyLmxlbmd0aDtcblxuICAgIHdoaWxlICh0aGlzLl9vZmZzZXQgPCBuKSB7XG4gICAgICBpbmRleCA9IHRoaXMuX29mZnNldDtcbiAgICAgIHRoaXMuX29mZnNldCArPSAxO1xuICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBidWZmZXJbaW5kZXhdKTtcbiAgICB9XG4gICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbVJlYWRlcjtcblxuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBCdWZmZXIgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5CdWZmZXIsXG4gICAgY3J5cHRvICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMyksXG4gICAgdXJsICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNiksXG4gICAgdXRpbCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMCksXG4gICAgSHR0cFBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApLFxuICAgIEJhc2UgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLFxuICAgIEh5YmkgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSxcbiAgICBQcm94eSAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cbnZhciBDbGllbnQgPSBmdW5jdGlvbihfdXJsLCBvcHRpb25zKSB7XG4gIHRoaXMudmVyc2lvbiA9ICdoeWJpLScgKyBIeWJpLlZFUlNJT047XG4gIEh5YmkuY2FsbCh0aGlzLCBudWxsLCBfdXJsLCBvcHRpb25zKTtcblxuICB0aGlzLnJlYWR5U3RhdGUgPSAtMTtcbiAgdGhpcy5fa2V5ICAgICAgID0gQ2xpZW50LmdlbmVyYXRlS2V5KCk7XG4gIHRoaXMuX2FjY2VwdCAgICA9IEh5YmkuZ2VuZXJhdGVBY2NlcHQodGhpcy5fa2V5KTtcbiAgdGhpcy5faHR0cCAgICAgID0gbmV3IEh0dHBQYXJzZXIoJ3Jlc3BvbnNlJyk7XG5cbiAgdmFyIHVyaSAgPSB1cmwucGFyc2UodGhpcy51cmwpLFxuICAgICAgYXV0aCA9IHVyaS5hdXRoICYmIEJ1ZmZlci5mcm9tKHVyaS5hdXRoLCAndXRmOCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcblxuICBpZiAodGhpcy5WQUxJRF9QUk9UT0NPTFMuaW5kZXhPZih1cmkucHJvdG9jb2wpIDwgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy51cmwgKyAnIGlzIG5vdCBhIHZhbGlkIFdlYlNvY2tldCBVUkwnKTtcblxuICB0aGlzLl9wYXRobmFtZSA9ICh1cmkucGF0aG5hbWUgfHwgJy8nKSArICh1cmkuc2VhcmNoIHx8ICcnKTtcblxuICB0aGlzLl9oZWFkZXJzLnNldCgnSG9zdCcsIHVyaS5ob3N0KTtcbiAgdGhpcy5faGVhZGVycy5zZXQoJ1VwZ3JhZGUnLCAnd2Vic29ja2V0Jyk7XG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdDb25uZWN0aW9uJywgJ1VwZ3JhZGUnKTtcbiAgdGhpcy5faGVhZGVycy5zZXQoJ1NlYy1XZWJTb2NrZXQtS2V5JywgdGhpcy5fa2V5KTtcbiAgdGhpcy5faGVhZGVycy5zZXQoJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbicsIEh5YmkuVkVSU0lPTik7XG5cbiAgaWYgKHRoaXMuX3Byb3RvY29scy5sZW5ndGggPiAwKVxuICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdTZWMtV2ViU29ja2V0LVByb3RvY29sJywgdGhpcy5fcHJvdG9jb2xzLmpvaW4oJywgJykpO1xuXG4gIGlmIChhdXRoKVxuICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBhdXRoKTtcbn07XG51dGlsLmluaGVyaXRzKENsaWVudCwgSHliaSk7XG5cbkNsaWVudC5nZW5lcmF0ZUtleSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnYmFzZTY0Jyk7XG59O1xuXG52YXIgaW5zdGFuY2UgPSB7XG4gIFZBTElEX1BST1RPQ09MUzogWyd3czonLCAnd3NzOiddLFxuXG4gIHByb3h5OiBmdW5jdGlvbihvcmlnaW4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIG9yaWdpbiwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IC0xKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGUodGhpcy5faGFuZHNoYWtlUmVxdWVzdCgpKTtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbihjaHVuaykge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IDMpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gMCkgcmV0dXJuIEh5YmkucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgY2h1bmspO1xuXG4gICAgdGhpcy5faHR0cC5wYXJzZShjaHVuayk7XG4gICAgaWYgKCF0aGlzLl9odHRwLmlzQ29tcGxldGUoKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fdmFsaWRhdGVIYW5kc2hha2UoKTtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSAzKSByZXR1cm47XG5cbiAgICB0aGlzLl9vcGVuKCk7XG4gICAgdGhpcy5wYXJzZSh0aGlzLl9odHRwLmJvZHkpO1xuICB9LFxuXG4gIF9oYW5kc2hha2VSZXF1ZXN0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXh0ZW5zaW9ucyA9IHRoaXMuX2V4dGVuc2lvbnMuZ2VuZXJhdGVPZmZlcigpO1xuICAgIGlmIChleHRlbnNpb25zKVxuICAgICAgdGhpcy5faGVhZGVycy5zZXQoJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucycsIGV4dGVuc2lvbnMpO1xuXG4gICAgdmFyIHN0YXJ0ICAgPSAnR0VUICcgKyB0aGlzLl9wYXRobmFtZSArICcgSFRUUC8xLjEnLFxuICAgICAgICBoZWFkZXJzID0gW3N0YXJ0LCB0aGlzLl9oZWFkZXJzLnRvU3RyaW5nKCksICcnXTtcblxuICAgIHJldHVybiBCdWZmZXIuZnJvbShoZWFkZXJzLmpvaW4oJ1xcclxcbicpLCAndXRmOCcpO1xuICB9LFxuXG4gIF9mYWlsSGFuZHNoYWtlOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgbWVzc2FnZSA9ICdFcnJvciBkdXJpbmcgV2ViU29ja2V0IGhhbmRzaGFrZTogJyArIG1lc3NhZ2U7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gMztcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgbmV3IEJhc2UuQ2xvc2VFdmVudCh0aGlzLkVSUk9SUy5wcm90b2NvbF9lcnJvciwgbWVzc2FnZSkpO1xuICB9LFxuXG4gIF92YWxpZGF0ZUhhbmRzaGFrZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gdGhpcy5faHR0cC5zdGF0dXNDb2RlO1xuICAgIHRoaXMuaGVhZGVycyAgICA9IHRoaXMuX2h0dHAuaGVhZGVycztcblxuICAgIGlmICh0aGlzLl9odHRwLmVycm9yKVxuICAgICAgcmV0dXJuIHRoaXMuX2ZhaWxIYW5kc2hha2UodGhpcy5faHR0cC5lcnJvci5tZXNzYWdlKTtcblxuICAgIGlmICh0aGlzLl9odHRwLnN0YXR1c0NvZGUgIT09IDEwMSlcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsSGFuZHNoYWtlKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGNvZGU6ICcgKyB0aGlzLl9odHRwLnN0YXR1c0NvZGUpO1xuXG4gICAgdmFyIGhlYWRlcnMgICAgPSB0aGlzLl9odHRwLmhlYWRlcnMsXG4gICAgICAgIHVwZ3JhZGUgICAgPSBoZWFkZXJzWyd1cGdyYWRlJ10gfHwgJycsXG4gICAgICAgIGNvbm5lY3Rpb24gPSBoZWFkZXJzWydjb25uZWN0aW9uJ10gfHwgJycsXG4gICAgICAgIGFjY2VwdCAgICAgPSBoZWFkZXJzWydzZWMtd2Vic29ja2V0LWFjY2VwdCddIHx8ICcnLFxuICAgICAgICBwcm90b2NvbCAgID0gaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddIHx8ICcnO1xuXG4gICAgaWYgKHVwZ3JhZGUgPT09ICcnKVxuICAgICAgcmV0dXJuIHRoaXMuX2ZhaWxIYW5kc2hha2UoXCInVXBncmFkZScgaGVhZGVyIGlzIG1pc3NpbmdcIik7XG4gICAgaWYgKHVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpXG4gICAgICByZXR1cm4gdGhpcy5fZmFpbEhhbmRzaGFrZShcIidVcGdyYWRlJyBoZWFkZXIgdmFsdWUgaXMgbm90ICdXZWJTb2NrZXQnXCIpO1xuXG4gICAgaWYgKGNvbm5lY3Rpb24gPT09ICcnKVxuICAgICAgcmV0dXJuIHRoaXMuX2ZhaWxIYW5kc2hha2UoXCInQ29ubmVjdGlvbicgaGVhZGVyIGlzIG1pc3NpbmdcIik7XG4gICAgaWYgKGNvbm5lY3Rpb24udG9Mb3dlckNhc2UoKSAhPT0gJ3VwZ3JhZGUnKVxuICAgICAgcmV0dXJuIHRoaXMuX2ZhaWxIYW5kc2hha2UoXCInQ29ubmVjdGlvbicgaGVhZGVyIHZhbHVlIGlzIG5vdCAnVXBncmFkZSdcIik7XG5cbiAgICBpZiAoYWNjZXB0ICE9PSB0aGlzLl9hY2NlcHQpXG4gICAgICByZXR1cm4gdGhpcy5fZmFpbEhhbmRzaGFrZSgnU2VjLVdlYlNvY2tldC1BY2NlcHQgbWlzbWF0Y2gnKTtcblxuICAgIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuXG4gICAgaWYgKHByb3RvY29sICE9PSAnJykge1xuICAgICAgaWYgKHRoaXMuX3Byb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA8IDApXG4gICAgICAgIHJldHVybiB0aGlzLl9mYWlsSGFuZHNoYWtlKCdTZWMtV2ViU29ja2V0LVByb3RvY29sIG1pc21hdGNoJyk7XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9ucy5hY3RpdmF0ZSh0aGlzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFpbEhhbmRzaGFrZShlLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufTtcblxuZm9yICh2YXIga2V5IGluIGluc3RhbmNlKVxuICBDbGllbnQucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudDtcblxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuXG52YXIgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbmV4cG9ydHMuSFRUUFBhcnNlciA9IEhUVFBQYXJzZXI7XG5mdW5jdGlvbiBIVFRQUGFyc2VyKHR5cGUpIHtcbiAgYXNzZXJ0Lm9rKHR5cGUgPT09IEhUVFBQYXJzZXIuUkVRVUVTVCB8fCB0eXBlID09PSBIVFRQUGFyc2VyLlJFU1BPTlNFIHx8IHR5cGUgPT09IHVuZGVmaW5lZCk7XG4gIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBOb2RlIHYxMitcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmluaXRpYWxpemUodHlwZSk7XG4gIH1cbiAgdGhpcy5tYXhIZWFkZXJTaXplPUhUVFBQYXJzZXIubWF4SGVhZGVyU2l6ZVxufVxuSFRUUFBhcnNlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh0eXBlLCBhc3luY19yZXNvdXJjZSkge1xuICBhc3NlcnQub2sodHlwZSA9PT0gSFRUUFBhcnNlci5SRVFVRVNUIHx8IHR5cGUgPT09IEhUVFBQYXJzZXIuUkVTUE9OU0UpO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnN0YXRlID0gdHlwZSArICdfTElORSc7XG4gIHRoaXMuaW5mbyA9IHtcbiAgICBoZWFkZXJzOiBbXSxcbiAgICB1cGdyYWRlOiBmYWxzZVxuICB9O1xuICB0aGlzLnRyYWlsZXJzID0gW107XG4gIHRoaXMubGluZSA9ICcnO1xuICB0aGlzLmlzQ2h1bmtlZCA9IGZhbHNlO1xuICB0aGlzLmNvbm5lY3Rpb24gPSAnJztcbiAgdGhpcy5oZWFkZXJTaXplID0gMDsgLy8gZm9yIHByZXZlbnRpbmcgdG9vIGJpZyBoZWFkZXJzXG4gIHRoaXMuYm9keV9ieXRlcyA9IG51bGw7XG4gIHRoaXMuaXNVc2VyQ2FsbCA9IGZhbHNlO1xuICB0aGlzLmhhZEVycm9yID0gZmFsc2U7XG59O1xuXG5IVFRQUGFyc2VyLmVuY29kaW5nID0gJ2FzY2lpJztcbkhUVFBQYXJzZXIubWF4SGVhZGVyU2l6ZSA9IDgwICogMTAyNDsgLy8gbWF4SGVhZGVyU2l6ZSAoaW4gYnl0ZXMpIGlzIGNvbmZpZ3VyYWJsZSwgYnV0IDgwa2IgYnkgZGVmYXVsdDtcbkhUVFBQYXJzZXIuUkVRVUVTVCA9ICdSRVFVRVNUJztcbkhUVFBQYXJzZXIuUkVTUE9OU0UgPSAnUkVTUE9OU0UnO1xuXG4vLyBOb3RlOiAqbm90KiBzdGFydGluZyB3aXRoIGtPbkhlYWRlcnM9MCBsaW5lIHRoZSBOb2RlIHBhcnNlciwgYmVjYXVzZSBhbnlcbi8vICAgbmV3bHkgYWRkZWQgY29uc3RhbnRzIChrT25UaW1lb3V0IGluIE5vZGUgdjEyLjE5LjApIHdpbGwgb3ZlcndyaXRlIDAhXG52YXIga09uSGVhZGVycyA9IEhUVFBQYXJzZXIua09uSGVhZGVycyA9IDE7XG52YXIga09uSGVhZGVyc0NvbXBsZXRlID0gSFRUUFBhcnNlci5rT25IZWFkZXJzQ29tcGxldGUgPSAyO1xudmFyIGtPbkJvZHkgPSBIVFRQUGFyc2VyLmtPbkJvZHkgPSAzO1xudmFyIGtPbk1lc3NhZ2VDb21wbGV0ZSA9IEhUVFBQYXJzZXIua09uTWVzc2FnZUNvbXBsZXRlID0gNDtcblxuLy8gU29tZSBoYW5kbGVyIHN0dWJzLCBuZWVkZWQgZm9yIGNvbXBhdGliaWxpdHlcbkhUVFBQYXJzZXIucHJvdG90eXBlW2tPbkhlYWRlcnNdID1cbkhUVFBQYXJzZXIucHJvdG90eXBlW2tPbkhlYWRlcnNDb21wbGV0ZV0gPVxuSFRUUFBhcnNlci5wcm90b3R5cGVba09uQm9keV0gPVxuSFRUUFBhcnNlci5wcm90b3R5cGVba09uTWVzc2FnZUNvbXBsZXRlXSA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgY29tcGF0TW9kZTBfMTIgPSB0cnVlO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUVFBQYXJzZXIsICdrT25FeGVjdXRlJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gaGFjayBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgY29tcGF0TW9kZTBfMTIgPSBmYWxzZTtcbiAgICAgIHJldHVybiA5OTtcbiAgICB9XG4gIH0pO1xuXG52YXIgbWV0aG9kcyA9IGV4cG9ydHMubWV0aG9kcyA9IEhUVFBQYXJzZXIubWV0aG9kcyA9IFtcbiAgJ0RFTEVURScsXG4gICdHRVQnLFxuICAnSEVBRCcsXG4gICdQT1NUJyxcbiAgJ1BVVCcsXG4gICdDT05ORUNUJyxcbiAgJ09QVElPTlMnLFxuICAnVFJBQ0UnLFxuICAnQ09QWScsXG4gICdMT0NLJyxcbiAgJ01LQ09MJyxcbiAgJ01PVkUnLFxuICAnUFJPUEZJTkQnLFxuICAnUFJPUFBBVENIJyxcbiAgJ1NFQVJDSCcsXG4gICdVTkxPQ0snLFxuICAnQklORCcsXG4gICdSRUJJTkQnLFxuICAnVU5CSU5EJyxcbiAgJ0FDTCcsXG4gICdSRVBPUlQnLFxuICAnTUtBQ1RJVklUWScsXG4gICdDSEVDS09VVCcsXG4gICdNRVJHRScsXG4gICdNLVNFQVJDSCcsXG4gICdOT1RJRlknLFxuICAnU1VCU0NSSUJFJyxcbiAgJ1VOU1VCU0NSSUJFJyxcbiAgJ1BBVENIJyxcbiAgJ1BVUkdFJyxcbiAgJ01LQ0FMRU5EQVInLFxuICAnTElOSycsXG4gICdVTkxJTksnLFxuICAnU09VUkNFJyxcbl07XG52YXIgbWV0aG9kX2Nvbm5lY3QgPSBtZXRob2RzLmluZGV4T2YoJ0NPTk5FQ1QnKTtcbkhUVFBQYXJzZXIucHJvdG90eXBlLnJlaW5pdGlhbGl6ZSA9IEhUVFBQYXJzZXI7XG5IVFRQUGFyc2VyLnByb3RvdHlwZS5jbG9zZSA9XG5IVFRQUGFyc2VyLnByb3RvdHlwZS5wYXVzZSA9XG5IVFRQUGFyc2VyLnByb3RvdHlwZS5yZXN1bWUgPVxuSFRUUFBhcnNlci5wcm90b3R5cGUuZnJlZSA9IGZ1bmN0aW9uICgpIHt9O1xuSFRUUFBhcnNlci5wcm90b3R5cGUuX2NvbXBhdE1vZGUwXzExID0gZmFsc2U7XG5IVFRQUGFyc2VyLnByb3RvdHlwZS5nZXRBc3luY0lkID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG52YXIgaGVhZGVyU3RhdGUgPSB7XG4gIFJFUVVFU1RfTElORTogdHJ1ZSxcbiAgUkVTUE9OU0VfTElORTogdHJ1ZSxcbiAgSEVBREVSOiB0cnVlXG59O1xuSFRUUFBhcnNlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChjaHVuaywgc3RhcnQsIGxlbmd0aCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSFRUUFBhcnNlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBIVFRQUGFyc2VyJyk7XG4gIH1cblxuICAvLyBiYWNrd2FyZCBjb21wYXQgdG8gbm9kZSA8IDAuMTEuNFxuICAvLyBOb3RlOiB0aGUgc3RhcnQgYW5kIGxlbmd0aCBwYXJhbXMgd2VyZSByZW1vdmVkIGluIG5ld2VyIHZlcnNpb25cbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBsZW5ndGggPSB0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJyA/IGxlbmd0aCA6IGNodW5rLmxlbmd0aDtcblxuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMub2Zmc2V0ID0gc3RhcnQ7XG4gIHZhciBlbmQgPSB0aGlzLmVuZCA9IHN0YXJ0ICsgbGVuZ3RoO1xuICB0cnkge1xuICAgIHdoaWxlICh0aGlzLm9mZnNldCA8IGVuZCkge1xuICAgICAgaWYgKHRoaXNbdGhpcy5zdGF0ZV0oKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0aGlzLmlzVXNlckNhbGwpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgdGhpcy5oYWRFcnJvciA9IHRydWU7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuICB0aGlzLmNodW5rID0gbnVsbDtcbiAgbGVuZ3RoID0gdGhpcy5vZmZzZXQgLSBzdGFydDtcbiAgaWYgKGhlYWRlclN0YXRlW3RoaXMuc3RhdGVdKSB7XG4gICAgdGhpcy5oZWFkZXJTaXplICs9IGxlbmd0aDtcbiAgICBpZiAodGhpcy5oZWFkZXJTaXplID4gKHRoaXMubWF4SGVhZGVyU2l6ZXx8SFRUUFBhcnNlci5tYXhIZWFkZXJTaXplKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignbWF4IGhlYWRlciBzaXplIGV4Y2VlZGVkJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW5ndGg7XG59O1xuXG52YXIgc3RhdGVGaW5pc2hBbGxvd2VkID0ge1xuICBSRVFVRVNUX0xJTkU6IHRydWUsXG4gIFJFU1BPTlNFX0xJTkU6IHRydWUsXG4gIEJPRFlfUkFXOiB0cnVlXG59O1xuSFRUUFBhcnNlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5oYWRFcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXN0YXRlRmluaXNoQWxsb3dlZFt0aGlzLnN0YXRlXSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUgZm9yIEVPRicpO1xuICB9XG4gIGlmICh0aGlzLnN0YXRlID09PSAnQk9EWV9SQVcnKSB7XG4gICAgdGhpcy51c2VyQ2FsbCgpKHRoaXNba09uTWVzc2FnZUNvbXBsZXRlXSgpKTtcbiAgfVxufTtcblxuLy8gVGhlc2UgdGhyZWUgbWV0aG9kcyBhcmUgdXNlZCBmb3IgYW4gaW50ZXJuYWwgc3BlZWQgb3B0aW1pemF0aW9uLCBhbmQgaXQgYWxzb1xuLy8gd29ya3MgaWYgdGhlc2VzIGFyZSBub29wcy4gQmFzaWNhbGx5IGNvbnN1bWUoKSBhc2tzIHVzIHRvIHJlYWQgdGhlIGJ5dGVzXG4vLyBvdXJzZWx2ZXMsIGJ1dCBpZiB3ZSBkb24ndCBkbyBpdCB3ZSBnZXQgdGhlbSB0aHJvdWdoIGV4ZWN1dGUoKS5cbkhUVFBQYXJzZXIucHJvdG90eXBlLmNvbnN1bWUgPVxuSFRUUFBhcnNlci5wcm90b3R5cGUudW5jb25zdW1lID1cbkhUVFBQYXJzZXIucHJvdG90eXBlLmdldEN1cnJlbnRCdWZmZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy9Gb3IgY29ycmVjdCBlcnJvciBoYW5kbGluZyAtIHNlZSBIVFRQUGFyc2VyI2V4ZWN1dGVcbi8vVXNhZ2U6IHRoaXMudXNlckNhbGwoKSh1c2VyRnVuY3Rpb24oJ2FyZycpKTtcbkhUVFBQYXJzZXIucHJvdG90eXBlLnVzZXJDYWxsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmlzVXNlckNhbGwgPSB0cnVlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbiAocmV0KSB7XG4gICAgc2VsZi5pc1VzZXJDYWxsID0gZmFsc2U7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbn07XG5cbkhUVFBQYXJzZXIucHJvdG90eXBlLm5leHRSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnVzZXJDYWxsKCkodGhpc1trT25NZXNzYWdlQ29tcGxldGVdKCkpO1xuICB0aGlzLnJlaW5pdGlhbGl6ZSh0aGlzLnR5cGUpO1xufTtcblxuSFRUUFBhcnNlci5wcm90b3R5cGUuY29uc3VtZUxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbmQgPSB0aGlzLmVuZCxcbiAgICAgIGNodW5rID0gdGhpcy5jaHVuaztcbiAgZm9yICh2YXIgaSA9IHRoaXMub2Zmc2V0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoY2h1bmtbaV0gPT09IDB4MGEpIHsgLy8gXFxuXG4gICAgICB2YXIgbGluZSA9IHRoaXMubGluZSArIGNodW5rLnRvU3RyaW5nKEhUVFBQYXJzZXIuZW5jb2RpbmcsIHRoaXMub2Zmc2V0LCBpKTtcbiAgICAgIGlmIChsaW5lLmNoYXJBdChsaW5lLmxlbmd0aCAtIDEpID09PSAnXFxyJykge1xuICAgICAgICBsaW5lID0gbGluZS5zdWJzdHIoMCwgbGluZS5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGluZSA9ICcnO1xuICAgICAgdGhpcy5vZmZzZXQgPSBpICsgMTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgfVxuICAvL2xpbmUgc3BsaXQgb3ZlciBtdWx0aXBsZSBjaHVua3NcbiAgdGhpcy5saW5lICs9IGNodW5rLnRvU3RyaW5nKEhUVFBQYXJzZXIuZW5jb2RpbmcsIHRoaXMub2Zmc2V0LCB0aGlzLmVuZCk7XG4gIHRoaXMub2Zmc2V0ID0gdGhpcy5lbmQ7XG59O1xuXG52YXIgaGVhZGVyRXhwID0gL14oW146IFxcdF0rKTpbIFxcdF0qKCg/Oi4qW14gXFx0XSl8KS87XG52YXIgaGVhZGVyQ29udGludWVFeHAgPSAvXlsgXFx0XSsoLipbXiBcXHRdKS87XG5IVFRQUGFyc2VyLnByb3RvdHlwZS5wYXJzZUhlYWRlciA9IGZ1bmN0aW9uIChsaW5lLCBoZWFkZXJzKSB7XG4gIGlmIChsaW5lLmluZGV4T2YoJ1xccicpICE9PSAtMSkge1xuICAgIHRocm93IHBhcnNlRXJyb3JDb2RlKCdIUEVfTEZfRVhQRUNURUQnKTtcbiAgfVxuXG4gIHZhciBtYXRjaCA9IGhlYWRlckV4cC5leGVjKGxpbmUpO1xuICB2YXIgayA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICBpZiAoaykgeyAvLyBza2lwIGVtcHR5IHN0cmluZyAobWFsZm9ybWVkIGhlYWRlcilcbiAgICBoZWFkZXJzLnB1c2goayk7XG4gICAgaGVhZGVycy5wdXNoKG1hdGNoWzJdKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWF0Y2hDb250aW51ZSA9IGhlYWRlckNvbnRpbnVlRXhwLmV4ZWMobGluZSk7XG4gICAgaWYgKG1hdGNoQ29udGludWUgJiYgaGVhZGVycy5sZW5ndGgpIHtcbiAgICAgIGlmIChoZWFkZXJzW2hlYWRlcnMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgaGVhZGVyc1toZWFkZXJzLmxlbmd0aCAtIDFdICs9ICcgJztcbiAgICAgIH1cbiAgICAgIGhlYWRlcnNbaGVhZGVycy5sZW5ndGggLSAxXSArPSBtYXRjaENvbnRpbnVlWzFdO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHJlcXVlc3RFeHAgPSAvXihbQS1aLV0rKSAoW14gXSspIEhUVFBcXC8oXFxkKVxcLihcXGQpJC87XG5IVFRQUGFyc2VyLnByb3RvdHlwZS5SRVFVRVNUX0xJTkUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsaW5lID0gdGhpcy5jb25zdW1lTGluZSgpO1xuICBpZiAoIWxpbmUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gcmVxdWVzdEV4cC5leGVjKGxpbmUpO1xuICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICB0aHJvdyBwYXJzZUVycm9yQ29kZSgnSFBFX0lOVkFMSURfQ09OU1RBTlQnKTtcbiAgfVxuICB0aGlzLmluZm8ubWV0aG9kID0gdGhpcy5fY29tcGF0TW9kZTBfMTEgPyBtYXRjaFsxXSA6IG1ldGhvZHMuaW5kZXhPZihtYXRjaFsxXSk7XG4gIGlmICh0aGlzLmluZm8ubWV0aG9kID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZXF1ZXN0IG1ldGhvZCcpO1xuICB9XG4gIHRoaXMuaW5mby51cmwgPSBtYXRjaFsyXTtcbiAgdGhpcy5pbmZvLnZlcnNpb25NYWpvciA9ICttYXRjaFszXTtcbiAgdGhpcy5pbmZvLnZlcnNpb25NaW5vciA9ICttYXRjaFs0XTtcbiAgdGhpcy5ib2R5X2J5dGVzID0gMDtcbiAgdGhpcy5zdGF0ZSA9ICdIRUFERVInO1xufTtcblxudmFyIHJlc3BvbnNlRXhwID0gL15IVFRQXFwvKFxcZClcXC4oXFxkKSAoXFxkezN9KSA/KC4qKSQvO1xuSFRUUFBhcnNlci5wcm90b3R5cGUuUkVTUE9OU0VfTElORSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxpbmUgPSB0aGlzLmNvbnN1bWVMaW5lKCk7XG4gIGlmICghbGluZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSByZXNwb25zZUV4cC5leGVjKGxpbmUpO1xuICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICB0aHJvdyBwYXJzZUVycm9yQ29kZSgnSFBFX0lOVkFMSURfQ09OU1RBTlQnKTtcbiAgfVxuICB0aGlzLmluZm8udmVyc2lvbk1ham9yID0gK21hdGNoWzFdO1xuICB0aGlzLmluZm8udmVyc2lvbk1pbm9yID0gK21hdGNoWzJdO1xuICB2YXIgc3RhdHVzQ29kZSA9IHRoaXMuaW5mby5zdGF0dXNDb2RlID0gK21hdGNoWzNdO1xuICB0aGlzLmluZm8uc3RhdHVzTWVzc2FnZSA9IG1hdGNoWzRdO1xuICAvLyBJbXBsaWVkIHplcm8gbGVuZ3RoLlxuICBpZiAoKHN0YXR1c0NvZGUgLyAxMDAgfCAwKSA9PT0gMSB8fCBzdGF0dXNDb2RlID09PSAyMDQgfHwgc3RhdHVzQ29kZSA9PT0gMzA0KSB7XG4gICAgdGhpcy5ib2R5X2J5dGVzID0gMDtcbiAgfVxuICB0aGlzLnN0YXRlID0gJ0hFQURFUic7XG59O1xuXG5IVFRQUGFyc2VyLnByb3RvdHlwZS5zaG91bGRLZWVwQWxpdmUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmluZm8udmVyc2lvbk1ham9yID4gMCAmJiB0aGlzLmluZm8udmVyc2lvbk1pbm9yID4gMCkge1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb24uaW5kZXhPZignY2xvc2UnKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5jb25uZWN0aW9uLmluZGV4T2YoJ2tlZXAtYWxpdmUnKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRoaXMuYm9keV9ieXRlcyAhPT0gbnVsbCB8fCB0aGlzLmlzQ2h1bmtlZCkgeyAvLyB8fCBza2lwQm9keVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkhUVFBQYXJzZXIucHJvdG90eXBlLkhFQURFUiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxpbmUgPSB0aGlzLmNvbnN1bWVMaW5lKCk7XG4gIGlmIChsaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGluZm8gPSB0aGlzLmluZm87XG4gIGlmIChsaW5lKSB7XG4gICAgdGhpcy5wYXJzZUhlYWRlcihsaW5lLCBpbmZvLmhlYWRlcnMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBoZWFkZXJzID0gaW5mby5oZWFkZXJzO1xuICAgIHZhciBoYXNDb250ZW50TGVuZ3RoID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRDb250ZW50TGVuZ3RoVmFsdWU7XG4gICAgdmFyIGhhc1VwZ3JhZGVIZWFkZXIgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHN3aXRjaCAoaGVhZGVyc1tpXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ3RyYW5zZmVyLWVuY29kaW5nJzpcbiAgICAgICAgICB0aGlzLmlzQ2h1bmtlZCA9IGhlYWRlcnNbaSArIDFdLnRvTG93ZXJDYXNlKCkgPT09ICdjaHVua2VkJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29udGVudC1sZW5ndGgnOlxuICAgICAgICAgIGN1cnJlbnRDb250ZW50TGVuZ3RoVmFsdWUgPSAraGVhZGVyc1tpICsgMV07XG4gICAgICAgICAgaWYgKGhhc0NvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEZpeCBkdXBsaWNhdGUgQ29udGVudC1MZW5ndGggaGVhZGVyIHdpdGggc2FtZSB2YWx1ZXMuXG4gICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBvbmx5IGlmIHZhbHVlcyBhcmUgZGlmZmVyZW50LlxuICAgICAgICAgICAgLy8gS25vd24gaXNzdWVzOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlcXVlc3QvcmVxdWVzdC9pc3N1ZXMvMjA5MSNpc3N1ZWNvbW1lbnQtMzI4NzE1MTEzXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzY1MTcjaXNzdWVjb21tZW50LTIxNjI2Mzc3MVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDb250ZW50TGVuZ3RoVmFsdWUgIT09IHRoaXMuYm9keV9ieXRlcykge1xuICAgICAgICAgICAgICB0aHJvdyBwYXJzZUVycm9yQ29kZSgnSFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFzQ29udGVudExlbmd0aCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJvZHlfYnl0ZXMgPSBjdXJyZW50Q29udGVudExlbmd0aFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29ubmVjdGlvbic6XG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uICs9IGhlYWRlcnNbaSArIDFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3VwZ3JhZGUnOlxuICAgICAgICAgIGhhc1VwZ3JhZGVIZWFkZXIgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIGJvdGggaXNDaHVua2VkIGFuZCBoYXNDb250ZW50TGVuZ3RoLCBpc0NodW5rZWQgd2luc1xuICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgc28gdGhlIGJvZHkgaXMgcGFyc2VkIHVzaW5nIHRoZSBjaHVua2VkIG1ldGhvZCwgYW5kIG1hdGNoZXNcbiAgICAvLyBDaHJvbWUncyBiZWhhdmlvci4gIFdlIGNvdWxkLCBtYXliZSwgaWdub3JlIHRoZW0gYm90aCAod291bGQgZ2V0IGNodW5rZWRcbiAgICAvLyBlbmNvZGluZyBpbnRvIHRoZSBib2R5KSwgYW5kL29yIGRpc2FibGUgc2hvdWxkS2VlcEFsaXZlIHRvIGJlIG1vcmVcbiAgICAvLyByZXNpbGllbnQuXG4gICAgaWYgKHRoaXMuaXNDaHVua2VkICYmIGhhc0NvbnRlbnRMZW5ndGgpIHtcbiAgICAgIGhhc0NvbnRlbnRMZW5ndGggPSBmYWxzZTtcbiAgICAgIHRoaXMuYm9keV9ieXRlcyA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gTG9naWMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL2h0dHAtcGFyc2VyL2Jsb2IvOTIxZDU1ODU1MTVhMTUzZmEwMGU0MTFjZjE0NDI4MGM1OWI0MWY5MC9odHRwX3BhcnNlci5jI0wxNzI3LUwxNzM3XG4gICAgLy8gXCJGb3IgcmVzcG9uc2VzLCBcIlVwZ3JhZGU6IGZvb1wiIGFuZCBcIkNvbm5lY3Rpb246IHVwZ3JhZGVcIiBhcmVcbiAgICAvLyAgIG1hbmRhdG9yeSBvbmx5IHdoZW4gaXQgaXMgYSAxMDEgU3dpdGNoaW5nIFByb3RvY29scyByZXNwb25zZSxcbiAgICAvLyAgIG90aGVyd2lzZSBpdCBpcyBwdXJlbHkgaW5mb3JtYXRpb25hbCwgdG8gYW5ub3VuY2Ugc3VwcG9ydC5cbiAgICBpZiAoaGFzVXBncmFkZUhlYWRlciAmJiB0aGlzLmNvbm5lY3Rpb24uaW5kZXhPZigndXBncmFkZScpICE9IC0xKSB7XG4gICAgICBpbmZvLnVwZ3JhZGUgPSB0aGlzLnR5cGUgPT09IEhUVFBQYXJzZXIuUkVRVUVTVCB8fCBpbmZvLnN0YXR1c0NvZGUgPT09IDEwMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mby51cGdyYWRlID0gaW5mby5tZXRob2QgPT09IG1ldGhvZF9jb25uZWN0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzQ2h1bmtlZCAmJiBpbmZvLnVwZ3JhZGUpIHtcbiAgICAgIHRoaXMuaXNDaHVua2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaW5mby5zaG91bGRLZWVwQWxpdmUgPSB0aGlzLnNob3VsZEtlZXBBbGl2ZSgpO1xuICAgIC8vcHJvYmxlbSB3aGljaCBhbHNvIGV4aXN0cyBpbiBvcmlnaW5hbCBub2RlOiB3ZSBzaG91bGQga25vdyBza2lwQm9keSBiZWZvcmUgY2FsbGluZyBvbkhlYWRlcnNDb21wbGV0ZVxuICAgIHZhciBza2lwQm9keTtcbiAgICBpZiAoY29tcGF0TW9kZTBfMTIpIHtcbiAgICAgIHNraXBCb2R5ID0gdGhpcy51c2VyQ2FsbCgpKHRoaXNba09uSGVhZGVyc0NvbXBsZXRlXShpbmZvKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNraXBCb2R5ID0gdGhpcy51c2VyQ2FsbCgpKHRoaXNba09uSGVhZGVyc0NvbXBsZXRlXShpbmZvLnZlcnNpb25NYWpvcixcbiAgICAgICAgICBpbmZvLnZlcnNpb25NaW5vciwgaW5mby5oZWFkZXJzLCBpbmZvLm1ldGhvZCwgaW5mby51cmwsIGluZm8uc3RhdHVzQ29kZSxcbiAgICAgICAgICBpbmZvLnN0YXR1c01lc3NhZ2UsIGluZm8udXBncmFkZSwgaW5mby5zaG91bGRLZWVwQWxpdmUpKTtcbiAgICB9XG4gICAgaWYgKHNraXBCb2R5ID09PSAyKSB7XG4gICAgICB0aGlzLm5leHRSZXF1ZXN0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDaHVua2VkICYmICFza2lwQm9keSkge1xuICAgICAgdGhpcy5zdGF0ZSA9ICdCT0RZX0NIVU5LSEVBRCc7XG4gICAgfSBlbHNlIGlmIChza2lwQm9keSB8fCB0aGlzLmJvZHlfYnl0ZXMgPT09IDApIHtcbiAgICAgIHRoaXMubmV4dFJlcXVlc3QoKTtcbiAgICAgIC8vIEZvciBvbGRlciB2ZXJzaW9ucyBvZiBub2RlICh2Ni54IGFuZCBvbGRlcj8pLCB0aGF0IHJldHVybiBza2lwQm9keT0xIG9yIHNraXBCb2R5PXRydWUsXG4gICAgICAvLyAgIG5lZWQgdGhpcyBcInJldHVybiB0cnVlO1wiIGlmIGl0J3MgYW4gdXBncmFkZSByZXF1ZXN0LlxuICAgICAgcmV0dXJuIGluZm8udXBncmFkZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYm9keV9ieXRlcyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdGF0ZSA9ICdCT0RZX1JBVyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAnQk9EWV9TSVpFRCc7XG4gICAgfVxuICB9XG59O1xuXG5IVFRQUGFyc2VyLnByb3RvdHlwZS5CT0RZX0NIVU5LSEVBRCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxpbmUgPSB0aGlzLmNvbnN1bWVMaW5lKCk7XG4gIGlmIChsaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5ib2R5X2J5dGVzID0gcGFyc2VJbnQobGluZSwgMTYpO1xuICBpZiAoIXRoaXMuYm9keV9ieXRlcykge1xuICAgIHRoaXMuc3RhdGUgPSAnQk9EWV9DSFVOS1RSQUlMRVJTJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YXRlID0gJ0JPRFlfQ0hVTksnO1xuICB9XG59O1xuXG5IVFRQUGFyc2VyLnByb3RvdHlwZS5CT0RZX0NIVU5LID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4odGhpcy5lbmQgLSB0aGlzLm9mZnNldCwgdGhpcy5ib2R5X2J5dGVzKTtcbiAgdGhpcy51c2VyQ2FsbCgpKHRoaXNba09uQm9keV0odGhpcy5jaHVuaywgdGhpcy5vZmZzZXQsIGxlbmd0aCkpO1xuICB0aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gIHRoaXMuYm9keV9ieXRlcyAtPSBsZW5ndGg7XG4gIGlmICghdGhpcy5ib2R5X2J5dGVzKSB7XG4gICAgdGhpcy5zdGF0ZSA9ICdCT0RZX0NIVU5LRU1QVFlMSU5FJztcbiAgfVxufTtcblxuSFRUUFBhcnNlci5wcm90b3R5cGUuQk9EWV9DSFVOS0VNUFRZTElORSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxpbmUgPSB0aGlzLmNvbnN1bWVMaW5lKCk7XG4gIGlmIChsaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0LmVxdWFsKGxpbmUsICcnKTtcbiAgdGhpcy5zdGF0ZSA9ICdCT0RZX0NIVU5LSEVBRCc7XG59O1xuXG5IVFRQUGFyc2VyLnByb3RvdHlwZS5CT0RZX0NIVU5LVFJBSUxFUlMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsaW5lID0gdGhpcy5jb25zdW1lTGluZSgpO1xuICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChsaW5lKSB7XG4gICAgdGhpcy5wYXJzZUhlYWRlcihsaW5lLCB0aGlzLnRyYWlsZXJzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy50cmFpbGVycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudXNlckNhbGwoKSh0aGlzW2tPbkhlYWRlcnNdKHRoaXMudHJhaWxlcnMsICcnKSk7XG4gICAgfVxuICAgIHRoaXMubmV4dFJlcXVlc3QoKTtcbiAgfVxufTtcblxuSFRUUFBhcnNlci5wcm90b3R5cGUuQk9EWV9SQVcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmVuZCAtIHRoaXMub2Zmc2V0O1xuICB0aGlzLnVzZXJDYWxsKCkodGhpc1trT25Cb2R5XSh0aGlzLmNodW5rLCB0aGlzLm9mZnNldCwgbGVuZ3RoKSk7XG4gIHRoaXMub2Zmc2V0ID0gdGhpcy5lbmQ7XG59O1xuXG5IVFRQUGFyc2VyLnByb3RvdHlwZS5CT0RZX1NJWkVEID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4odGhpcy5lbmQgLSB0aGlzLm9mZnNldCwgdGhpcy5ib2R5X2J5dGVzKTtcbiAgdGhpcy51c2VyQ2FsbCgpKHRoaXNba09uQm9keV0odGhpcy5jaHVuaywgdGhpcy5vZmZzZXQsIGxlbmd0aCkpO1xuICB0aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gIHRoaXMuYm9keV9ieXRlcyAtPSBsZW5ndGg7XG4gIGlmICghdGhpcy5ib2R5X2J5dGVzKSB7XG4gICAgdGhpcy5uZXh0UmVxdWVzdCgpO1xuICB9XG59O1xuXG4vLyBiYWNrd2FyZCBjb21wYXQgdG8gbm9kZSA8IDAuMTEuNlxuWydIZWFkZXJzJywgJ0hlYWRlcnNDb21wbGV0ZScsICdCb2R5JywgJ01lc3NhZ2VDb21wbGV0ZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGsgPSBIVFRQUGFyc2VyWydrT24nICsgbmFtZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVFRQUGFyc2VyLnByb3RvdHlwZSwgJ29uJyArIG5hbWUsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzW2tdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodG8pIHtcbiAgICAgIC8vIGhhY2sgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgIHRoaXMuX2NvbXBhdE1vZGUwXzExID0gdHJ1ZTtcbiAgICAgIG1ldGhvZF9jb25uZWN0ID0gJ0NPTk5FQ1QnO1xuICAgICAgcmV0dXJuICh0aGlzW2tdID0gdG8pO1xuICAgIH1cbiAgfSk7XG59KTtcblxuZnVuY3Rpb24gcGFyc2VFcnJvckNvZGUoY29kZSkge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKCdQYXJzZSBFcnJvcicpO1xuICBlcnIuY29kZSA9IGNvZGU7XG4gIHJldHVybiBlcnI7XG59XG5cblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFBhcnNlciAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCksXG4gICAgUGlwZWxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblxudmFyIEV4dGVuc2lvbnMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcnN2MSA9IHRoaXMuX3JzdjIgPSB0aGlzLl9yc3YzID0gbnVsbDtcblxuICB0aGlzLl9ieU5hbWUgICA9IHt9O1xuICB0aGlzLl9pbk9yZGVyICA9IFtdO1xuICB0aGlzLl9zZXNzaW9ucyA9IFtdO1xuICB0aGlzLl9pbmRleCAgICA9IHt9O1xufTtcblxuRXh0ZW5zaW9ucy5NRVNTQUdFX09QQ09ERVMgPSBbMSwgMl07XG5cbnZhciBpbnN0YW5jZSA9IHtcbiAgYWRkOiBmdW5jdGlvbihleHQpIHtcbiAgICBpZiAodHlwZW9mIGV4dC5uYW1lICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignZXh0ZW5zaW9uLm5hbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIGlmIChleHQudHlwZSAhPT0gJ3Blcm1lc3NhZ2UnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHRlbnNpb24udHlwZSBtdXN0IGJlIFwicGVybWVzc2FnZVwiJyk7XG5cbiAgICBpZiAodHlwZW9mIGV4dC5yc3YxICE9PSAnYm9vbGVhbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4dGVuc2lvbi5yc3YxIG11c3QgYmUgdHJ1ZSBvciBmYWxzZScpO1xuICAgIGlmICh0eXBlb2YgZXh0LnJzdjIgIT09ICdib29sZWFuJykgdGhyb3cgbmV3IFR5cGVFcnJvcignZXh0ZW5zaW9uLnJzdjIgbXVzdCBiZSB0cnVlIG9yIGZhbHNlJyk7XG4gICAgaWYgKHR5cGVvZiBleHQucnN2MyAhPT0gJ2Jvb2xlYW4nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHRlbnNpb24ucnN2MyBtdXN0IGJlIHRydWUgb3IgZmFsc2UnKTtcblxuICAgIGlmICh0aGlzLl9ieU5hbWUuaGFzT3duUHJvcGVydHkoZXh0Lm5hbWUpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQW4gZXh0ZW5zaW9uIHdpdGggbmFtZSBcIicgKyBleHQubmFtZSArICdcIiBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQnKTtcblxuICAgIHRoaXMuX2J5TmFtZVtleHQubmFtZV0gPSBleHQ7XG4gICAgdGhpcy5faW5PcmRlci5wdXNoKGV4dCk7XG4gIH0sXG5cbiAgZ2VuZXJhdGVPZmZlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlc3Npb25zID0gW10sXG4gICAgICAgIG9mZmVyICAgID0gW10sXG4gICAgICAgIGluZGV4ICAgID0ge307XG5cbiAgICB0aGlzLl9pbk9yZGVyLmZvckVhY2goZnVuY3Rpb24oZXh0KSB7XG4gICAgICB2YXIgc2Vzc2lvbiA9IGV4dC5jcmVhdGVDbGllbnRTZXNzaW9uKCk7XG4gICAgICBpZiAoIXNlc3Npb24pIHJldHVybjtcblxuICAgICAgdmFyIHJlY29yZCA9IFtleHQsIHNlc3Npb25dO1xuICAgICAgc2Vzc2lvbnMucHVzaChyZWNvcmQpO1xuICAgICAgaW5kZXhbZXh0Lm5hbWVdID0gcmVjb3JkO1xuXG4gICAgICB2YXIgb2ZmZXJzID0gc2Vzc2lvbi5nZW5lcmF0ZU9mZmVyKCk7XG4gICAgICBvZmZlcnMgPSBvZmZlcnMgPyBbXS5jb25jYXQob2ZmZXJzKSA6IFtdO1xuXG4gICAgICBvZmZlcnMuZm9yRWFjaChmdW5jdGlvbihvZmYpIHtcbiAgICAgICAgb2ZmZXIucHVzaChQYXJzZXIuc2VyaWFsaXplUGFyYW1zKGV4dC5uYW1lLCBvZmYpKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fc2Vzc2lvbnMgPSBzZXNzaW9ucztcbiAgICB0aGlzLl9pbmRleCAgICA9IGluZGV4O1xuXG4gICAgcmV0dXJuIG9mZmVyLmxlbmd0aCA+IDAgPyBvZmZlci5qb2luKCcsICcpIDogbnVsbDtcbiAgfSxcblxuICBhY3RpdmF0ZTogZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgdmFyIHJlc3BvbnNlcyA9IFBhcnNlci5wYXJzZUhlYWRlcihoZWFkZXIpLFxuICAgICAgICBzZXNzaW9ucyAgPSBbXTtcblxuICAgIHJlc3BvbnNlcy5lYWNoT2ZmZXIoZnVuY3Rpb24obmFtZSwgcGFyYW1zKSB7XG4gICAgICB2YXIgcmVjb3JkID0gdGhpcy5faW5kZXhbbmFtZV07XG5cbiAgICAgIGlmICghcmVjb3JkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciBzZW50IGFuIGV4dGVuc2lvbiByZXNwb25zZSBmb3IgdW5rbm93biBleHRlbnNpb24gXCInICsgbmFtZSArICdcIicpO1xuXG4gICAgICB2YXIgZXh0ICAgICAgPSByZWNvcmRbMF0sXG4gICAgICAgICAgc2Vzc2lvbiAgPSByZWNvcmRbMV0sXG4gICAgICAgICAgcmVzZXJ2ZWQgPSB0aGlzLl9yZXNlcnZlZChleHQpO1xuXG4gICAgICBpZiAocmVzZXJ2ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmVyIHNlbnQgdHdvIGV4dGVuc2lvbiByZXNwb25zZXMgdGhhdCB1c2UgdGhlIFJTVicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXJ2ZWRbMF0gKyAnIGJpdDogXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2VydmVkWzFdICsgJ1wiIGFuZCBcIicgKyBleHQubmFtZSArICdcIicpO1xuXG4gICAgICBpZiAoc2Vzc2lvbi5hY3RpdmF0ZShwYXJhbXMpICE9PSB0cnVlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciBzZW50IHVuYWNjZXB0YWJsZSBleHRlbnNpb24gcGFyYW1ldGVyczogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBQYXJzZXIuc2VyaWFsaXplUGFyYW1zKG5hbWUsIHBhcmFtcykpO1xuXG4gICAgICB0aGlzLl9yZXNlcnZlKGV4dCk7XG4gICAgICBzZXNzaW9ucy5wdXNoKHJlY29yZCk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9zZXNzaW9ucyA9IHNlc3Npb25zO1xuICAgIHRoaXMuX3BpcGVsaW5lID0gbmV3IFBpcGVsaW5lKHNlc3Npb25zKTtcbiAgfSxcblxuICBnZW5lcmF0ZVJlc3BvbnNlOiBmdW5jdGlvbihoZWFkZXIpIHtcbiAgICB2YXIgc2Vzc2lvbnMgPSBbXSxcbiAgICAgICAgcmVzcG9uc2UgPSBbXSxcbiAgICAgICAgb2ZmZXJzICAgPSBQYXJzZXIucGFyc2VIZWFkZXIoaGVhZGVyKTtcblxuICAgIHRoaXMuX2luT3JkZXIuZm9yRWFjaChmdW5jdGlvbihleHQpIHtcbiAgICAgIHZhciBvZmZlciA9IG9mZmVycy5ieU5hbWUoZXh0Lm5hbWUpO1xuICAgICAgaWYgKG9mZmVyLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9yZXNlcnZlZChleHQpKSByZXR1cm47XG5cbiAgICAgIHZhciBzZXNzaW9uID0gZXh0LmNyZWF0ZVNlcnZlclNlc3Npb24ob2ZmZXIpO1xuICAgICAgaWYgKCFzZXNzaW9uKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX3Jlc2VydmUoZXh0KTtcbiAgICAgIHNlc3Npb25zLnB1c2goW2V4dCwgc2Vzc2lvbl0pO1xuICAgICAgcmVzcG9uc2UucHVzaChQYXJzZXIuc2VyaWFsaXplUGFyYW1zKGV4dC5uYW1lLCBzZXNzaW9uLmdlbmVyYXRlUmVzcG9uc2UoKSkpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fc2Vzc2lvbnMgPSBzZXNzaW9ucztcbiAgICB0aGlzLl9waXBlbGluZSA9IG5ldyBQaXBlbGluZShzZXNzaW9ucyk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2UubGVuZ3RoID4gMCA/IHJlc3BvbnNlLmpvaW4oJywgJykgOiBudWxsO1xuICB9LFxuXG4gIHZhbGlkRnJhbWVSc3Y6IGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgdmFyIGFsbG93ZWQgPSB7IHJzdjE6IGZhbHNlLCByc3YyOiBmYWxzZSwgcnN2MzogZmFsc2UgfSxcbiAgICAgICAgZXh0O1xuXG4gICAgaWYgKEV4dGVuc2lvbnMuTUVTU0FHRV9PUENPREVTLmluZGV4T2YoZnJhbWUub3Bjb2RlKSA+PSAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuX3Nlc3Npb25zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBleHQgPSB0aGlzLl9zZXNzaW9uc1tpXVswXTtcbiAgICAgICAgYWxsb3dlZC5yc3YxID0gYWxsb3dlZC5yc3YxIHx8IGV4dC5yc3YxO1xuICAgICAgICBhbGxvd2VkLnJzdjIgPSBhbGxvd2VkLnJzdjIgfHwgZXh0LnJzdjI7XG4gICAgICAgIGFsbG93ZWQucnN2MyA9IGFsbG93ZWQucnN2MyB8fCBleHQucnN2MztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGFsbG93ZWQucnN2MSB8fCAhZnJhbWUucnN2MSkgJiZcbiAgICAgICAgICAgKGFsbG93ZWQucnN2MiB8fCAhZnJhbWUucnN2MikgJiZcbiAgICAgICAgICAgKGFsbG93ZWQucnN2MyB8fCAhZnJhbWUucnN2Myk7XG4gIH0sXG5cbiAgcHJvY2Vzc0luY29taW5nTWVzc2FnZTogZnVuY3Rpb24obWVzc2FnZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl9waXBlbGluZS5wcm9jZXNzSW5jb21pbmdNZXNzYWdlKG1lc3NhZ2UsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfSxcblxuICBwcm9jZXNzT3V0Z29pbmdNZXNzYWdlOiBmdW5jdGlvbihtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHRoaXMuX3BpcGVsaW5lLnByb2Nlc3NPdXRnb2luZ01lc3NhZ2UobWVzc2FnZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbihjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGlmICghdGhpcy5fcGlwZWxpbmUpIHJldHVybiBjYWxsYmFjay5jYWxsKGNvbnRleHQpO1xuICAgIHRoaXMuX3BpcGVsaW5lLmNsb3NlKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfSxcblxuICBfcmVzZXJ2ZTogZnVuY3Rpb24oZXh0KSB7XG4gICAgdGhpcy5fcnN2MSA9IHRoaXMuX3JzdjEgfHwgKGV4dC5yc3YxICYmIGV4dC5uYW1lKTtcbiAgICB0aGlzLl9yc3YyID0gdGhpcy5fcnN2MiB8fCAoZXh0LnJzdjIgJiYgZXh0Lm5hbWUpO1xuICAgIHRoaXMuX3JzdjMgPSB0aGlzLl9yc3YzIHx8IChleHQucnN2MyAmJiBleHQubmFtZSk7XG4gIH0sXG5cbiAgX3Jlc2VydmVkOiBmdW5jdGlvbihleHQpIHtcbiAgICBpZiAodGhpcy5fcnN2MSAmJiBleHQucnN2MSkgcmV0dXJuIFsxLCB0aGlzLl9yc3YxXTtcbiAgICBpZiAodGhpcy5fcnN2MiAmJiBleHQucnN2MikgcmV0dXJuIFsyLCB0aGlzLl9yc3YyXTtcbiAgICBpZiAodGhpcy5fcnN2MyAmJiBleHQucnN2MykgcmV0dXJuIFszLCB0aGlzLl9yc3YzXTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZvciAodmFyIGtleSBpbiBpbnN0YW5jZSlcbiAgRXh0ZW5zaW9ucy5wcm90b3R5cGVba2V5XSA9IGluc3RhbmNlW2tleV07XG5cbm1vZHVsZS5leHBvcnRzID0gRXh0ZW5zaW9ucztcblxuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBUT0tFTiAgICA9IC8oWyEjXFwkJSYnXFwqXFwrXFwtXFwuXFxeX2BcXHx+MC05QS1aYS16XSspLyxcbiAgICBOT1RPS0VOICA9IC8oW14hI1xcJCUmJ1xcKlxcK1xcLVxcLlxcXl9gXFx8fjAtOUEtWmEtel0pL2csXG4gICAgUVVPVEVEICAgPSAvXCIoKD86XFxcXFtcXHgwMC1cXHg3Zl18W15cXHgwMC1cXHgwOFxceDBhLVxceDFmXFx4N2ZcIlxcXFxdKSopXCIvLFxuICAgIFBBUkFNICAgID0gbmV3IFJlZ0V4cChUT0tFTi5zb3VyY2UgKyAnKD86PSg/OicgKyBUT0tFTi5zb3VyY2UgKyAnfCcgKyBRVU9URUQuc291cmNlICsgJykpPycpLFxuICAgIEVYVCAgICAgID0gbmV3IFJlZ0V4cChUT0tFTi5zb3VyY2UgKyAnKD86ICo7IConICsgUEFSQU0uc291cmNlICsgJykqJywgJ2cnKSxcbiAgICBFWFRfTElTVCA9IG5ldyBSZWdFeHAoJ14nICsgRVhULnNvdXJjZSArICcoPzogKiwgKicgKyBFWFQuc291cmNlICsgJykqJCcpLFxuICAgIE5VTUJFUiAgID0gL14tPygwfFsxLTldWzAtOV0qKShcXC5bMC05XSspPyQvO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUGFyc2VyID0ge1xuICBwYXJzZUhlYWRlcjogZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgdmFyIG9mZmVycyA9IG5ldyBPZmZlcnMoKTtcbiAgICBpZiAoaGVhZGVyID09PSAnJyB8fCBoZWFkZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG9mZmVycztcblxuICAgIGlmICghRVhUX0xJU1QudGVzdChoZWFkZXIpKVxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXI6ICcgKyBoZWFkZXIpO1xuXG4gICAgdmFyIHZhbHVlcyA9IGhlYWRlci5tYXRjaChFWFQpO1xuXG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBwYXJhbXMgPSB2YWx1ZS5tYXRjaChuZXcgUmVnRXhwKFBBUkFNLnNvdXJjZSwgJ2cnKSksXG4gICAgICAgICAgbmFtZSAgID0gcGFyYW1zLnNoaWZ0KCksXG4gICAgICAgICAgb2ZmZXIgID0ge307XG5cbiAgICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHZhciBhcmdzID0gcGFyYW0ubWF0Y2goUEFSQU0pLCBrZXkgPSBhcmdzWzFdLCBkYXRhO1xuXG4gICAgICAgIGlmIChhcmdzWzJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkYXRhID0gYXJnc1syXTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmdzWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkYXRhID0gYXJnc1szXS5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTlVNQkVSLnRlc3QoZGF0YSkpIGRhdGEgPSBwYXJzZUZsb2F0KGRhdGEpO1xuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9mZmVyLCBrZXkpKSB7XG4gICAgICAgICAgb2ZmZXJba2V5XSA9IFtdLmNvbmNhdChvZmZlcltrZXldKTtcbiAgICAgICAgICBvZmZlcltrZXldLnB1c2goZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmZXJba2V5XSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgb2ZmZXJzLnB1c2gobmFtZSwgb2ZmZXIpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgcmV0dXJuIG9mZmVycztcbiAgfSxcblxuICBzZXJpYWxpemVQYXJhbXM6IGZ1bmN0aW9uKG5hbWUsIHBhcmFtcykge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIHZhciBwcmludCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24odikgeyBwcmludChrZXksIHYpIH0pO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YWx1ZXMucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGtleSArICc9JyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoTk9UT0tFTi50ZXN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZXMucHVzaChrZXkgKyAnPVwiJyArIHZhbHVlLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSArICdcIicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzLnB1c2goa2V5ICsgJz0nICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSBwcmludChrZXksIHBhcmFtc1trZXldKTtcblxuICAgIHJldHVybiBbbmFtZV0uY29uY2F0KHZhbHVlcykuam9pbignOyAnKTtcbiAgfVxufTtcblxudmFyIE9mZmVycyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9ieU5hbWUgID0ge307XG4gIHRoaXMuX2luT3JkZXIgPSBbXTtcbn07XG5cbk9mZmVycy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKG5hbWUsIHBhcmFtcykge1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwodGhpcy5fYnlOYW1lLCBuYW1lKSlcbiAgICB0aGlzLl9ieU5hbWVbbmFtZV0gPSBbXTtcblxuICB0aGlzLl9ieU5hbWVbbmFtZV0ucHVzaChwYXJhbXMpO1xuICB0aGlzLl9pbk9yZGVyLnB1c2goeyBuYW1lOiBuYW1lLCBwYXJhbXM6IHBhcmFtcyB9KTtcbn07XG5cbk9mZmVycy5wcm90b3R5cGUuZWFjaE9mZmVyID0gZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgdmFyIGxpc3QgPSB0aGlzLl9pbk9yZGVyO1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGxpc3QubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgbGlzdFtpXS5uYW1lLCBsaXN0W2ldLnBhcmFtcyk7XG59O1xuXG5PZmZlcnMucHJvdG90eXBlLmJ5TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuX2J5TmFtZVtuYW1lXSB8fCBbXTtcbn07XG5cbk9mZmVycy5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faW5PcmRlci5zbGljZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXI7XG5cblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgQ2VsbCAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMiksXG4gICAgUGxlZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbnZhciBQaXBlbGluZSA9IGZ1bmN0aW9uKHNlc3Npb25zKSB7XG4gIHRoaXMuX2NlbGxzICAgPSBzZXNzaW9ucy5tYXAoZnVuY3Rpb24oc2Vzc2lvbikgeyByZXR1cm4gbmV3IENlbGwoc2Vzc2lvbikgfSk7XG4gIHRoaXMuX3N0b3BwZWQgPSB7IGluY29taW5nOiBmYWxzZSwgb3V0Z29pbmc6IGZhbHNlIH07XG59O1xuXG5QaXBlbGluZS5wcm90b3R5cGUucHJvY2Vzc0luY29taW5nTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICh0aGlzLl9zdG9wcGVkLmluY29taW5nKSByZXR1cm47XG4gIHRoaXMuX2xvb3AoJ2luY29taW5nJywgdGhpcy5fY2VsbHMubGVuZ3RoIC0gMSwgLTEsIC0xLCBtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCk7XG59O1xuXG5QaXBlbGluZS5wcm90b3R5cGUucHJvY2Vzc091dGdvaW5nTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICh0aGlzLl9zdG9wcGVkLm91dGdvaW5nKSByZXR1cm47XG4gIHRoaXMuX2xvb3AoJ291dGdvaW5nJywgMCwgdGhpcy5fY2VsbHMubGVuZ3RoLCAxLCBtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCk7XG59O1xuXG5QaXBlbGluZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjYWxsYmFjaywgY29udGV4dCkge1xuICB0aGlzLl9zdG9wcGVkID0geyBpbmNvbWluZzogdHJ1ZSwgb3V0Z29pbmc6IHRydWUgfTtcblxuICB2YXIgY2xvc2VkID0gdGhpcy5fY2VsbHMubWFwKGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGEuY2xvc2UoKSB9KTtcbiAgaWYgKGNhbGxiYWNrKVxuICAgIFBsZWRnZS5hbGwoY2xvc2VkKS50aGVuKGZ1bmN0aW9uKCkgeyBjYWxsYmFjay5jYWxsKGNvbnRleHQpIH0pO1xufTtcblxuUGlwZWxpbmUucHJvdG90eXBlLl9sb29wID0gZnVuY3Rpb24oZGlyZWN0aW9uLCBzdGFydCwgZW5kLCBzdGVwLCBtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCkge1xuICB2YXIgY2VsbHMgPSB0aGlzLl9jZWxscyxcbiAgICAgIG4gICAgID0gY2VsbHMubGVuZ3RoLFxuICAgICAgc2VsZiAgPSB0aGlzO1xuXG4gIHdoaWxlIChuLS0pIGNlbGxzW25dLnBlbmRpbmcoZGlyZWN0aW9uKTtcblxuICB2YXIgcGlwZSA9IGZ1bmN0aW9uKGluZGV4LCBlcnJvciwgbXNnKSB7XG4gICAgaWYgKGluZGV4ID09PSBlbmQpIHJldHVybiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGVycm9yLCBtc2cpO1xuXG4gICAgY2VsbHNbaW5kZXhdW2RpcmVjdGlvbl0oZXJyb3IsIG1zZywgZnVuY3Rpb24oZXJyLCBtKSB7XG4gICAgICBpZiAoZXJyKSBzZWxmLl9zdG9wcGVkW2RpcmVjdGlvbl0gPSB0cnVlO1xuICAgICAgcGlwZShpbmRleCArIHN0ZXAsIGVyciwgbSk7XG4gICAgfSk7XG4gIH07XG4gIHBpcGUoc3RhcnQsIG51bGwsIG1lc3NhZ2UpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQaXBlbGluZTtcblxuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBGdW5jdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyksXG4gICAgUGxlZGdlICA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgQ2VsbCA9IGZ1bmN0aW9uKHR1cGxlKSB7XG4gIHRoaXMuX2V4dCAgICAgPSB0dXBsZVswXTtcbiAgdGhpcy5fc2Vzc2lvbiA9IHR1cGxlWzFdO1xuXG4gIHRoaXMuX2Z1bmN0b3JzID0ge1xuICAgIGluY29taW5nOiBuZXcgRnVuY3Rvcih0aGlzLl9zZXNzaW9uLCAncHJvY2Vzc0luY29taW5nTWVzc2FnZScpLFxuICAgIG91dGdvaW5nOiBuZXcgRnVuY3Rvcih0aGlzLl9zZXNzaW9uLCAncHJvY2Vzc091dGdvaW5nTWVzc2FnZScpXG4gIH07XG59O1xuXG5DZWxsLnByb3RvdHlwZS5wZW5kaW5nID0gZnVuY3Rpb24oZGlyZWN0aW9uKSB7XG4gIHZhciBmdW5jdG9yID0gdGhpcy5fZnVuY3RvcnNbZGlyZWN0aW9uXTtcbiAgaWYgKCFmdW5jdG9yLl9zdG9wcGVkKSBmdW5jdG9yLnBlbmRpbmcgKz0gMTtcbn07XG5cbkNlbGwucHJvdG90eXBlLmluY29taW5nID0gZnVuY3Rpb24oZXJyb3IsIG1lc3NhZ2UsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIHRoaXMuX2V4ZWMoJ2luY29taW5nJywgZXJyb3IsIG1lc3NhZ2UsIGNhbGxiYWNrLCBjb250ZXh0KTtcbn07XG5cbkNlbGwucHJvdG90eXBlLm91dGdvaW5nID0gZnVuY3Rpb24oZXJyb3IsIG1lc3NhZ2UsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIHRoaXMuX2V4ZWMoJ291dGdvaW5nJywgZXJyb3IsIG1lc3NhZ2UsIGNhbGxiYWNrLCBjb250ZXh0KTtcbn07XG5cbkNlbGwucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2Nsb3NlZCA9IHRoaXMuX2Nsb3NlZCB8fCBuZXcgUGxlZGdlKCk7XG4gIHRoaXMuX2RvQ2xvc2UoKTtcbiAgcmV0dXJuIHRoaXMuX2Nsb3NlZDtcbn07XG5cbkNlbGwucHJvdG90eXBlLl9leGVjID0gZnVuY3Rpb24oZGlyZWN0aW9uLCBlcnJvciwgbWVzc2FnZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgdGhpcy5fZnVuY3RvcnNbZGlyZWN0aW9uXS5jYWxsKGVycm9yLCBtZXNzYWdlLCBmdW5jdGlvbihlcnIsIG1zZykge1xuICAgIGlmIChlcnIpIGVyci5tZXNzYWdlID0gdGhpcy5fZXh0Lm5hbWUgKyAnOiAnICsgZXJyLm1lc3NhZ2U7XG4gICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBlcnIsIG1zZyk7XG4gICAgdGhpcy5fZG9DbG9zZSgpO1xuICB9LCB0aGlzKTtcbn07XG5cbkNlbGwucHJvdG90eXBlLl9kb0Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmaW4gID0gdGhpcy5fZnVuY3RvcnMuaW5jb21pbmcsXG4gICAgICBmb3V0ID0gdGhpcy5fZnVuY3RvcnMub3V0Z29pbmc7XG5cbiAgaWYgKCF0aGlzLl9jbG9zZWQgfHwgZmluLnBlbmRpbmcgKyBmb3V0LnBlbmRpbmcgIT09IDApIHJldHVybjtcbiAgaWYgKHRoaXMuX3Nlc3Npb24pIHRoaXMuX3Nlc3Npb24uY2xvc2UoKTtcbiAgdGhpcy5fc2Vzc2lvbiA9IG51bGw7XG4gIHRoaXMuX2Nsb3NlZC5kb25lKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlbGw7XG5cblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgUmluZ0J1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgRnVuY3RvciA9IGZ1bmN0aW9uKHNlc3Npb24sIG1ldGhvZCkge1xuICB0aGlzLl9zZXNzaW9uID0gc2Vzc2lvbjtcbiAgdGhpcy5fbWV0aG9kICA9IG1ldGhvZDtcbiAgdGhpcy5fcXVldWUgICA9IG5ldyBSaW5nQnVmZmVyKEZ1bmN0b3IuUVVFVUVfU0laRSk7XG4gIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgdGhpcy5wZW5kaW5nICA9IDA7XG59O1xuXG5GdW5jdG9yLlFVRVVFX1NJWkUgPSA4O1xuXG5GdW5jdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24oZXJyb3IsIG1lc3NhZ2UsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICh0aGlzLl9zdG9wcGVkKSByZXR1cm47XG5cbiAgdmFyIHJlY29yZCA9IHsgZXJyb3I6IGVycm9yLCBtZXNzYWdlOiBtZXNzYWdlLCBjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQsIGRvbmU6IGZhbHNlIH0sXG4gICAgICBjYWxsZWQgPSBmYWxzZSxcbiAgICAgIHNlbGYgICA9IHRoaXM7XG5cbiAgdGhpcy5fcXVldWUucHVzaChyZWNvcmQpO1xuXG4gIGlmIChyZWNvcmQuZXJyb3IpIHtcbiAgICByZWNvcmQuZG9uZSA9IHRydWU7XG4gICAgdGhpcy5fc3RvcCgpO1xuICAgIHJldHVybiB0aGlzLl9mbHVzaFF1ZXVlKCk7XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKGVyciwgbXNnKSB7XG4gICAgaWYgKCEoY2FsbGVkIF4gKGNhbGxlZCA9IHRydWUpKSkgcmV0dXJuO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgc2VsZi5fc3RvcCgpO1xuICAgICAgcmVjb3JkLmVycm9yICAgPSBlcnI7XG4gICAgICByZWNvcmQubWVzc2FnZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29yZC5tZXNzYWdlID0gbXNnO1xuICAgIH1cblxuICAgIHJlY29yZC5kb25lID0gdHJ1ZTtcbiAgICBzZWxmLl9mbHVzaFF1ZXVlKCk7XG4gIH07XG5cbiAgdHJ5IHtcbiAgICB0aGlzLl9zZXNzaW9uW3RoaXMuX21ldGhvZF0obWVzc2FnZSwgaGFuZGxlcik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGhhbmRsZXIoZXJyKTtcbiAgfVxufTtcblxuRnVuY3Rvci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wZW5kaW5nICA9IHRoaXMuX3F1ZXVlLmxlbmd0aDtcbiAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG59O1xuXG5GdW5jdG9yLnByb3RvdHlwZS5fZmx1c2hRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcXVldWUgPSB0aGlzLl9xdWV1ZSwgcmVjb3JkO1xuXG4gIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwICYmIHF1ZXVlLnBlZWsoKS5kb25lKSB7XG4gICAgcmVjb3JkID0gcXVldWUuc2hpZnQoKTtcbiAgICBpZiAocmVjb3JkLmVycm9yKSB7XG4gICAgICB0aGlzLnBlbmRpbmcgPSAwO1xuICAgICAgcXVldWUuY2xlYXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wZW5kaW5nIC09IDE7XG4gICAgfVxuICAgIHJlY29yZC5jYWxsYmFjay5jYWxsKHJlY29yZC5jb250ZXh0LCByZWNvcmQuZXJyb3IsIHJlY29yZC5tZXNzYWdlKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdG9yO1xuXG5cbi8qKiovIH0pLFxuLyogMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEZyYW1lID0gZnVuY3Rpb24oKSB7fTtcblxudmFyIGluc3RhbmNlID0ge1xuICBmaW5hbDogICAgICAgIGZhbHNlLFxuICByc3YxOiAgICAgICAgIGZhbHNlLFxuICByc3YyOiAgICAgICAgIGZhbHNlLFxuICByc3YzOiAgICAgICAgIGZhbHNlLFxuICBvcGNvZGU6ICAgICAgIG51bGwsXG4gIG1hc2tlZDogICAgICAgZmFsc2UsXG4gIG1hc2tpbmdLZXk6ICAgbnVsbCxcbiAgbGVuZ3RoQnl0ZXM6ICAxLFxuICBsZW5ndGg6ICAgICAgIDAsXG4gIHBheWxvYWQ6ICAgICAgbnVsbFxufTtcblxuZm9yICh2YXIga2V5IGluIGluc3RhbmNlKVxuICBGcmFtZS5wcm90b3R5cGVba2V5XSA9IGluc3RhbmNlW2tleV07XG5cbm1vZHVsZS5leHBvcnRzID0gRnJhbWU7XG5cblxuLyoqKi8gfSksXG4vKiAzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5CdWZmZXI7XG5cbnZhciBNZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucnN2MSAgICA9IGZhbHNlO1xuICB0aGlzLnJzdjIgICAgPSBmYWxzZTtcbiAgdGhpcy5yc3YzICAgID0gZmFsc2U7XG4gIHRoaXMub3Bjb2RlICA9IG51bGw7XG4gIHRoaXMubGVuZ3RoICA9IDA7XG4gIHRoaXMuX2NodW5rcyA9IFtdO1xufTtcblxudmFyIGluc3RhbmNlID0ge1xuICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhID0gdGhpcy5kYXRhIHx8IEJ1ZmZlci5jb25jYXQodGhpcy5fY2h1bmtzLCB0aGlzLmxlbmd0aCk7XG4gIH0sXG5cbiAgcHVzaEZyYW1lOiBmdW5jdGlvbihmcmFtZSkge1xuICAgIHRoaXMucnN2MSA9IHRoaXMucnN2MSB8fCBmcmFtZS5yc3YxO1xuICAgIHRoaXMucnN2MiA9IHRoaXMucnN2MiB8fCBmcmFtZS5yc3YyO1xuICAgIHRoaXMucnN2MyA9IHRoaXMucnN2MyB8fCBmcmFtZS5yc3YzO1xuXG4gICAgaWYgKHRoaXMub3Bjb2RlID09PSBudWxsKSB0aGlzLm9wY29kZSA9IGZyYW1lLm9wY29kZTtcblxuICAgIHRoaXMuX2NodW5rcy5wdXNoKGZyYW1lLnBheWxvYWQpO1xuICAgIHRoaXMubGVuZ3RoICs9IGZyYW1lLmxlbmd0aDtcbiAgfVxufTtcblxuZm9yICh2YXIga2V5IGluIGluc3RhbmNlKVxuICBNZXNzYWdlLnByb3RvdHlwZVtrZXldID0gaW5zdGFuY2Vba2V5XTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlO1xuXG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEJ1ZmZlciAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLkJ1ZmZlcixcbiAgICBTdHJlYW0gICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KS5TdHJlYW0sXG4gICAgdXJsICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNiksXG4gICAgdXRpbCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMCksXG4gICAgQmFzZSAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMiksXG4gICAgSGVhZGVycyAgICA9IF9fd2VicGFja19yZXF1aXJlX18oOSksXG4gICAgSHR0cFBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgUE9SVFMgPSB7ICd3czonOiA4MCwgJ3dzczonOiA0NDMgfTtcblxudmFyIFByb3h5ID0gZnVuY3Rpb24oY2xpZW50LCBvcmlnaW4sIG9wdGlvbnMpIHtcbiAgdGhpcy5fY2xpZW50ICA9IGNsaWVudDtcbiAgdGhpcy5faHR0cCAgICA9IG5ldyBIdHRwUGFyc2VyKCdyZXNwb25zZScpO1xuICB0aGlzLl9vcmlnaW4gID0gKHR5cGVvZiBjbGllbnQudXJsID09PSAnb2JqZWN0JykgPyBjbGllbnQudXJsIDogdXJsLnBhcnNlKGNsaWVudC51cmwpO1xuICB0aGlzLl91cmwgICAgID0gKHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnKSA/IG9yaWdpbiA6IHVybC5wYXJzZShvcmlnaW4pO1xuICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fc3RhdGUgICA9IDA7XG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLl9wYXVzZWQgID0gZmFsc2U7XG5cbiAgdGhpcy5faGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdIb3N0JywgdGhpcy5fb3JpZ2luLmhvc3QpO1xuICB0aGlzLl9oZWFkZXJzLnNldCgnQ29ubmVjdGlvbicsICdrZWVwLWFsaXZlJyk7XG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdQcm94eS1Db25uZWN0aW9uJywgJ2tlZXAtYWxpdmUnKTtcblxuICB2YXIgYXV0aCA9IHRoaXMuX3VybC5hdXRoICYmIEJ1ZmZlci5mcm9tKHRoaXMuX3VybC5hdXRoLCAndXRmOCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgaWYgKGF1dGgpIHRoaXMuX2hlYWRlcnMuc2V0KCdQcm94eS1BdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBhdXRoKTtcbn07XG51dGlsLmluaGVyaXRzKFByb3h5LCBTdHJlYW0pO1xuXG52YXIgaW5zdGFuY2UgPSB7XG4gIHNldEhlYWRlcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgIT09IDApIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLl9oZWFkZXJzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuX3N0YXRlID0gMTtcblxuICAgIHZhciBvcmlnaW4gPSB0aGlzLl9vcmlnaW4sXG4gICAgICAgIHBvcnQgICA9IG9yaWdpbi5wb3J0IHx8IFBPUlRTW29yaWdpbi5wcm90b2NvbF0sXG4gICAgICAgIHN0YXJ0ICA9ICdDT05ORUNUICcgKyBvcmlnaW4uaG9zdG5hbWUgKyAnOicgKyBwb3J0ICsgJyBIVFRQLzEuMSc7XG5cbiAgICB2YXIgaGVhZGVycyA9IFtzdGFydCwgdGhpcy5faGVhZGVycy50b1N0cmluZygpLCAnJ107XG5cbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCBCdWZmZXIuZnJvbShoZWFkZXJzLmpvaW4oJ1xcclxcbicpLCAndXRmOCcpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBwYXVzZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgfSxcblxuICByZXN1bWU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgfSxcblxuICB3cml0ZTogZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgIHRoaXMuX2h0dHAucGFyc2UoY2h1bmspO1xuICAgIGlmICghdGhpcy5faHR0cC5pc0NvbXBsZXRlKCkpIHJldHVybiAhdGhpcy5fcGF1c2VkO1xuXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gdGhpcy5faHR0cC5zdGF0dXNDb2RlO1xuICAgIHRoaXMuaGVhZGVycyAgICA9IHRoaXMuX2h0dHAuaGVhZGVycztcblxuICAgIGlmICh0aGlzLnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgdGhpcy5lbWl0KCdjb25uZWN0JywgbmV3IEJhc2UuQ29ubmVjdEV2ZW50KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IFwiQ2FuJ3QgZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIGF0IFwiICsgdGhpcy5fb3JpZ2luLmhyZWY7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgdGhpcy5lbmQoKTtcbiAgICByZXR1cm4gIXRoaXMuX3BhdXNlZDtcbiAgfSxcblxuICBlbmQ6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSByZXR1cm47XG4gICAgaWYgKGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmspO1xuICAgIHRoaXMucmVhZGFibGUgPSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIHRoaXMuZW1pdCgnZW5kJyk7XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbmQoKTtcbiAgfVxufTtcblxuZm9yICh2YXIga2V5IGluIGluc3RhbmNlKVxuICBQcm94eS5wcm90b3R5cGVba2V5XSA9IGluc3RhbmNlW2tleV07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJveHk7XG5cblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdXRpbCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMCksXG4gICAgSHR0cFBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApLFxuICAgIEJhc2UgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLFxuICAgIERyYWZ0NzUgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSxcbiAgICBEcmFmdDc2ICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCksXG4gICAgSHliaSAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG52YXIgU2VydmVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBCYXNlLmNhbGwodGhpcywgbnVsbCwgbnVsbCwgb3B0aW9ucyk7XG4gIHRoaXMuX2h0dHAgPSBuZXcgSHR0cFBhcnNlcigncmVxdWVzdCcpO1xufTtcbnV0aWwuaW5oZXJpdHMoU2VydmVyLCBCYXNlKTtcblxudmFyIGluc3RhbmNlID0ge1xuICBFVkVOVFM6IFsnb3BlbicsICdtZXNzYWdlJywgJ2Vycm9yJywgJ2Nsb3NlJywgJ3BpbmcnLCAncG9uZyddLFxuXG4gIF9iaW5kRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubWVzc2FnZXMub24oJ2Vycm9yJywgZnVuY3Rpb24oKSB7fSk7XG4gICAgdGhpcy5vbignZXJyb3InLCBmdW5jdGlvbigpIHt9KTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAodGhpcy5fZGVsZWdhdGUpIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5wYXJzZShjaHVuayk7XG5cbiAgICB0aGlzLl9odHRwLnBhcnNlKGNodW5rKTtcbiAgICBpZiAoIXRoaXMuX2h0dHAuaXNDb21wbGV0ZSgpKSByZXR1cm47XG5cbiAgICB0aGlzLm1ldGhvZCAgPSB0aGlzLl9odHRwLm1ldGhvZDtcbiAgICB0aGlzLnVybCAgICAgPSB0aGlzLl9odHRwLnVybDtcbiAgICB0aGlzLmhlYWRlcnMgPSB0aGlzLl9odHRwLmhlYWRlcnM7XG4gICAgdGhpcy5ib2R5ICAgID0gdGhpcy5faHR0cC5ib2R5O1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX2RlbGVnYXRlID0gU2VydmVyLmh0dHAodGhpcywgdGhpcy5fb3B0aW9ucyk7XG4gICAgdGhpcy5fZGVsZWdhdGUubWVzc2FnZXMgPSB0aGlzLm1lc3NhZ2VzO1xuICAgIHRoaXMuX2RlbGVnYXRlLmlvID0gdGhpcy5pbztcbiAgICB0aGlzLl9vcGVuKCk7XG5cbiAgICB0aGlzLkVWRU5UUy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB0aGlzLl9kZWxlZ2F0ZS5vbihldmVudCwgZnVuY3Rpb24oZSkgeyBzZWxmLmVtaXQoZXZlbnQsIGUpIH0pO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5wcm90b2NvbCA9IHRoaXMuX2RlbGVnYXRlLnByb3RvY29sO1xuICAgIHRoaXMudmVyc2lvbiAgPSB0aGlzLl9kZWxlZ2F0ZS52ZXJzaW9uO1xuXG4gICAgdGhpcy5wYXJzZSh0aGlzLl9odHRwLmJvZHkpO1xuICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIG5ldyBCYXNlLkNvbm5lY3RFdmVudCgpKTtcbiAgfSxcblxuICBfb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fX3F1ZXVlLmZvckVhY2goZnVuY3Rpb24obXNnKSB7XG4gICAgICB0aGlzLl9kZWxlZ2F0ZVttc2dbMF1dLmFwcGx5KHRoaXMuX2RlbGVnYXRlLCBtc2dbMV0pO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX19xdWV1ZSA9IFtdO1xuICB9XG59O1xuXG5bJ2FkZEV4dGVuc2lvbicsICdzZXRIZWFkZXInLCAnc3RhcnQnLCAnZnJhbWUnLCAndGV4dCcsICdiaW5hcnknLCAncGluZycsICdjbG9zZSddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIGluc3RhbmNlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fZGVsZWdhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZVttZXRob2RdLmFwcGx5KHRoaXMuX2RlbGVnYXRlLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9fcXVldWUucHVzaChbbWV0aG9kLCBhcmd1bWVudHNdKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5mb3IgKHZhciBrZXkgaW4gaW5zdGFuY2UpXG4gIFNlcnZlci5wcm90b3R5cGVba2V5XSA9IGluc3RhbmNlW2tleV07XG5cblNlcnZlci5pc1NlY3VyZVJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIGlmIChyZXF1ZXN0LmNvbm5lY3Rpb24gJiYgcmVxdWVzdC5jb25uZWN0aW9uLmF1dGhvcml6ZWQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG4gIGlmIChyZXF1ZXN0LnNvY2tldCAmJiByZXF1ZXN0LnNvY2tldC5zZWN1cmUpIHJldHVybiB0cnVlO1xuXG4gIHZhciBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzO1xuICBpZiAoIWhlYWRlcnMpIHJldHVybiBmYWxzZTtcbiAgaWYgKGhlYWRlcnNbJ2h0dHBzJ10gPT09ICdvbicpIHJldHVybiB0cnVlO1xuICBpZiAoaGVhZGVyc1sneC1mb3J3YXJkZWQtc3NsJ10gPT09ICdvbicpIHJldHVybiB0cnVlO1xuICBpZiAoaGVhZGVyc1sneC1mb3J3YXJkZWQtc2NoZW1lJ10gPT09ICdodHRwcycpIHJldHVybiB0cnVlO1xuICBpZiAoaGVhZGVyc1sneC1mb3J3YXJkZWQtcHJvdG8nXSA9PT0gJ2h0dHBzJykgcmV0dXJuIHRydWU7XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuU2VydmVyLmRldGVybWluZVVybCA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgdmFyIHNjaGVtZSA9IHRoaXMuaXNTZWN1cmVSZXF1ZXN0KHJlcXVlc3QpID8gJ3dzczonIDogJ3dzOic7XG4gIHJldHVybiBzY2hlbWUgKyAnLy8nICsgcmVxdWVzdC5oZWFkZXJzLmhvc3QgKyByZXF1ZXN0LnVybDtcbn07XG5cblNlcnZlci5odHRwID0gZnVuY3Rpb24ocmVxdWVzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKG9wdGlvbnMucmVxdWlyZU1hc2tpbmcgPT09IHVuZGVmaW5lZCkgb3B0aW9ucy5yZXF1aXJlTWFza2luZyA9IHRydWU7XG5cbiAgdmFyIGhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnMsXG4gICAgICB2ZXJzaW9uID0gaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ10sXG4gICAgICBrZXkgICAgID0gaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXSxcbiAgICAgIGtleTEgICAgPSBoZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleTEnXSxcbiAgICAgIGtleTIgICAgPSBoZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleTInXSxcbiAgICAgIHVybCAgICAgPSB0aGlzLmRldGVybWluZVVybChyZXF1ZXN0KTtcblxuICBpZiAodmVyc2lvbiB8fCBrZXkpXG4gICAgcmV0dXJuIG5ldyBIeWJpKHJlcXVlc3QsIHVybCwgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKGtleTEgfHwga2V5MilcbiAgICByZXR1cm4gbmV3IERyYWZ0NzYocmVxdWVzdCwgdXJsLCBvcHRpb25zKTtcbiAgZWxzZVxuICAgIHJldHVybiBuZXcgRHJhZnQ3NShyZXF1ZXN0LCB1cmwsIG9wdGlvbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXJ2ZXI7XG5cblxuLyoqKi8gfSksXG4vKiAzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgQnVmZmVyICA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuQnVmZmVyLFxuICAgIEJhc2UgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLFxuICAgIERyYWZ0NzUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSxcbiAgICBjcnlwdG8gID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKSxcbiAgICB1dGlsICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG52YXIgbnVtYmVyRnJvbUtleSA9IGZ1bmN0aW9uKGtleSkge1xuICByZXR1cm4gcGFyc2VJbnQoKGtleS5tYXRjaCgvWzAtOV0vZykgfHwgW10pLmpvaW4oJycpLCAxMCk7XG59O1xuXG52YXIgc3BhY2VzSW5LZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgcmV0dXJuIChrZXkubWF0Y2goLyAvZykgfHwgW10pLmxlbmd0aDtcbn07XG5cblxudmFyIERyYWZ0NzYgPSBmdW5jdGlvbihyZXF1ZXN0LCB1cmwsIG9wdGlvbnMpIHtcbiAgRHJhZnQ3NS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB0aGlzLl9zdGFnZSAgPSAtMTtcbiAgdGhpcy5fYm9keSAgID0gW107XG4gIHRoaXMudmVyc2lvbiA9ICdoaXhpZS03Nic7XG5cbiAgdGhpcy5faGVhZGVycy5jbGVhcigpO1xuXG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdVcGdyYWRlJywgJ1dlYlNvY2tldCcpO1xuICB0aGlzLl9oZWFkZXJzLnNldCgnQ29ubmVjdGlvbicsICdVcGdyYWRlJyk7XG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdTZWMtV2ViU29ja2V0LU9yaWdpbicsIHRoaXMuX3JlcXVlc3QuaGVhZGVycy5vcmlnaW4pO1xuICB0aGlzLl9oZWFkZXJzLnNldCgnU2VjLVdlYlNvY2tldC1Mb2NhdGlvbicsIHRoaXMudXJsKTtcbn07XG51dGlsLmluaGVyaXRzKERyYWZ0NzYsIERyYWZ0NzUpO1xuXG52YXIgaW5zdGFuY2UgPSB7XG4gIEJPRFlfU0laRTogOCxcblxuICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFEcmFmdDc1LnByb3RvdHlwZS5zdGFydC5jYWxsKHRoaXMpKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgdGhpcy5fc2VuZEhhbmRzaGFrZUJvZHkoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gMykgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IDEpIHRoaXMuX3dyaXRlKEJ1ZmZlci5mcm9tKFsweEZGLCAweDAwXSkpO1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IDM7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIG5ldyBCYXNlLkNsb3NlRXZlbnQobnVsbCwgbnVsbCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIF9oYW5kc2hha2VSZXNwb25zZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhlYWRlcnMgPSB0aGlzLl9yZXF1ZXN0LmhlYWRlcnMsXG4gICAgICAgIGtleTEgICAgPSBoZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleTEnXSxcbiAgICAgICAga2V5MiAgICA9IGhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5MiddO1xuXG4gICAgaWYgKCFrZXkxKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgaGVhZGVyOiBTZWMtV2ViU29ja2V0LUtleTEnKTtcbiAgICBpZiAoIWtleTIpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBoZWFkZXI6IFNlYy1XZWJTb2NrZXQtS2V5MicpO1xuXG4gICAgdmFyIG51bWJlcjEgPSBudW1iZXJGcm9tS2V5KGtleTEpLFxuICAgICAgICBzcGFjZXMxID0gc3BhY2VzSW5LZXkoa2V5MSksXG5cbiAgICAgICAgbnVtYmVyMiA9IG51bWJlckZyb21LZXkoa2V5MiksXG4gICAgICAgIHNwYWNlczIgPSBzcGFjZXNJbktleShrZXkyKTtcblxuICAgIGlmIChudW1iZXIxICUgc3BhY2VzMSAhPT0gMCB8fCBudW1iZXIyICUgc3BhY2VzMiAhPT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50IHNlbnQgaW52YWxpZCBTZWMtV2ViU29ja2V0LUtleSBoZWFkZXJzJyk7XG5cbiAgICB0aGlzLl9rZXlWYWx1ZXMgPSBbbnVtYmVyMSAvIHNwYWNlczEsIG51bWJlcjIgLyBzcGFjZXMyXTtcblxuICAgIHZhciBzdGFydCAgID0gJ0hUVFAvMS4xIDEwMSBXZWJTb2NrZXQgUHJvdG9jb2wgSGFuZHNoYWtlJyxcbiAgICAgICAgaGVhZGVycyA9IFtzdGFydCwgdGhpcy5faGVhZGVycy50b1N0cmluZygpLCAnJ107XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaGVhZGVycy5qb2luKCdcXHJcXG4nKSwgJ2JpbmFyeScpO1xuICB9LFxuXG4gIF9oYW5kc2hha2VTaWduYXR1cmU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9ib2R5Lmxlbmd0aCA8IHRoaXMuQk9EWV9TSVpFKSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBtZDUgICAgPSBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1JyksXG4gICAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg4ICsgdGhpcy5CT0RZX1NJWkUpO1xuXG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUodGhpcy5fa2V5VmFsdWVzWzBdLCAwKTtcbiAgICBidWZmZXIud3JpdGVVSW50MzJCRSh0aGlzLl9rZXlWYWx1ZXNbMV0sIDQpO1xuICAgIEJ1ZmZlci5mcm9tKHRoaXMuX2JvZHkpLmNvcHkoYnVmZmVyLCA4LCAwLCB0aGlzLkJPRFlfU0laRSk7XG5cbiAgICBtZDUudXBkYXRlKGJ1ZmZlcik7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG1kNS5kaWdlc3QoJ2JpbmFyeScpLCAnYmluYXJ5Jyk7XG4gIH0sXG5cbiAgX3NlbmRIYW5kc2hha2VCb2R5OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHJldHVybjtcbiAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5faGFuZHNoYWtlU2lnbmF0dXJlKCk7XG4gICAgaWYgKCFzaWduYXR1cmUpIHJldHVybjtcblxuICAgIHRoaXMuX3dyaXRlKHNpZ25hdHVyZSk7XG4gICAgdGhpcy5fc3RhZ2UgPSAwO1xuICAgIHRoaXMuX29wZW4oKTtcblxuICAgIGlmICh0aGlzLl9ib2R5Lmxlbmd0aCA+IHRoaXMuQk9EWV9TSVpFKVxuICAgICAgdGhpcy5wYXJzZSh0aGlzLl9ib2R5LnNsaWNlKHRoaXMuQk9EWV9TSVpFKSk7XG4gIH0sXG5cbiAgX3BhcnNlTGVhZGluZ0J5dGU6IGZ1bmN0aW9uKG9jdGV0KSB7XG4gICAgaWYgKG9jdGV0ICE9PSAweEZGKVxuICAgICAgcmV0dXJuIERyYWZ0NzUucHJvdG90eXBlLl9wYXJzZUxlYWRpbmdCeXRlLmNhbGwodGhpcywgb2N0ZXQpO1xuXG4gICAgdGhpcy5fY2xvc2luZyA9IHRydWU7XG4gICAgdGhpcy5fbGVuZ3RoICA9IDA7XG4gICAgdGhpcy5fc3RhZ2UgICA9IDE7XG4gIH1cbn07XG5cbmZvciAodmFyIGtleSBpbiBpbnN0YW5jZSlcbiAgRHJhZnQ3Ni5wcm90b3R5cGVba2V5XSA9IGluc3RhbmNlW2tleV07XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhZnQ3NjtcblxuXG4vKioqLyB9KSxcbi8qIDM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLFxuICAgIG5ldCAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDApLFxuICAgIHRscyAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpLFxuICAgIHVybCAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNiksXG4gICAgZHJpdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KSxcbiAgICBBUEkgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKSxcbiAgICBFdmVudCAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgREVGQVVMVF9QT1JUUyAgICA9IHsnaHR0cDonOiA4MCwgJ2h0dHBzOic6IDQ0MywgJ3dzOic6ODAsICd3c3M6JzogNDQzfSxcbiAgICBTRUNVUkVfUFJPVE9DT0xTID0gWydodHRwczonLCAnd3NzOiddO1xuXG52YXIgQ2xpZW50ID0gZnVuY3Rpb24oX3VybCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMudXJsICAgICA9IF91cmw7XG4gIHRoaXMuX2RyaXZlciA9IGRyaXZlci5jbGllbnQodGhpcy51cmwsIHttYXhMZW5ndGg6IG9wdGlvbnMubWF4TGVuZ3RoLCBwcm90b2NvbHM6IHByb3RvY29sc30pO1xuXG4gIFsnb3BlbicsICdlcnJvciddLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB0aGlzLl9kcml2ZXIub24oZXZlbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5oZWFkZXJzICAgID0gc2VsZi5fZHJpdmVyLmhlYWRlcnM7XG4gICAgICBzZWxmLnN0YXR1c0NvZGUgPSBzZWxmLl9kcml2ZXIuc3RhdHVzQ29kZTtcbiAgICB9KTtcbiAgfSwgdGhpcyk7XG5cbiAgdmFyIHByb3h5ICAgICAgPSBvcHRpb25zLnByb3h5IHx8IHt9LFxuICAgICAgZW5kcG9pbnQgICA9IHVybC5wYXJzZShwcm94eS5vcmlnaW4gfHwgdGhpcy51cmwpLFxuICAgICAgcG9ydCAgICAgICA9IGVuZHBvaW50LnBvcnQgfHwgREVGQVVMVF9QT1JUU1tlbmRwb2ludC5wcm90b2NvbF0sXG4gICAgICBzZWN1cmUgICAgID0gU0VDVVJFX1BST1RPQ09MUy5pbmRleE9mKGVuZHBvaW50LnByb3RvY29sKSA+PSAwLFxuICAgICAgb25Db25uZWN0ICA9IGZ1bmN0aW9uKCkgeyBzZWxmLl9vbkNvbm5lY3QoKSB9LFxuICAgICAgbmV0T3B0aW9ucyA9IG9wdGlvbnMubmV0IHx8IHt9LFxuICAgICAgb3JpZ2luVExTICA9IG9wdGlvbnMudGxzIHx8IHt9LFxuICAgICAgc29ja2V0VExTICA9IHByb3h5Lm9yaWdpbiA/IChwcm94eS50bHMgfHwge30pIDogb3JpZ2luVExTLFxuICAgICAgc2VsZiAgICAgICA9IHRoaXM7XG5cbiAgbmV0T3B0aW9ucy5ob3N0ID0gc29ja2V0VExTLmhvc3QgPSBlbmRwb2ludC5ob3N0bmFtZTtcbiAgbmV0T3B0aW9ucy5wb3J0ID0gc29ja2V0VExTLnBvcnQgPSBwb3J0O1xuXG4gIG9yaWdpblRMUy5jYSA9IG9yaWdpblRMUy5jYSB8fCBvcHRpb25zLmNhO1xuICBzb2NrZXRUTFMuc2VydmVybmFtZSA9IHNvY2tldFRMUy5zZXJ2ZXJuYW1lIHx8IGVuZHBvaW50Lmhvc3RuYW1lO1xuXG4gIHRoaXMuX3N0cmVhbSA9IHNlY3VyZVxuICAgICAgICAgICAgICAgPyB0bHMuY29ubmVjdChzb2NrZXRUTFMsIG9uQ29ubmVjdClcbiAgICAgICAgICAgICAgIDogbmV0LmNvbm5lY3QobmV0T3B0aW9ucywgb25Db25uZWN0KTtcblxuICBpZiAocHJveHkub3JpZ2luKSB0aGlzLl9jb25maWd1cmVQcm94eShwcm94eSwgb3JpZ2luVExTKTtcblxuICBBUEkuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn07XG51dGlsLmluaGVyaXRzKENsaWVudCwgQVBJKTtcblxuQ2xpZW50LnByb3RvdHlwZS5fb25Db25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB3b3JrZXIgPSB0aGlzLl9wcm94eSB8fCB0aGlzLl9kcml2ZXI7XG4gIHdvcmtlci5zdGFydCgpO1xufTtcblxuQ2xpZW50LnByb3RvdHlwZS5fY29uZmlndXJlUHJveHkgPSBmdW5jdGlvbihwcm94eSwgb3JpZ2luVExTKSB7XG4gIHZhciB1cmkgICAgPSB1cmwucGFyc2UodGhpcy51cmwpLFxuICAgICAgc2VjdXJlID0gU0VDVVJFX1BST1RPQ09MUy5pbmRleE9mKHVyaS5wcm90b2NvbCkgPj0gMCxcbiAgICAgIHNlbGYgICA9IHRoaXMsXG4gICAgICBuYW1lO1xuXG4gIHRoaXMuX3Byb3h5ID0gdGhpcy5fZHJpdmVyLnByb3h5KHByb3h5Lm9yaWdpbik7XG5cbiAgaWYgKHByb3h5LmhlYWRlcnMpIHtcbiAgICBmb3IgKG5hbWUgaW4gcHJveHkuaGVhZGVycykgdGhpcy5fcHJveHkuc2V0SGVhZGVyKG5hbWUsIHByb3h5LmhlYWRlcnNbbmFtZV0pO1xuICB9XG5cbiAgdGhpcy5fcHJveHkucGlwZSh0aGlzLl9zdHJlYW0sIHtlbmQ6IGZhbHNlfSk7XG4gIHRoaXMuX3N0cmVhbS5waXBlKHRoaXMuX3Byb3h5KTtcblxuICB0aGlzLl9wcm94eS5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWN1cmUpIHtcbiAgICAgIHZhciBvcHRpb25zID0ge3NvY2tldDogc2VsZi5fc3RyZWFtLCBzZXJ2ZXJuYW1lOiB1cmkuaG9zdG5hbWV9O1xuICAgICAgZm9yIChuYW1lIGluIG9yaWdpblRMUykgb3B0aW9uc1tuYW1lXSA9IG9yaWdpblRMU1tuYW1lXTtcbiAgICAgIHNlbGYuX3N0cmVhbSA9IHRscy5jb25uZWN0KG9wdGlvbnMpO1xuICAgICAgc2VsZi5fY29uZmlndXJlU3RyZWFtKCk7XG4gICAgfVxuICAgIHNlbGYuX2RyaXZlci5pby5waXBlKHNlbGYuX3N0cmVhbSk7XG4gICAgc2VsZi5fc3RyZWFtLnBpcGUoc2VsZi5fZHJpdmVyLmlvKTtcbiAgICBzZWxmLl9kcml2ZXIuc3RhcnQoKTtcbiAgfSk7XG5cbiAgdGhpcy5fcHJveHkub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBzZWxmLl9kcml2ZXIuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnQ7XG5cblxuLyoqKi8gfSksXG4vKiA0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXRcIik7XG5cbi8qKiovIH0pLFxuLyogNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidGxzXCIpO1xuXG4vKioqLyB9KSxcbi8qIDQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBTdHJlYW0gICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNSkuU3RyZWFtLFxuICAgIHV0aWwgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKSxcbiAgICBkcml2ZXIgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNCksXG4gICAgSGVhZGVycyAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLFxuICAgIEFQSSAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSksXG4gICAgRXZlbnRUYXJnZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSxcbiAgICBFdmVudCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBFdmVudFNvdXJjZSA9IGZ1bmN0aW9uKHJlcXVlc3QsIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLl9zdHJlYW0gPSByZXNwb25zZS5zb2NrZXQ7XG4gIHRoaXMuX3BpbmcgICA9IG9wdGlvbnMucGluZyAgfHwgdGhpcy5ERUZBVUxUX1BJTkc7XG4gIHRoaXMuX3JldHJ5ICA9IG9wdGlvbnMucmV0cnkgfHwgdGhpcy5ERUZBVUxUX1JFVFJZO1xuXG4gIHZhciBzY2hlbWUgICAgICAgPSBkcml2ZXIuaXNTZWN1cmVSZXF1ZXN0KHJlcXVlc3QpID8gJ2h0dHBzOicgOiAnaHR0cDonO1xuICB0aGlzLnVybCAgICAgICAgID0gc2NoZW1lICsgJy8vJyArIHJlcXVlc3QuaGVhZGVycy5ob3N0ICsgcmVxdWVzdC51cmw7XG4gIHRoaXMubGFzdEV2ZW50SWQgPSByZXF1ZXN0LmhlYWRlcnNbJ2xhc3QtZXZlbnQtaWQnXSB8fCAnJztcbiAgdGhpcy5yZWFkeVN0YXRlICA9IEFQSS5DT05ORUNUSU5HO1xuXG4gIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKSxcbiAgICAgIHNlbGYgICAgPSB0aGlzO1xuXG4gIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5oZWFkZXJzKSBoZWFkZXJzLnNldChrZXksIG9wdGlvbnMuaGVhZGVyc1trZXldKTtcbiAgfVxuXG4gIGlmICghdGhpcy5fc3RyZWFtIHx8ICF0aGlzLl9zdHJlYW0ud3JpdGFibGUpIHJldHVybjtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHsgc2VsZi5fb3BlbigpIH0pO1xuXG4gIHRoaXMuX3N0cmVhbS5zZXRUaW1lb3V0KDApO1xuICB0aGlzLl9zdHJlYW0uc2V0Tm9EZWxheSh0cnVlKTtcblxuICB2YXIgaGFuZHNoYWtlID0gJ0hUVFAvMS4xIDIwMCBPS1xcclxcbicgK1xuICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZTogdGV4dC9ldmVudC1zdHJlYW1cXHJcXG4nICtcbiAgICAgICAgICAgICAgICAgICdDYWNoZS1Db250cm9sOiBuby1jYWNoZSwgbm8tc3RvcmVcXHJcXG4nICtcbiAgICAgICAgICAgICAgICAgICdDb25uZWN0aW9uOiBjbG9zZVxcclxcbicgK1xuICAgICAgICAgICAgICAgICAgaGVhZGVycy50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICdcXHJcXG4nICtcbiAgICAgICAgICAgICAgICAgICdyZXRyeTogJyArIE1hdGguZmxvb3IodGhpcy5fcmV0cnkgKiAxMDAwKSArICdcXHJcXG5cXHJcXG4nO1xuXG4gIHRoaXMuX3dyaXRlKGhhbmRzaGFrZSk7XG5cbiAgdGhpcy5fc3RyZWFtLm9uKCdkcmFpbicsIGZ1bmN0aW9uKCkgeyBzZWxmLmVtaXQoJ2RyYWluJykgfSk7XG5cbiAgaWYgKHRoaXMuX3BpbmcpXG4gICAgdGhpcy5fcGluZ1RpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7IHNlbGYucGluZygpIH0sIHRoaXMuX3BpbmcgKiAxMDAwKTtcblxuICBbJ2Vycm9yJywgJ2VuZCddLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBzZWxmLl9zdHJlYW0ub24oZXZlbnQsIGZ1bmN0aW9uKCkgeyBzZWxmLmNsb3NlKCkgfSk7XG4gIH0pO1xufTtcbnV0aWwuaW5oZXJpdHMoRXZlbnRTb3VyY2UsIFN0cmVhbSk7XG5cbkV2ZW50U291cmNlLmlzRXZlbnRTb3VyY2UgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcpIHJldHVybiBmYWxzZTtcbiAgdmFyIGFjY2VwdCA9IChyZXF1ZXN0LmhlYWRlcnMuYWNjZXB0IHx8ICcnKS5zcGxpdCgvXFxzKixcXHMqLyk7XG4gIHJldHVybiBhY2NlcHQuaW5kZXhPZigndGV4dC9ldmVudC1zdHJlYW0nKSA+PSAwO1xufTtcblxudmFyIGluc3RhbmNlID0ge1xuICBERUZBVUxUX1BJTkc6ICAgMTAsXG4gIERFRkFVTFRfUkVUUlk6ICA1LFxuXG4gIF93cml0ZTogZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0cmVhbS53cml0ZShjaHVuaywgJ3V0ZjgnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIF9vcGVuOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBBUEkuQ09OTkVDVElORykgcmV0dXJuO1xuXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gQVBJLk9QRU47XG5cbiAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ29wZW4nKTtcbiAgICBldmVudC5pbml0RXZlbnQoJ29wZW4nLCBmYWxzZSwgZmFsc2UpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0sXG5cbiAgd3JpdGU6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kKG1lc3NhZ2UpO1xuICB9LFxuXG4gIGVuZDogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUobWVzc2FnZSk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9LFxuXG4gIHNlbmQ6IGZ1bmN0aW9uKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gQVBJLk9QRU4pIHJldHVybiBmYWxzZTtcblxuICAgIG1lc3NhZ2UgPSBTdHJpbmcobWVzc2FnZSkucmVwbGFjZSgvKFxcclxcbnxcXHJ8XFxuKS9nLCAnJDFkYXRhOiAnKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBmcmFtZSA9ICcnO1xuICAgIGlmIChvcHRpb25zLmV2ZW50KSBmcmFtZSArPSAnZXZlbnQ6ICcgKyBvcHRpb25zLmV2ZW50ICsgJ1xcclxcbic7XG4gICAgaWYgKG9wdGlvbnMuaWQpICAgIGZyYW1lICs9ICdpZDogJyAgICArIG9wdGlvbnMuaWQgICAgKyAnXFxyXFxuJztcbiAgICBmcmFtZSArPSAnZGF0YTogJyArIG1lc3NhZ2UgKyAnXFxyXFxuXFxyXFxuJztcblxuICAgIHJldHVybiB0aGlzLl93cml0ZShmcmFtZSk7XG4gIH0sXG5cbiAgcGluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRlKCc6XFxyXFxuXFxyXFxuJyk7XG4gIH0sXG5cbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPiBBUEkuT1BFTikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gQVBJLkNMT1NFRDtcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuX3BpbmdUaW1lcikgY2xlYXJJbnRlcnZhbCh0aGlzLl9waW5nVGltZXIpO1xuICAgIGlmICh0aGlzLl9zdHJlYW0pIHRoaXMuX3N0cmVhbS5lbmQoKTtcblxuICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnY2xvc2UnKTtcbiAgICBldmVudC5pbml0RXZlbnQoJ2Nsb3NlJywgZmFsc2UsIGZhbHNlKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbmZvciAodmFyIG1ldGhvZCBpbiBpbnN0YW5jZSkgRXZlbnRTb3VyY2UucHJvdG90eXBlW21ldGhvZF0gPSBpbnN0YW5jZVttZXRob2RdO1xuZm9yICh2YXIga2V5IGluIEV2ZW50VGFyZ2V0KSBFdmVudFNvdXJjZS5wcm90b3R5cGVba2V5XSA9IEV2ZW50VGFyZ2V0W2tleV07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2U7XG5cblxuLyoqKi8gfSksXG4vKiA0MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xuXG4vKioqLyB9KSxcbi8qIDQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpO1xuXG4vKioqLyB9KSxcbi8qIDQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBcIik7XG5cbi8qKiovIH0pLFxuLyogNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cHNcIik7XG5cbi8qKiovIH0pLFxuLyogNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gcHVzaGVyX3dpdGhfZW5jcnlwdGlvbl9QdXNoZXJXaXRoRW5jcnlwdGlvbjsgfSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvYmFzZTY0LnRzXG5mdW5jdGlvbiBlbmNvZGUocykge1xuICAgIHJldHVybiBidG9hKHV0b2IocykpO1xufVxudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG52YXIgYjY0Y2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG52YXIgYjY0dGFiID0ge307XG5mb3IgKHZhciBiYXNlNjRfaSA9IDAsIGwgPSBiNjRjaGFycy5sZW5ndGg7IGJhc2U2NF9pIDwgbDsgYmFzZTY0X2krKykge1xuICAgIGI2NHRhYltiNjRjaGFycy5jaGFyQXQoYmFzZTY0X2kpXSA9IGJhc2U2NF9pO1xufVxudmFyIGNiX3V0b2IgPSBmdW5jdGlvbiAoYykge1xuICAgIHZhciBjYyA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICByZXR1cm4gY2MgPCAweDgwXG4gICAgICAgID8gY1xuICAgICAgICA6IGNjIDwgMHg4MDBcbiAgICAgICAgICAgID8gZnJvbUNoYXJDb2RlKDB4YzAgfCAoY2MgPj4+IDYpKSArIGZyb21DaGFyQ29kZSgweDgwIHwgKGNjICYgMHgzZikpXG4gICAgICAgICAgICA6IGZyb21DaGFyQ29kZSgweGUwIHwgKChjYyA+Pj4gMTIpICYgMHgwZikpICtcbiAgICAgICAgICAgICAgICBmcm9tQ2hhckNvZGUoMHg4MCB8ICgoY2MgPj4+IDYpICYgMHgzZikpICtcbiAgICAgICAgICAgICAgICBmcm9tQ2hhckNvZGUoMHg4MCB8IChjYyAmIDB4M2YpKTtcbn07XG52YXIgdXRvYiA9IGZ1bmN0aW9uICh1KSB7XG4gICAgcmV0dXJuIHUucmVwbGFjZSgvW15cXHgwMC1cXHg3Rl0vZywgY2JfdXRvYik7XG59O1xudmFyIGNiX2VuY29kZSA9IGZ1bmN0aW9uIChjY2MpIHtcbiAgICB2YXIgcGFkbGVuID0gWzAsIDIsIDFdW2NjYy5sZW5ndGggJSAzXTtcbiAgICB2YXIgb3JkID0gKGNjYy5jaGFyQ29kZUF0KDApIDw8IDE2KSB8XG4gICAgICAgICgoY2NjLmxlbmd0aCA+IDEgPyBjY2MuY2hhckNvZGVBdCgxKSA6IDApIDw8IDgpIHxcbiAgICAgICAgKGNjYy5sZW5ndGggPiAyID8gY2NjLmNoYXJDb2RlQXQoMikgOiAwKTtcbiAgICB2YXIgY2hhcnMgPSBbXG4gICAgICAgIGI2NGNoYXJzLmNoYXJBdChvcmQgPj4+IDE4KSxcbiAgICAgICAgYjY0Y2hhcnMuY2hhckF0KChvcmQgPj4+IDEyKSAmIDYzKSxcbiAgICAgICAgcGFkbGVuID49IDIgPyAnPScgOiBiNjRjaGFycy5jaGFyQXQoKG9yZCA+Pj4gNikgJiA2MyksXG4gICAgICAgIHBhZGxlbiA+PSAxID8gJz0nIDogYjY0Y2hhcnMuY2hhckF0KG9yZCAmIDYzKVxuICAgIF07XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xufTtcbnZhciBidG9hID0gZ2xvYmFsLmJ0b2EgfHxcbiAgICBmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gYi5yZXBsYWNlKC9bXFxzXFxTXXsxLDN9L2csIGNiX2VuY29kZSk7XG4gICAgfTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy90aW1lcnMvYWJzdHJhY3RfdGltZXIudHNcbmNsYXNzIFRpbWVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXQsIGNsZWFyLCBkZWxheSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jbGVhciA9IGNsZWFyO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lciA9IGNhbGxiYWNrKHRoaXMudGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBkZWxheSk7XG4gICAgfVxuICAgIGlzUnVubmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXIgIT09IG51bGw7XG4gICAgfVxuICAgIGVuc3VyZUFib3J0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKHRoaXMudGltZXIpO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBhYnN0cmFjdF90aW1lciA9IChUaW1lcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvdGltZXJzL2luZGV4LnRzXG5cbmZ1bmN0aW9uIHRpbWVyc19jbGVhclRpbWVvdXQodGltZXIpIHtcbiAgICBnbG9iYWwuY2xlYXJUaW1lb3V0KHRpbWVyKTtcbn1cbmZ1bmN0aW9uIHRpbWVyc19jbGVhckludGVydmFsKHRpbWVyKSB7XG4gICAgZ2xvYmFsLmNsZWFySW50ZXJ2YWwodGltZXIpO1xufVxuY2xhc3MgdGltZXJzX09uZU9mZlRpbWVyIGV4dGVuZHMgYWJzdHJhY3RfdGltZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlbGF5LCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlcihzZXRUaW1lb3V0LCB0aW1lcnNfY2xlYXJUaW1lb3V0LCBkZWxheSwgZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIHRpbWVyc19QZXJpb2RpY1RpbWVyIGV4dGVuZHMgYWJzdHJhY3RfdGltZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlbGF5LCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlcihzZXRJbnRlcnZhbCwgdGltZXJzX2NsZWFySW50ZXJ2YWwsIGRlbGF5LCBmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm4gdGltZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlsLnRzXG5cbnZhciBVdGlsID0ge1xuICAgIG5vdygpIHtcbiAgICAgICAgaWYgKERhdGUubm93KSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVmZXIoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aW1lcnNfT25lT2ZmVGltZXIoMCwgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgbWV0aG9kKG5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgdmFyIGJvdW5kQXJndW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RbbmFtZV0uYXBwbHkob2JqZWN0LCBib3VuZEFyZ3VtZW50cy5jb25jYXQoYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHV0aWwgPSAoVXRpbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvY29sbGVjdGlvbnMudHNcblxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCAuLi5zb3VyY2VzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBleHRlbnNpb25zID0gc291cmNlc1tpXTtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnNbcHJvcGVydHldICYmXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uc1twcm9wZXJ0eV0uY29uc3RydWN0b3IgJiZcbiAgICAgICAgICAgICAgICBleHRlbnNpb25zW3Byb3BlcnR5XS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IGV4dGVuZCh0YXJnZXRbcHJvcGVydHldIHx8IHt9LCBleHRlbnNpb25zW3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcGVydHldID0gZXh0ZW5zaW9uc1twcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSgpIHtcbiAgICB2YXIgbSA9IFsnUHVzaGVyJ107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG0ucHVzaChzYWZlSlNPTlN0cmluZ2lmeShhcmd1bWVudHNbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbS5qb2luKCcgOiAnKTtcbn1cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZihhcnJheSwgaXRlbSkge1xuICAgIHZhciBuYXRpdmVJbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgaWYgKGFycmF5ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgYXJyYXkuaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikge1xuICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFycmF5W2ldID09PSBpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBvYmplY3RBcHBseShvYmplY3QsIGYpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICBmKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgb2JqZWN0QXBwbHkob2JqZWN0LCBmdW5jdGlvbiAoXywga2V5KSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH0pO1xuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBvYmplY3RBcHBseShvYmplY3QsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIGFwcGx5KGFycmF5LCBmLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmLmNhbGwoY29udGV4dCB8fCBnbG9iYWwsIGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwKGFycmF5LCBmKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZihhcnJheVtpXSwgaSwgYXJyYXksIHJlc3VsdCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFwT2JqZWN0KG9iamVjdCwgZikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBvYmplY3RBcHBseShvYmplY3QsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gZih2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbHRlcihhcnJheSwgdGVzdCkge1xuICAgIHRlc3QgPVxuICAgICAgICB0ZXN0IHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISF2YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRlc3QoYXJyYXlbaV0sIGksIGFycmF5LCByZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbHRlck9iamVjdChvYmplY3QsIHRlc3QpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgb2JqZWN0QXBwbHkob2JqZWN0LCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoKHRlc3QgJiYgdGVzdCh2YWx1ZSwga2V5LCBvYmplY3QsIHJlc3VsdCkpIHx8IEJvb2xlYW4odmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqZWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIG9iamVjdEFwcGx5KG9iamVjdCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYW55KGFycmF5LCB0ZXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGVzdChhcnJheVtpXSwgaSwgYXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb2xsZWN0aW9uc19hbGwoYXJyYXksIHRlc3QpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghdGVzdChhcnJheVtpXSwgaSwgYXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBlbmNvZGVQYXJhbXNPYmplY3QoZGF0YSkge1xuICAgIHJldHVybiBtYXBPYmplY3QoZGF0YSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNhZmVKU09OU3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGVuY29kZSh2YWx1ZS50b1N0cmluZygpKSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBidWlsZFF1ZXJ5U3RyaW5nKGRhdGEpIHtcbiAgICB2YXIgcGFyYW1zID0gZmlsdGVyT2JqZWN0KGRhdGEsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICB2YXIgcXVlcnkgPSBtYXAoZmxhdHRlbihlbmNvZGVQYXJhbXNPYmplY3QocGFyYW1zKSksIHV0aWwubWV0aG9kKCdqb2luJywgJz0nKSkuam9pbignJicpO1xuICAgIHJldHVybiBxdWVyeTtcbn1cbmZ1bmN0aW9uIGRlY3ljbGVPYmplY3Qob2JqZWN0KSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXSwgcGF0aHMgPSBbXTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIGRlcmV6KHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHZhciBpLCBuYW1lLCBudTtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdHNbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyAkcmVmOiBwYXRoc1tpXSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9iamVjdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICAgICAgbnUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudVtpXSA9IGRlcmV6KHZhbHVlW2ldLCBwYXRoICsgJ1snICsgaSArICddJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG51ID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAobmFtZSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudVtuYW1lXSA9IGRlcmV6KHZhbHVlW25hbWVdLCBwYXRoICsgJ1snICsgSlNPTi5zdHJpbmdpZnkobmFtZSkgKyAnXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudTtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfSkob2JqZWN0LCAnJCcpO1xufVxuZnVuY3Rpb24gc2FmZUpTT05TdHJpbmdpZnkoc291cmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHNvdXJjZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkZWN5Y2xlT2JqZWN0KHNvdXJjZSkpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9kZWZhdWx0cy50c1xudmFyIERlZmF1bHRzID0ge1xuICAgIFZFUlNJT046IFwiOC40LjAtcmMyXCIsXG4gICAgUFJPVE9DT0w6IDcsXG4gICAgd3NQb3J0OiA4MCxcbiAgICB3c3NQb3J0OiA0NDMsXG4gICAgd3NQYXRoOiAnJyxcbiAgICBodHRwSG9zdDogJ3NvY2tqcy5wdXNoZXIuY29tJyxcbiAgICBodHRwUG9ydDogODAsXG4gICAgaHR0cHNQb3J0OiA0NDMsXG4gICAgaHR0cFBhdGg6ICcvcHVzaGVyJyxcbiAgICBzdGF0c19ob3N0OiAnc3RhdHMucHVzaGVyLmNvbScsXG4gICAgYXV0aEVuZHBvaW50OiAnL3B1c2hlci9hdXRoJyxcbiAgICBhdXRoVHJhbnNwb3J0OiAnYWpheCcsXG4gICAgYWN0aXZpdHlUaW1lb3V0OiAxMjAwMDAsXG4gICAgcG9uZ1RpbWVvdXQ6IDMwMDAwLFxuICAgIHVuYXZhaWxhYmxlVGltZW91dDogMTAwMDAsXG4gICAgdXNlckF1dGhlbnRpY2F0aW9uOiB7XG4gICAgICAgIGVuZHBvaW50OiAnL3B1c2hlci91c2VyLWF1dGgnLFxuICAgICAgICB0cmFuc3BvcnQ6ICdhamF4J1xuICAgIH0sXG4gICAgY2hhbm5lbEF1dGhvcml6YXRpb246IHtcbiAgICAgICAgZW5kcG9pbnQ6ICcvcHVzaGVyL2F1dGgnLFxuICAgICAgICB0cmFuc3BvcnQ6ICdhamF4J1xuICAgIH0sXG4gICAgY2RuX2h0dHA6IFwiaHR0cDovL2pzLnB1c2hlci5jb21cIixcbiAgICBjZG5faHR0cHM6IFwiaHR0cHM6Ly9qcy5wdXNoZXIuY29tXCIsXG4gICAgZGVwZW5kZW5jeV9zdWZmaXg6IFwiXCJcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkZWZhdWx0cyA9IChEZWZhdWx0cyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy91cmxfc2NoZW1lcy50c1xuXG5mdW5jdGlvbiBnZXRHZW5lcmljVVJMKGJhc2VTY2hlbWUsIHBhcmFtcywgcGF0aCkge1xuICAgIHZhciBzY2hlbWUgPSBiYXNlU2NoZW1lICsgKHBhcmFtcy51c2VUTFMgPyAncycgOiAnJyk7XG4gICAgdmFyIGhvc3QgPSBwYXJhbXMudXNlVExTID8gcGFyYW1zLmhvc3RUTFMgOiBwYXJhbXMuaG9zdE5vblRMUztcbiAgICByZXR1cm4gc2NoZW1lICsgJzovLycgKyBob3N0ICsgcGF0aDtcbn1cbmZ1bmN0aW9uIGdldEdlbmVyaWNQYXRoKGtleSwgcXVlcnlTdHJpbmcpIHtcbiAgICB2YXIgcGF0aCA9ICcvYXBwLycgKyBrZXk7XG4gICAgdmFyIHF1ZXJ5ID0gJz9wcm90b2NvbD0nICtcbiAgICAgICAgZGVmYXVsdHMuUFJPVE9DT0wgK1xuICAgICAgICAnJmNsaWVudD1qcycgK1xuICAgICAgICAnJnZlcnNpb249JyArXG4gICAgICAgIGRlZmF1bHRzLlZFUlNJT04gK1xuICAgICAgICAocXVlcnlTdHJpbmcgPyAnJicgKyBxdWVyeVN0cmluZyA6ICcnKTtcbiAgICByZXR1cm4gcGF0aCArIHF1ZXJ5O1xufVxudmFyIHdzID0ge1xuICAgIGdldEluaXRpYWw6IGZ1bmN0aW9uIChrZXksIHBhcmFtcykge1xuICAgICAgICB2YXIgcGF0aCA9IChwYXJhbXMuaHR0cFBhdGggfHwgJycpICsgZ2V0R2VuZXJpY1BhdGgoa2V5LCAnZmxhc2g9ZmFsc2UnKTtcbiAgICAgICAgcmV0dXJuIGdldEdlbmVyaWNVUkwoJ3dzJywgcGFyYW1zLCBwYXRoKTtcbiAgICB9XG59O1xudmFyIGh0dHAgPSB7XG4gICAgZ2V0SW5pdGlhbDogZnVuY3Rpb24gKGtleSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXRoID0gKHBhcmFtcy5odHRwUGF0aCB8fCAnL3B1c2hlcicpICsgZ2V0R2VuZXJpY1BhdGgoa2V5KTtcbiAgICAgICAgcmV0dXJuIGdldEdlbmVyaWNVUkwoJ2h0dHAnLCBwYXJhbXMsIHBhdGgpO1xuICAgIH1cbn07XG52YXIgc29ja2pzID0ge1xuICAgIGdldEluaXRpYWw6IGZ1bmN0aW9uIChrZXksIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gZ2V0R2VuZXJpY1VSTCgnaHR0cCcsIHBhcmFtcywgcGFyYW1zLmh0dHBQYXRoIHx8ICcvcHVzaGVyJyk7XG4gICAgfSxcbiAgICBnZXRQYXRoOiBmdW5jdGlvbiAoa2V5LCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGdldEdlbmVyaWNQYXRoKGtleSk7XG4gICAgfVxufTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9ldmVudHMvY2FsbGJhY2tfcmVnaXN0cnkudHNcblxuY2xhc3MgY2FsbGJhY2tfcmVnaXN0cnlfQ2FsbGJhY2tSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIH1cbiAgICBnZXQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW3ByZWZpeChuYW1lKV07XG4gICAgfVxuICAgIGFkZChuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB2YXIgcHJlZml4ZWRFdmVudE5hbWUgPSBwcmVmaXgobmFtZSk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrc1twcmVmaXhlZEV2ZW50TmFtZV0gPVxuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzW3ByZWZpeGVkRXZlbnROYW1lXSB8fCBbXTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzW3ByZWZpeGVkRXZlbnROYW1lXS5wdXNoKHtcbiAgICAgICAgICAgIGZuOiBjYWxsYmFjayxcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZShuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICBpZiAoIW5hbWUgJiYgIWNhbGxiYWNrICYmICFjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXMgPSBuYW1lID8gW3ByZWZpeChuYW1lKV0gOiBrZXlzKHRoaXMuX2NhbGxiYWNrcyk7XG4gICAgICAgIGlmIChjYWxsYmFjayB8fCBjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNhbGxiYWNrKG5hbWVzLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbENhbGxiYWNrcyhuYW1lcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2FsbGJhY2sobmFtZXMsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGFwcGx5KG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzW25hbWVdID0gZmlsdGVyKHRoaXMuX2NhbGxiYWNrc1tuYW1lXSB8fCBbXSwgZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChjYWxsYmFjayAmJiBjYWxsYmFjayAhPT0gYmluZGluZy5mbikgfHxcbiAgICAgICAgICAgICAgICAgICAgKGNvbnRleHQgJiYgY29udGV4dCAhPT0gYmluZGluZy5jb250ZXh0KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3NbbmFtZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIHJlbW92ZUFsbENhbGxiYWNrcyhuYW1lcykge1xuICAgICAgICBhcHBseShuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbbmFtZV07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByZWZpeChuYW1lKSB7XG4gICAgcmV0dXJuICdfJyArIG5hbWU7XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvZXZlbnRzL2Rpc3BhdGNoZXIudHNcblxuXG5jbGFzcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGZhaWxUaHJvdWdoKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gbmV3IGNhbGxiYWNrX3JlZ2lzdHJ5X0NhbGxiYWNrUmVnaXN0cnkoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxfY2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuZmFpbFRocm91Z2ggPSBmYWlsVGhyb3VnaDtcbiAgICB9XG4gICAgYmluZChldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmFkZChldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJpbmRfZ2xvYmFsKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZChldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLnJlbW92ZShldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZF9nbG9iYWwoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxfY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsb2JhbF9jYWxsYmFja3MgPSBmaWx0ZXIodGhpcy5nbG9iYWxfY2FsbGJhY2tzIHx8IFtdLCBjID0+IGMgIT09IGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZF9hbGwoKSB7XG4gICAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgICAgIHRoaXMudW5iaW5kX2dsb2JhbCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW1pdChldmVudE5hbWUsIGRhdGEsIG1ldGFkYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nbG9iYWxfY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbF9jYWxsYmFja3NbaV0oZXZlbnROYW1lLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgYXJncy5wdXNoKGRhdGEsIG1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrcyAmJiBjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3NbaV0uZm4uYXBwbHkoY2FsbGJhY2tzW2ldLmNvbnRleHQgfHwgZ2xvYmFsLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZhaWxUaHJvdWdoKSB7XG4gICAgICAgICAgICB0aGlzLmZhaWxUaHJvdWdoKGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2xvZ2dlci50c1xuXG5cbmNsYXNzIGxvZ2dlcl9Mb2dnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmdsb2JhbExvZyA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsLmNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMubG9nKHRoaXMuZ2xvYmFsTG9nLCBhcmdzKTtcbiAgICB9XG4gICAgd2FybiguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMubG9nKHRoaXMuZ2xvYmFsTG9nV2FybiwgYXJncyk7XG4gICAgfVxuICAgIGVycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5sb2codGhpcy5nbG9iYWxMb2dFcnJvciwgYXJncyk7XG4gICAgfVxuICAgIGdsb2JhbExvZ1dhcm4obWVzc2FnZSkge1xuICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgZ2xvYmFsLmNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdsb2JhbExvZ0Vycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICBnbG9iYWwuY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nV2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2coZGVmYXVsdExvZ2dpbmdGdW5jdGlvbiwgLi4uYXJncykge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IHN0cmluZ2lmeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoY29yZV9wdXNoZXIubG9nKSB7XG4gICAgICAgICAgICBjb3JlX3B1c2hlci5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29yZV9wdXNoZXIubG9nVG9Db25zb2xlKSB7XG4gICAgICAgICAgICBjb25zdCBsb2cgPSBkZWZhdWx0TG9nZ2luZ0Z1bmN0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBsb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBsb2dnZXIgPSAobmV3IGxvZ2dlcl9Mb2dnZXIoKSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy90cmFuc3BvcnRfY29ubmVjdGlvbi50c1xuXG5cblxuXG5cbmNsYXNzIHRyYW5zcG9ydF9jb25uZWN0aW9uX1RyYW5zcG9ydENvbm5lY3Rpb24gZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGhvb2tzLCBuYW1lLCBwcmlvcml0eSwga2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSA9IG5vZGVfcnVudGltZS50cmFuc3BvcnRDb25uZWN0aW9uSW5pdGlhbGl6ZXI7XG4gICAgICAgIHRoaXMuaG9va3MgPSBob29rcztcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICduZXcnO1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gb3B0aW9ucy50aW1lbGluZTtcbiAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVvdXQgPSBvcHRpb25zLmFjdGl2aXR5VGltZW91dDtcbiAgICAgICAgdGhpcy5pZCA9IHRoaXMudGltZWxpbmUuZ2VuZXJhdGVVbmlxdWVJRCgpO1xuICAgIH1cbiAgICBoYW5kbGVzQWN0aXZpdHlDaGVja3MoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaG9va3MuaGFuZGxlc0FjdGl2aXR5Q2hlY2tzKTtcbiAgICB9XG4gICAgc3VwcG9ydHNQaW5nKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmhvb2tzLnN1cHBvcnRzUGluZyk7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldCB8fCB0aGlzLnN0YXRlICE9PSAnaW5pdGlhbGl6ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVybCA9IHRoaXMuaG9va3MudXJscy5nZXRJbml0aWFsKHRoaXMua2V5LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSB0aGlzLmhvb2tzLmdldFNvY2tldCh1cmwsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHV0aWwuZGVmZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdjbG9zZWQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmluZExpc3RlbmVycygpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ0Nvbm5lY3RpbmcnLCB7IHRyYW5zcG9ydDogdGhpcy5uYW1lLCB1cmwgfSk7XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICAgICAgdXRpbC5kZWZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ29wZW4nICYmIHRoaXMuc3VwcG9ydHNQaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnBpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmhvb2tzLmJlZm9yZU9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuaG9va3MuYmVmb3JlT3Blbih0aGlzLnNvY2tldCwgdGhpcy5ob29rcy51cmxzLmdldFBhdGgodGhpcy5rZXksIHRoaXMub3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ29wZW4nKTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25vcGVuID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB7IHR5cGU6ICdXZWJTb2NrZXRFcnJvcicsIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgdGhpcy50aW1lbGluZS5lcnJvcih0aGlzLmJ1aWxkVGltZWxpbmVNZXNzYWdlKHsgZXJyb3I6IGVycm9yLnRvU3RyaW5nKCkgfSkpO1xuICAgIH1cbiAgICBvbkNsb3NlKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgaWYgKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ2Nsb3NlZCcsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjbG9zZUV2ZW50LmNvZGUsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBjbG9zZUV2ZW50LnJlYXNvbixcbiAgICAgICAgICAgICAgICB3YXNDbGVhbjogY2xvc2VFdmVudC53YXNDbGVhblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuYmluZExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgfVxuICAgIG9uQWN0aXZpdHkoKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnYWN0aXZpdHknKTtcbiAgICB9XG4gICAgYmluZExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbk9wZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25lcnJvciA9IGVycm9yID0+IHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uY2xvc2UgPSBjbG9zZUV2ZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZShjbG9zZUV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25tZXNzYWdlID0gbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNQaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uYWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuYmluZExpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbm9wZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbmVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25jbG9zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1cHBvcnRzUGluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQub25hY3Rpdml0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VTdGF0ZShzdGF0ZSwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHRoaXMuYnVpbGRUaW1lbGluZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmVtaXQoc3RhdGUsIHBhcmFtcyk7XG4gICAgfVxuICAgIGJ1aWxkVGltZWxpbmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7IGNpZDogdGhpcy5pZCB9LCBtZXNzYWdlKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy90cmFuc3BvcnQudHNcblxuY2xhc3MgdHJhbnNwb3J0X1RyYW5zcG9ydCB7XG4gICAgY29uc3RydWN0b3IoaG9va3MpIHtcbiAgICAgICAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZChlbnZpcm9ubWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob29rcy5pc1N1cHBvcnRlZChlbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIGNyZWF0ZUNvbm5lY3Rpb24obmFtZSwgcHJpb3JpdHksIGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zcG9ydF9jb25uZWN0aW9uX1RyYW5zcG9ydENvbm5lY3Rpb24odGhpcy5ob29rcywgbmFtZSwgcHJpb3JpdHksIGtleSwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL3RyYW5zcG9ydHMvdHJhbnNwb3J0cy50c1xuXG5cblxuXG52YXIgV1NUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X1RyYW5zcG9ydCh7XG4gICAgdXJsczogd3MsXG4gICAgaGFuZGxlc0FjdGl2aXR5Q2hlY2tzOiBmYWxzZSxcbiAgICBzdXBwb3J0c1Bpbmc6IGZhbHNlLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4obm9kZV9ydW50aW1lLmdldFdlYlNvY2tldEFQSSgpKTtcbiAgICB9LFxuICAgIGlzU3VwcG9ydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKG5vZGVfcnVudGltZS5nZXRXZWJTb2NrZXRBUEkoKSk7XG4gICAgfSxcbiAgICBnZXRTb2NrZXQ6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVfcnVudGltZS5jcmVhdGVXZWJTb2NrZXQodXJsKTtcbiAgICB9XG59KTtcbnZhciBodHRwQ29uZmlndXJhdGlvbiA9IHtcbiAgICB1cmxzOiBodHRwLFxuICAgIGhhbmRsZXNBY3Rpdml0eUNoZWNrczogZmFsc2UsXG4gICAgc3VwcG9ydHNQaW5nOiB0cnVlLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcbnZhciBzdHJlYW1pbmdDb25maWd1cmF0aW9uID0gZXh0ZW5kKHtcbiAgICBnZXRTb2NrZXQ6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVfcnVudGltZS5IVFRQRmFjdG9yeS5jcmVhdGVTdHJlYW1pbmdTb2NrZXQodXJsKTtcbiAgICB9XG59LCBodHRwQ29uZmlndXJhdGlvbik7XG52YXIgcG9sbGluZ0NvbmZpZ3VyYXRpb24gPSBleHRlbmQoe1xuICAgIGdldFNvY2tldDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gbm9kZV9ydW50aW1lLkhUVFBGYWN0b3J5LmNyZWF0ZVBvbGxpbmdTb2NrZXQodXJsKTtcbiAgICB9XG59LCBodHRwQ29uZmlndXJhdGlvbik7XG52YXIgeGhyQ29uZmlndXJhdGlvbiA9IHtcbiAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbm9kZV9ydW50aW1lLmlzWEhSU3VwcG9ydGVkKCk7XG4gICAgfVxufTtcbnZhciBYSFJTdHJlYW1pbmdUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X1RyYW5zcG9ydCgoZXh0ZW5kKHt9LCBzdHJlYW1pbmdDb25maWd1cmF0aW9uLCB4aHJDb25maWd1cmF0aW9uKSkpO1xudmFyIFhIUlBvbGxpbmdUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X1RyYW5zcG9ydChleHRlbmQoe30sIHBvbGxpbmdDb25maWd1cmF0aW9uLCB4aHJDb25maWd1cmF0aW9uKSk7XG52YXIgVHJhbnNwb3J0cyA9IHtcbiAgICB3czogV1NUcmFuc3BvcnQsXG4gICAgeGhyX3N0cmVhbWluZzogWEhSU3RyZWFtaW5nVHJhbnNwb3J0LFxuICAgIHhocl9wb2xsaW5nOiBYSFJQb2xsaW5nVHJhbnNwb3J0XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwb3J0cyA9IChUcmFuc3BvcnRzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90cmFuc3BvcnRzL2Fzc2lzdGFudF90b190aGVfdHJhbnNwb3J0X21hbmFnZXIudHNcblxuXG5jbGFzcyBhc3Npc3RhbnRfdG9fdGhlX3RyYW5zcG9ydF9tYW5hZ2VyX0Fzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IobWFuYWdlciwgdHJhbnNwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLm1pblBpbmdEZWxheSA9IG9wdGlvbnMubWluUGluZ0RlbGF5O1xuICAgICAgICB0aGlzLm1heFBpbmdEZWxheSA9IG9wdGlvbnMubWF4UGluZ0RlbGF5O1xuICAgICAgICB0aGlzLnBpbmdEZWxheSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY3JlYXRlQ29ubmVjdGlvbihuYW1lLCBwcmlvcml0eSwga2V5LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGFjdGl2aXR5VGltZW91dDogdGhpcy5waW5nRGVsYXlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy50cmFuc3BvcnQuY3JlYXRlQ29ubmVjdGlvbihuYW1lLCBwcmlvcml0eSwga2V5LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG9wZW5UaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB2YXIgb25PcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi51bmJpbmQoJ29wZW4nLCBvbk9wZW4pO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5iaW5kKCdjbG9zZWQnLCBvbkNsb3NlZCk7XG4gICAgICAgICAgICBvcGVuVGltZXN0YW1wID0gdXRpbC5ub3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uQ2xvc2VkID0gY2xvc2VFdmVudCA9PiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnVuYmluZCgnY2xvc2VkJywgb25DbG9zZWQpO1xuICAgICAgICAgICAgaWYgKGNsb3NlRXZlbnQuY29kZSA9PT0gMTAwMiB8fCBjbG9zZUV2ZW50LmNvZGUgPT09IDEwMDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIucmVwb3J0RGVhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjbG9zZUV2ZW50Lndhc0NsZWFuICYmIG9wZW5UaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlmZXNwYW4gPSB1dGlsLm5vdygpIC0gb3BlblRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBpZiAobGlmZXNwYW4gPCAyICogdGhpcy5tYXhQaW5nRGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLnJlcG9ydERlYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGluZ0RlbGF5ID0gTWF0aC5tYXgobGlmZXNwYW4gLyAyLCB0aGlzLm1pblBpbmdEZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25uZWN0aW9uLmJpbmQoJ29wZW4nLCBvbk9wZW4pO1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoZW52aXJvbm1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5pc0FsaXZlKCkgJiYgdGhpcy50cmFuc3BvcnQuaXNTdXBwb3J0ZWQoZW52aXJvbm1lbnQpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jb25uZWN0aW9uL3Byb3RvY29sL3Byb3RvY29sLnRzXG5jb25zdCBQcm90b2NvbCA9IHtcbiAgICBkZWNvZGVNZXNzYWdlOiBmdW5jdGlvbiAobWVzc2FnZUV2ZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZURhdGEgPSBKU09OLnBhcnNlKG1lc3NhZ2VFdmVudC5kYXRhKTtcbiAgICAgICAgICAgIHZhciBwdXNoZXJFdmVudERhdGEgPSBtZXNzYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwdXNoZXJFdmVudERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaGVyRXZlbnREYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlRGF0YS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHB1c2hlckV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBtZXNzYWdlRGF0YS5ldmVudCxcbiAgICAgICAgICAgICAgICBjaGFubmVsOiBtZXNzYWdlRGF0YS5jaGFubmVsLFxuICAgICAgICAgICAgICAgIGRhdGE6IHB1c2hlckV2ZW50RGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlRGF0YS51c2VyX2lkKSB7XG4gICAgICAgICAgICAgICAgcHVzaGVyRXZlbnQudXNlcl9pZCA9IG1lc3NhZ2VEYXRhLnVzZXJfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHVzaGVyRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ01lc3NhZ2VQYXJzZUVycm9yJywgZXJyb3I6IGUsIGRhdGE6IG1lc3NhZ2VFdmVudC5kYXRhIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGVuY29kZU1lc3NhZ2U6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXZlbnQpO1xuICAgIH0sXG4gICAgcHJvY2Vzc0hhbmRzaGFrZTogZnVuY3Rpb24gKG1lc3NhZ2VFdmVudCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFByb3RvY29sLmRlY29kZU1lc3NhZ2UobWVzc2FnZUV2ZW50KTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnQgPT09ICdwdXNoZXI6Y29ubmVjdGlvbl9lc3RhYmxpc2hlZCcpIHtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZS5kYXRhLmFjdGl2aXR5X3RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnTm8gYWN0aXZpdHkgdGltZW91dCBzcGVjaWZpZWQgaW4gaGFuZHNoYWtlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICBpZDogbWVzc2FnZS5kYXRhLnNvY2tldF9pZCxcbiAgICAgICAgICAgICAgICBhY3Rpdml0eVRpbWVvdXQ6IG1lc3NhZ2UuZGF0YS5hY3Rpdml0eV90aW1lb3V0ICogMTAwMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmV2ZW50ID09PSAncHVzaGVyOmVycm9yJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IHRoaXMuZ2V0Q2xvc2VBY3Rpb24obWVzc2FnZS5kYXRhKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5nZXRDbG9zZUVycm9yKG1lc3NhZ2UuZGF0YSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnSW52YWxpZCBoYW5kc2hha2UnO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRDbG9zZUFjdGlvbjogZnVuY3Rpb24gKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgaWYgKGNsb3NlRXZlbnQuY29kZSA8IDQwMDApIHtcbiAgICAgICAgICAgIGlmIChjbG9zZUV2ZW50LmNvZGUgPj0gMTAwMiAmJiBjbG9zZUV2ZW50LmNvZGUgPD0gMTAwNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYmFja29mZic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbG9zZUV2ZW50LmNvZGUgPT09IDQwMDApIHtcbiAgICAgICAgICAgIHJldHVybiAndGxzX29ubHknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsb3NlRXZlbnQuY29kZSA8IDQxMDApIHtcbiAgICAgICAgICAgIHJldHVybiAncmVmdXNlZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xvc2VFdmVudC5jb2RlIDwgNDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuICdiYWNrb2ZmJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbG9zZUV2ZW50LmNvZGUgPCA0MzAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3JldHJ5JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAncmVmdXNlZCc7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldENsb3NlRXJyb3I6IGZ1bmN0aW9uIChjbG9zZUV2ZW50KSB7XG4gICAgICAgIGlmIChjbG9zZUV2ZW50LmNvZGUgIT09IDEwMDAgJiYgY2xvc2VFdmVudC5jb2RlICE9PSAxMDAxKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQdXNoZXJFcnJvcicsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjbG9zZUV2ZW50LmNvZGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNsb3NlRXZlbnQucmVhc29uIHx8IGNsb3NlRXZlbnQubWVzc2FnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwcm90b2NvbCA9IChQcm90b2NvbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29ubmVjdGlvbi9jb25uZWN0aW9uLnRzXG5cblxuXG5cbmNsYXNzIGNvbm5lY3Rpb25fQ29ubmVjdGlvbiBleHRlbmRzIGRpc3BhdGNoZXJfRGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IoaWQsIHRyYW5zcG9ydCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLmFjdGl2aXR5VGltZW91dCA9IHRyYW5zcG9ydC5hY3Rpdml0eVRpbWVvdXQ7XG4gICAgICAgIHRoaXMuYmluZExpc3RlbmVycygpO1xuICAgIH1cbiAgICBoYW5kbGVzQWN0aXZpdHlDaGVja3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5oYW5kbGVzQWN0aXZpdHlDaGVja3MoKTtcbiAgICB9XG4gICAgc2VuZChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5zZW5kKGRhdGEpO1xuICAgIH1cbiAgICBzZW5kX2V2ZW50KG5hbWUsIGRhdGEsIGNoYW5uZWwpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0geyBldmVudDogbmFtZSwgZGF0YTogZGF0YSB9O1xuICAgICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgZXZlbnQuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdFdmVudCBzZW50JywgZXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHByb3RvY29sLmVuY29kZU1lc3NhZ2UoZXZlbnQpKTtcbiAgICB9XG4gICAgcGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0LnN1cHBvcnRzUGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5waW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRfZXZlbnQoJ3B1c2hlcjpwaW5nJywge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cbiAgICBiaW5kTGlzdGVuZXJzKCkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogKG1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBwdXNoZXJFdmVudDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoZXJFdmVudCA9IHByb3RvY29sLmRlY29kZU1lc3NhZ2UobWVzc2FnZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNZXNzYWdlUGFyc2VFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2VFdmVudC5kYXRhXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHVzaGVyRXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ0V2ZW50IHJlY2QnLCBwdXNoZXJFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHVzaGVyRXZlbnQuZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1c2hlcjplcnJvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1B1c2hlckVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcHVzaGVyRXZlbnQuZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHVzaGVyOnBpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHVzaGVyOnBvbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHB1c2hlckV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWN0aXZpdHk6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2FjdGl2aXR5Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlZDogY2xvc2VFdmVudCA9PiB7XG4gICAgICAgICAgICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlRXZlbnQgJiYgY2xvc2VFdmVudC5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VFdmVudChjbG9zZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB1bmJpbmRMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgICAgICAgICBvYmplY3RBcHBseShsaXN0ZW5lcnMsIChsaXN0ZW5lciwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC51bmJpbmQoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBvYmplY3RBcHBseShsaXN0ZW5lcnMsIChsaXN0ZW5lciwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmJpbmQoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUNsb3NlRXZlbnQoY2xvc2VFdmVudCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gcHJvdG9jb2wuZ2V0Q2xvc2VBY3Rpb24oY2xvc2VFdmVudCk7XG4gICAgICAgIHZhciBlcnJvciA9IHByb3RvY29sLmdldENsb3NlRXJyb3IoY2xvc2VFdmVudCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoYWN0aW9uLCB7IGFjdGlvbjogYWN0aW9uLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29ubmVjdGlvbi9oYW5kc2hha2UvaW5kZXgudHNcblxuXG5cbmNsYXNzIGhhbmRzaGFrZV9IYW5kc2hha2Uge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5iaW5kTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnVuYmluZExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cbiAgICBiaW5kTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLm9uTWVzc2FnZSA9IG0gPT4ge1xuICAgICAgICAgICAgdGhpcy51bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByb3RvY29sLnByb2Nlc3NIYW5kc2hha2UobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoKCdlcnJvcicsIHsgZXJyb3I6IGUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFjdGlvbiA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaCgnY29ubmVjdGVkJywge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiBuZXcgY29ubmVjdGlvbl9Db25uZWN0aW9uKHJlc3VsdC5pZCwgdGhpcy50cmFuc3BvcnQpLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eVRpbWVvdXQ6IHJlc3VsdC5hY3Rpdml0eVRpbWVvdXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoKHJlc3VsdC5hY3Rpb24sIHsgZXJyb3I6IHJlc3VsdC5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQ2xvc2VkID0gY2xvc2VFdmVudCA9PiB7XG4gICAgICAgICAgICB0aGlzLnVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHByb3RvY29sLmdldENsb3NlQWN0aW9uKGNsb3NlRXZlbnQpIHx8ICdiYWNrb2ZmJztcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHByb3RvY29sLmdldENsb3NlRXJyb3IoY2xvc2VFdmVudCk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaChhY3Rpb24sIHsgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5iaW5kKCdtZXNzYWdlJywgdGhpcy5vbk1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5iaW5kKCdjbG9zZWQnLCB0aGlzLm9uQ2xvc2VkKTtcbiAgICB9XG4gICAgdW5iaW5kTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC51bmJpbmQoJ21lc3NhZ2UnLCB0aGlzLm9uTWVzc2FnZSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnVuYmluZCgnY2xvc2VkJywgdGhpcy5vbkNsb3NlZCk7XG4gICAgfVxuICAgIGZpbmlzaChhY3Rpb24sIHBhcmFtcykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrKGV4dGVuZCh7IHRyYW5zcG9ydDogdGhpcy50cmFuc3BvcnQsIGFjdGlvbjogYWN0aW9uIH0sIHBhcmFtcykpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90aW1lbGluZS90aW1lbGluZV9zZW5kZXIudHNcblxuY2xhc3MgdGltZWxpbmVfc2VuZGVyX1RpbWVsaW5lU2VuZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0aW1lbGluZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gdGltZWxpbmU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgfVxuICAgIHNlbmQodXNlVExTLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy50aW1lbGluZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVsaW5lLnNlbmQobm9kZV9ydW50aW1lLlRpbWVsaW5lVHJhbnNwb3J0LmdldEFnZW50KHRoaXMsIHVzZVRMUyksIGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvZXJyb3JzLnRzXG5jbGFzcyBCYWRFdmVudE5hbWUgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgQmFkQ2hhbm5lbE5hbWUgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgUmVxdWVzdFRpbWVkT3V0IGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmNsYXNzIFRyYW5zcG9ydFByaW9yaXR5VG9vTG93IGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmNsYXNzIFRyYW5zcG9ydENsb3NlZCBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5jbGFzcyBVbnN1cHBvcnRlZEZlYXR1cmUgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgVW5zdXBwb3J0ZWRUcmFuc3BvcnQgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgVW5zdXBwb3J0ZWRTdHJhdGVneSBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5jbGFzcyBIVFRQQXV0aEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YXR1cywgbXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy91cmxfc3RvcmUudHNcbmNvbnN0IHVybFN0b3JlID0ge1xuICAgIGJhc2VVcmw6ICdodHRwczovL3B1c2hlci5jb20nLFxuICAgIHVybHM6IHtcbiAgICAgICAgYXV0aGVudGljYXRpb25FbmRwb2ludDoge1xuICAgICAgICAgICAgcGF0aDogJy9kb2NzL2NoYW5uZWxzL3NlcnZlcl9hcGkvYXV0aGVudGljYXRpbmdfdXNlcnMnXG4gICAgICAgIH0sXG4gICAgICAgIGF1dGhvcml6YXRpb25FbmRwb2ludDoge1xuICAgICAgICAgICAgcGF0aDogJy9kb2NzL2NoYW5uZWxzL3NlcnZlcl9hcGkvYXV0aG9yaXppbmctdXNlcnMvJ1xuICAgICAgICB9LFxuICAgICAgICBqYXZhc2NyaXB0UXVpY2tTdGFydDoge1xuICAgICAgICAgICAgcGF0aDogJy9kb2NzL2phdmFzY3JpcHRfcXVpY2tfc3RhcnQnXG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJpbmdDbGllbnRFdmVudHM6IHtcbiAgICAgICAgICAgIHBhdGg6ICcvZG9jcy9jbGllbnRfYXBpX2d1aWRlL2NsaWVudF9ldmVudHMjdHJpZ2dlci1ldmVudHMnXG4gICAgICAgIH0sXG4gICAgICAgIGVuY3J5cHRlZENoYW5uZWxTdXBwb3J0OiB7XG4gICAgICAgICAgICBmdWxsVXJsOiAnaHR0cHM6Ly9naXRodWIuY29tL3B1c2hlci9wdXNoZXItanMvdHJlZS9jYzQ5MTAxNTM3MWE0YmRlNTc0M2QxYzg3YTBmYmFjMGZlYjUzMTk1I2VuY3J5cHRlZC1jaGFubmVsLXN1cHBvcnQnXG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgYnVpbGRMb2dTdWZmaXggPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgY29uc3QgdXJsUHJlZml4ID0gJ1NlZTonO1xuICAgIGNvbnN0IHVybE9iaiA9IHVybFN0b3JlLnVybHNba2V5XTtcbiAgICBpZiAoIXVybE9iailcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGxldCB1cmw7XG4gICAgaWYgKHVybE9iai5mdWxsVXJsKSB7XG4gICAgICAgIHVybCA9IHVybE9iai5mdWxsVXJsO1xuICAgIH1cbiAgICBlbHNlIGlmICh1cmxPYmoucGF0aCkge1xuICAgICAgICB1cmwgPSB1cmxTdG9yZS5iYXNlVXJsICsgdXJsT2JqLnBhdGg7XG4gICAgfVxuICAgIGlmICghdXJsKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgcmV0dXJuIGAke3VybFByZWZpeH0gJHt1cmx9YDtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1cmxfc3RvcmUgPSAoeyBidWlsZExvZ1N1ZmZpeCB9KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9jaGFubmVsLnRzXG5cblxuXG5cblxuY2xhc3MgY2hhbm5lbF9DaGFubmVsIGV4dGVuZHMgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgc3VwZXIoZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ05vIGNhbGxiYWNrcyBvbiAnICsgbmFtZSArICcgZm9yICcgKyBldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnB1c2hlciA9IHB1c2hlcjtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBhdXRob3JpemUoc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7IGF1dGg6ICcnIH0pO1xuICAgIH1cbiAgICB0cmlnZ2VyKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIGlmIChldmVudC5pbmRleE9mKCdjbGllbnQtJykgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCYWRFdmVudE5hbWUoXCJFdmVudCAnXCIgKyBldmVudCArIFwiJyBkb2VzIG5vdCBzdGFydCB3aXRoICdjbGllbnQtJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IHVybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgndHJpZ2dlcmluZ0NsaWVudEV2ZW50cycpO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYENsaWVudCBldmVudCB0cmlnZ2VyZWQgYmVmb3JlIGNoYW5uZWwgJ3N1YnNjcmlwdGlvbl9zdWNjZWVkZWQnIGV2ZW50IC4gJHtzdWZmaXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoZXZlbnQsIGRhdGEsIHRoaXMubmFtZSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblBlbmRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50O1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09ICdwdXNoZXJfaW50ZXJuYWw6c3Vic2NyaXB0aW9uX3N1Y2NlZWRlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uU3VjY2VlZGVkRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ3B1c2hlcl9pbnRlcm5hbDpzdWJzY3JpcHRpb25fY291bnQnKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkNvdW50RXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZS5pbmRleE9mKCdwdXNoZXJfaW50ZXJuYWw6JykgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50TmFtZSwgZGF0YSwgbWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVN1YnNjcmlwdGlvblN1Y2NlZWRlZEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaGVyLnVuc3Vic2NyaWJlKHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJywgZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlU3Vic2NyaXB0aW9uQ291bnRFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS5zdWJzY3JpcHRpb25fY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uQ291bnQgPSBldmVudC5kYXRhLnN1YnNjcmlwdGlvbl9jb3VudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjpzdWJzY3JpcHRpb25fY291bnQnLCBldmVudC5kYXRhKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25QZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdXRob3JpemUodGhpcy5wdXNoZXIuY29ubmVjdGlvbi5zb2NrZXRfaWQsIChlcnJvciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25QZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOnN1YnNjcmlwdGlvbl9lcnJvcicsIE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0F1dGhFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfSwgZXJyb3IgaW5zdGFuY2VvZiBIVFRQQXV0aEVycm9yID8geyBzdGF0dXM6IGVycm9yLnN0YXR1cyB9IDoge30pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoJ3B1c2hlcjpzdWJzY3JpYmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIGF1dGg6IGRhdGEuYXV0aCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbF9kYXRhOiBkYXRhLmNoYW5uZWxfZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5uYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoJ3B1c2hlcjp1bnN1YnNjcmliZScsIHtcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMubmFtZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2FuY2VsU3Vic2NyaXB0aW9uKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIHJlaW5zdGF0ZVN1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY2hhbm5lbHMvcHJpdmF0ZV9jaGFubmVsLnRzXG5cbmNsYXNzIHByaXZhdGVfY2hhbm5lbF9Qcml2YXRlQ2hhbm5lbCBleHRlbmRzIGNoYW5uZWxfQ2hhbm5lbCB7XG4gICAgYXV0aG9yaXplKHNvY2tldElkLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXNoZXIuY29uZmlnLmNoYW5uZWxBdXRob3JpemVyKHtcbiAgICAgICAgICAgIGNoYW5uZWxOYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBzb2NrZXRJZDogc29ja2V0SWRcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9tZW1iZXJzLnRzXG5cbmNsYXNzIG1lbWJlcnNfTWVtYmVycyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgZ2V0KGlkKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5tZW1iZXJzLCBpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGluZm86IHRoaXMubWVtYmVyc1tpZF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIG9iamVjdEFwcGx5KHRoaXMubWVtYmVycywgKG1lbWJlciwgaWQpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZ2V0KGlkKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRNeUlEKGlkKSB7XG4gICAgICAgIHRoaXMubXlJRCA9IGlkO1xuICAgIH1cbiAgICBvblN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb25EYXRhKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IHN1YnNjcmlwdGlvbkRhdGEucHJlc2VuY2UuaGFzaDtcbiAgICAgICAgdGhpcy5jb3VudCA9IHN1YnNjcmlwdGlvbkRhdGEucHJlc2VuY2UuY291bnQ7XG4gICAgICAgIHRoaXMubWUgPSB0aGlzLmdldCh0aGlzLm15SUQpO1xuICAgIH1cbiAgICBhZGRNZW1iZXIobWVtYmVyRGF0YSkge1xuICAgICAgICBpZiAodGhpcy5nZXQobWVtYmVyRGF0YS51c2VyX2lkKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVtYmVyc1ttZW1iZXJEYXRhLnVzZXJfaWRdID0gbWVtYmVyRGF0YS51c2VyX2luZm87XG4gICAgICAgIHJldHVybiB0aGlzLmdldChtZW1iZXJEYXRhLnVzZXJfaWQpO1xuICAgIH1cbiAgICByZW1vdmVNZW1iZXIobWVtYmVyRGF0YSkge1xuICAgICAgICB2YXIgbWVtYmVyID0gdGhpcy5nZXQobWVtYmVyRGF0YS51c2VyX2lkKTtcbiAgICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubWVtYmVyc1ttZW1iZXJEYXRhLnVzZXJfaWRdO1xuICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1iZXI7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMubXlJRCA9IG51bGw7XG4gICAgICAgIHRoaXMubWUgPSBudWxsO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9wcmVzZW5jZV9jaGFubmVsLnRzXG52YXIgX19hd2FpdGVyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5cblxuXG5cbmNsYXNzIHByZXNlbmNlX2NoYW5uZWxfUHJlc2VuY2VDaGFubmVsIGV4dGVuZHMgcHJpdmF0ZV9jaGFubmVsX1ByaXZhdGVDaGFubmVsIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgc3VwZXIobmFtZSwgcHVzaGVyKTtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbmV3IG1lbWJlcnNfTWVtYmVycygpO1xuICAgIH1cbiAgICBhdXRob3JpemUoc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHN1cGVyLmF1dGhvcml6ZShzb2NrZXRJZCwgKGVycm9yLCBhdXRoRGF0YSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGF1dGhEYXRhID0gYXV0aERhdGE7XG4gICAgICAgICAgICAgICAgaWYgKGF1dGhEYXRhLmNoYW5uZWxfZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFubmVsRGF0YSA9IEpTT04ucGFyc2UoYXV0aERhdGEuY2hhbm5lbF9kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1iZXJzLnNldE15SUQoY2hhbm5lbERhdGEudXNlcl9pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnB1c2hlci51c2VyLnNpZ25pbkRvbmVQcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wdXNoZXIudXNlci51c2VyX2RhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1iZXJzLnNldE15SUQodGhpcy5wdXNoZXIudXNlci51c2VyX2RhdGEuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IHVybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgnYXV0aG9yaXphdGlvbkVuZHBvaW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEludmFsaWQgYXV0aCByZXNwb25zZSBmb3IgY2hhbm5lbCAnJHt0aGlzLm5hbWV9JywgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGV4cGVjdGVkICdjaGFubmVsX2RhdGEnIGZpZWxkLiAke3N1ZmZpeH0sIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBvciB0aGUgdXNlciBzaG91bGQgYmUgc2lnbmVkIGluLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soJ0ludmFsaWQgYXV0aCByZXNwb25zZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIGF1dGhEYXRhKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQuZXZlbnQ7XG4gICAgICAgIGlmIChldmVudE5hbWUuaW5kZXhPZigncHVzaGVyX2ludGVybmFsOicpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUludGVybmFsRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ge307XG4gICAgICAgICAgICBpZiAoZXZlbnQudXNlcl9pZCkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLnVzZXJfaWQgPSBldmVudC51c2VyX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50TmFtZSwgZGF0YSwgbWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUludGVybmFsRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50O1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdwdXNoZXJfaW50ZXJuYWw6c3Vic2NyaXB0aW9uX3N1Y2NlZWRlZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25TdWNjZWVkZWRFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwdXNoZXJfaW50ZXJuYWw6c3Vic2NyaXB0aW9uX2NvdW50JzpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkNvdW50RXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncHVzaGVyX2ludGVybmFsOm1lbWJlcl9hZGRlZCc6XG4gICAgICAgICAgICAgICAgdmFyIGFkZGVkTWVtYmVyID0gdGhpcy5tZW1iZXJzLmFkZE1lbWJlcihkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjptZW1iZXJfYWRkZWQnLCBhZGRlZE1lbWJlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwdXNoZXJfaW50ZXJuYWw6bWVtYmVyX3JlbW92ZWQnOlxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkTWVtYmVyID0gdGhpcy5tZW1iZXJzLnJlbW92ZU1lbWJlcihkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZE1lbWJlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjptZW1iZXJfcmVtb3ZlZCcsIHJlbW92ZWRNZW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVTdWJzY3JpcHRpb25TdWNjZWVkZWRFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hlci51bnN1YnNjcmliZSh0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZW1iZXJzLm9uU3Vic2NyaXB0aW9uKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwdXNoZXI6c3Vic2NyaXB0aW9uX3N1Y2NlZWRlZCcsIHRoaXMubWVtYmVycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzLnJlc2V0KCk7XG4gICAgICAgIHN1cGVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi91dGY4L2xpYi91dGY4LmpzXG52YXIgdXRmOCA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BzdGFibGVsaWIvYmFzZTY0L2xpYi9iYXNlNjQuanNcbnZhciBiYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2NoYW5uZWxzL2VuY3J5cHRlZF9jaGFubmVsLnRzXG5cblxuXG5cblxuY2xhc3MgZW5jcnlwdGVkX2NoYW5uZWxfRW5jcnlwdGVkQ2hhbm5lbCBleHRlbmRzIHByaXZhdGVfY2hhbm5lbF9Qcml2YXRlQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcHVzaGVyLCBuYWNsKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIHB1c2hlcik7XG4gICAgICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5uYWNsID0gbmFjbDtcbiAgICB9XG4gICAgYXV0aG9yaXplKHNvY2tldElkLCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlci5hdXRob3JpemUoc29ja2V0SWQsIChlcnJvciwgYXV0aERhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBhdXRoRGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNoYXJlZFNlY3JldCA9IGF1dGhEYXRhWydzaGFyZWRfc2VjcmV0J107XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFNlY3JldCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgTm8gc2hhcmVkX3NlY3JldCBrZXkgaW4gYXV0aCBwYXlsb2FkIGZvciBlbmNyeXB0ZWQgY2hhbm5lbDogJHt0aGlzLm5hbWV9YCksIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMua2V5ID0gT2JqZWN0KGJhc2U2NFtcImRlY29kZVwiXSkoc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgICAgIGRlbGV0ZSBhdXRoRGF0YVsnc2hhcmVkX3NlY3JldCddO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYXV0aERhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJpZ2dlcihldmVudCwgZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGZWF0dXJlKCdDbGllbnQgZXZlbnRzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBmb3IgZW5jcnlwdGVkIGNoYW5uZWxzJyk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudC5ldmVudDtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICBpZiAoZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcl9pbnRlcm5hbDonKSA9PT0gMCB8fFxuICAgICAgICAgICAgZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcjonKSA9PT0gMCkge1xuICAgICAgICAgICAgc3VwZXIuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZGxlRW5jcnlwdGVkRXZlbnQoZXZlbnROYW1lLCBkYXRhKTtcbiAgICB9XG4gICAgaGFuZGxlRW5jcnlwdGVkRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdSZWNlaXZlZCBlbmNyeXB0ZWQgZXZlbnQgYmVmb3JlIGtleSBoYXMgYmVlbiByZXRyaWV2ZWQgZnJvbSB0aGUgYXV0aEVuZHBvaW50Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhLmNpcGhlcnRleHQgfHwgIWRhdGEubm9uY2UpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignVW5leHBlY3RlZCBmb3JtYXQgZm9yIGVuY3J5cHRlZCBldmVudCwgZXhwZWN0ZWQgb2JqZWN0IHdpdGggYGNpcGhlcnRleHRgIGFuZCBgbm9uY2VgIGZpZWxkcywgZ290OiAnICtcbiAgICAgICAgICAgICAgICBkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2lwaGVyVGV4dCA9IE9iamVjdChiYXNlNjRbXCJkZWNvZGVcIl0pKGRhdGEuY2lwaGVydGV4dCk7XG4gICAgICAgIGlmIChjaXBoZXJUZXh0Lmxlbmd0aCA8IHRoaXMubmFjbC5zZWNyZXRib3gub3ZlcmhlYWRMZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRXhwZWN0ZWQgZW5jcnlwdGVkIGV2ZW50IGNpcGhlcnRleHQgbGVuZ3RoIHRvIGJlICR7dGhpcy5uYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aH0sIGdvdDogJHtjaXBoZXJUZXh0Lmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9uY2UgPSBPYmplY3QoYmFzZTY0W1wiZGVjb2RlXCJdKShkYXRhLm5vbmNlKTtcbiAgICAgICAgaWYgKG5vbmNlLmxlbmd0aCA8IHRoaXMubmFjbC5zZWNyZXRib3gubm9uY2VMZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRXhwZWN0ZWQgZW5jcnlwdGVkIGV2ZW50IG5vbmNlIGxlbmd0aCB0byBiZSAke3RoaXMubmFjbC5zZWNyZXRib3gubm9uY2VMZW5ndGh9LCBnb3Q6ICR7bm9uY2UubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBieXRlcyA9IHRoaXMubmFjbC5zZWNyZXRib3gub3BlbihjaXBoZXJUZXh0LCBub25jZSwgdGhpcy5rZXkpO1xuICAgICAgICBpZiAoYnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnRmFpbGVkIHRvIGRlY3J5cHQgYW4gZXZlbnQsIHByb2JhYmx5IGJlY2F1c2UgaXQgd2FzIGVuY3J5cHRlZCB3aXRoIGEgZGlmZmVyZW50IGtleS4gRmV0Y2hpbmcgYSBuZXcga2V5IGZyb20gdGhlIGF1dGhFbmRwb2ludC4uLicpO1xuICAgICAgICAgICAgdGhpcy5hdXRob3JpemUodGhpcy5wdXNoZXIuY29ubmVjdGlvbi5zb2NrZXRfaWQsIChlcnJvciwgYXV0aERhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gbWFrZSBhIHJlcXVlc3QgdG8gdGhlIGF1dGhFbmRwb2ludDogJHthdXRoRGF0YX0uIFVuYWJsZSB0byBmZXRjaCBuZXcga2V5LCBzbyBkcm9wcGluZyBlbmNyeXB0ZWQgZXZlbnRgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBieXRlcyA9IHRoaXMubmFjbC5zZWNyZXRib3gub3BlbihjaXBoZXJUZXh0LCBub25jZSwgdGhpcy5rZXkpO1xuICAgICAgICAgICAgICAgIGlmIChieXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBkZWNyeXB0IGV2ZW50IHdpdGggbmV3IGtleS4gRHJvcHBpbmcgZW5jcnlwdGVkIGV2ZW50YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50LCB0aGlzLmdldERhdGFUb0VtaXQoYnl0ZXMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoZXZlbnQsIHRoaXMuZ2V0RGF0YVRvRW1pdChieXRlcykpO1xuICAgIH1cbiAgICBnZXREYXRhVG9FbWl0KGJ5dGVzKSB7XG4gICAgICAgIGxldCByYXcgPSBPYmplY3QodXRmOFtcImRlY29kZVwiXSkoYnl0ZXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmF3KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiByYXc7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29ubmVjdGlvbi9jb25uZWN0aW9uX21hbmFnZXIudHNcblxuXG5cblxuXG5jbGFzcyBjb25uZWN0aW9uX21hbmFnZXJfQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gJ2luaXRpYWxpemVkJztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudGltZWxpbmUgPSB0aGlzLm9wdGlvbnMudGltZWxpbmU7XG4gICAgICAgIHRoaXMudXNpbmdUTFMgPSB0aGlzLm9wdGlvbnMudXNlVExTO1xuICAgICAgICB0aGlzLmVycm9yQ2FsbGJhY2tzID0gdGhpcy5idWlsZEVycm9yQ2FsbGJhY2tzKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcyA9IHRoaXMuYnVpbGRDb25uZWN0aW9uQ2FsbGJhY2tzKHRoaXMuZXJyb3JDYWxsYmFja3MpO1xuICAgICAgICB0aGlzLmhhbmRzaGFrZUNhbGxiYWNrcyA9IHRoaXMuYnVpbGRIYW5kc2hha2VDYWxsYmFja3ModGhpcy5lcnJvckNhbGxiYWNrcyk7XG4gICAgICAgIHZhciBOZXR3b3JrID0gbm9kZV9ydW50aW1lLmdldE5ldHdvcmsoKTtcbiAgICAgICAgTmV0d29yay5iaW5kKCdvbmxpbmUnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lLmluZm8oeyBuZXRpbmZvOiAnb25saW5lJyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnY29ubmVjdGluZycgfHwgdGhpcy5zdGF0ZSA9PT0gJ3VuYXZhaWxhYmxlJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmV0cnlJbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE5ldHdvcmsuYmluZCgnb2ZmbGluZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmUuaW5mbyh7IG5ldGluZm86ICdvZmZsaW5lJyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0cmF0ZWd5KCk7XG4gICAgfVxuICAgIHN3aXRjaENsdXN0ZXIoa2V5KSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnVwZGF0ZVN0cmF0ZWd5KCk7XG4gICAgICAgIHRoaXMucmV0cnlJbigwKTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbiB8fCB0aGlzLnJ1bm5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zdHJhdGVneS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdmYWlsZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdjb25uZWN0aW5nJyk7XG4gICAgICAgIHRoaXMuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgIHRoaXMuc2V0VW5hdmFpbGFibGVUaW1lcigpO1xuICAgIH1cbiAgICBzZW5kKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRfZXZlbnQobmFtZSwgZGF0YSwgY2hhbm5lbCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRfZXZlbnQobmFtZSwgZGF0YSwgY2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0SW50ZXJuYWxseSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICB9XG4gICAgaXNVc2luZ1RMUygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXNpbmdUTFM7XG4gICAgfVxuICAgIHN0YXJ0Q29ubmVjdGluZygpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gKGVycm9yLCBoYW5kc2hha2UpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMucnVubmVyID0gdGhpcy5zdHJhdGVneS5jb25uZWN0KDAsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kc2hha2UuYWN0aW9uID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSGFuZHNoYWtlRXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGhhbmRzaGFrZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lbGluZS5lcnJvcih7IGhhbmRzaGFrZUVycm9yOiBoYW5kc2hha2UuZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFib3J0Q29ubmVjdGluZygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRzaGFrZUNhbGxiYWNrc1toYW5kc2hha2UuYWN0aW9uXShoYW5kc2hha2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5uZXIgPSB0aGlzLnN0cmF0ZWd5LmNvbm5lY3QoMCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBhYm9ydENvbm5lY3RpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bm5lcikge1xuICAgICAgICAgICAgdGhpcy5ydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMucnVubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNjb25uZWN0SW50ZXJuYWxseSgpIHtcbiAgICAgICAgdGhpcy5hYm9ydENvbm5lY3RpbmcoKTtcbiAgICAgICAgdGhpcy5jbGVhclJldHJ5VGltZXIoKTtcbiAgICAgICAgdGhpcy5jbGVhclVuYXZhaWxhYmxlVGltZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLmFiYW5kb25Db25uZWN0aW9uKCk7XG4gICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU3RyYXRlZ3koKSB7XG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSB0aGlzLm9wdGlvbnMuZ2V0U3RyYXRlZ3koe1xuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIHRpbWVsaW5lOiB0aGlzLnRpbWVsaW5lLFxuICAgICAgICAgICAgdXNlVExTOiB0aGlzLnVzaW5nVExTXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXRyeUluKGRlbGF5KSB7XG4gICAgICAgIHRoaXMudGltZWxpbmUuaW5mbyh7IGFjdGlvbjogJ3JldHJ5JywgZGVsYXk6IGRlbGF5IH0pO1xuICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmdfaW4nLCBNYXRoLnJvdW5kKGRlbGF5IC8gMTAwMCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmV0cnlUaW1lciA9IG5ldyB0aW1lcnNfT25lT2ZmVGltZXIoZGVsYXkgfHwgMCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0SW50ZXJuYWxseSgpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbGVhclJldHJ5VGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJldHJ5VGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmV0cnlUaW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFVuYXZhaWxhYmxlVGltZXIoKSB7XG4gICAgICAgIHRoaXMudW5hdmFpbGFibGVUaW1lciA9IG5ldyB0aW1lcnNfT25lT2ZmVGltZXIodGhpcy5vcHRpb25zLnVuYXZhaWxhYmxlVGltZW91dCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgndW5hdmFpbGFibGUnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsZWFyVW5hdmFpbGFibGVUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMudW5hdmFpbGFibGVUaW1lcikge1xuICAgICAgICAgICAgdGhpcy51bmF2YWlsYWJsZVRpbWVyLmVuc3VyZUFib3J0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kQWN0aXZpdHlDaGVjaygpIHtcbiAgICAgICAgdGhpcy5zdG9wQWN0aXZpdHlDaGVjaygpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ucGluZygpO1xuICAgICAgICB0aGlzLmFjdGl2aXR5VGltZXIgPSBuZXcgdGltZXJzX09uZU9mZlRpbWVyKHRoaXMub3B0aW9ucy5wb25nVGltZW91dCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZS5lcnJvcih7IHBvbmdfdGltZWRfb3V0OiB0aGlzLm9wdGlvbnMucG9uZ1RpbWVvdXQgfSk7XG4gICAgICAgICAgICB0aGlzLnJldHJ5SW4oMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNldEFjdGl2aXR5Q2hlY2soKSB7XG4gICAgICAgIHRoaXMuc3RvcEFjdGl2aXR5Q2hlY2soKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbiAmJiAhdGhpcy5jb25uZWN0aW9uLmhhbmRsZXNBY3Rpdml0eUNoZWNrcygpKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2aXR5VGltZXIgPSBuZXcgdGltZXJzX09uZU9mZlRpbWVyKHRoaXMuYWN0aXZpdHlUaW1lb3V0LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kQWN0aXZpdHlDaGVjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcEFjdGl2aXR5Q2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2aXR5VGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZpdHlUaW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGRDb25uZWN0aW9uQ2FsbGJhY2tzKGVycm9yQ2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoe30sIGVycm9yQ2FsbGJhY2tzLCB7XG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QWN0aXZpdHlDaGVjaygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBpbmc6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRfZXZlbnQoJ3B1c2hlcjpwb25nJywge30pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFjdGl2aXR5OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEFjdGl2aXR5Q2hlY2soKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2VkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hYmFuZG9uQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFJldHJ5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeUluKDEwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1aWxkSGFuZHNoYWtlQ2FsbGJhY2tzKGVycm9yQ2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoe30sIGVycm9yQ2FsbGJhY2tzLCB7XG4gICAgICAgICAgICBjb25uZWN0ZWQ6IChoYW5kc2hha2UpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2aXR5VGltZW91dCA9IE1hdGgubWluKHRoaXMub3B0aW9ucy5hY3Rpdml0eVRpbWVvdXQsIGhhbmRzaGFrZS5hY3Rpdml0eVRpbWVvdXQsIGhhbmRzaGFrZS5jb25uZWN0aW9uLmFjdGl2aXR5VGltZW91dCB8fCBJbmZpbml0eSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclVuYXZhaWxhYmxlVGltZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvbm5lY3Rpb24oaGFuZHNoYWtlLmNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0X2lkID0gdGhpcy5jb25uZWN0aW9uLmlkO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoJ2Nvbm5lY3RlZCcsIHsgc29ja2V0X2lkOiB0aGlzLnNvY2tldF9pZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1aWxkRXJyb3JDYWxsYmFja3MoKSB7XG4gICAgICAgIGxldCB3aXRoRXJyb3JFbWl0dGVkID0gY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB7IHR5cGU6ICdXZWJTb2NrZXRFcnJvcicsIGVycm9yOiByZXN1bHQuZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGxzX29ubHk6IHdpdGhFcnJvckVtaXR0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXNpbmdUTFMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RyYXRlZ3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHJ5SW4oMCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJlZnVzZWQ6IHdpdGhFcnJvckVtaXR0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBiYWNrb2ZmOiB3aXRoRXJyb3JFbWl0dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHJ5SW4oMTAwMCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJldHJ5OiB3aXRoRXJyb3JFbWl0dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHJ5SW4oMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXRDb25uZWN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgZm9yICh2YXIgZXZlbnQgaW4gdGhpcy5jb25uZWN0aW9uQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uYmluZChldmVudCwgdGhpcy5jb25uZWN0aW9uQ2FsbGJhY2tzW2V2ZW50XSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldEFjdGl2aXR5Q2hlY2soKTtcbiAgICB9XG4gICAgYWJhbmRvbkNvbm5lY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9wQWN0aXZpdHlDaGVjaygpO1xuICAgICAgICBmb3IgKHZhciBldmVudCBpbiB0aGlzLmNvbm5lY3Rpb25DYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi51bmJpbmQoZXZlbnQsIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrc1tldmVudF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9XG4gICAgdXBkYXRlU3RhdGUobmV3U3RhdGUsIGRhdGEpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSBuZXdTdGF0ZSkge1xuICAgICAgICAgICAgdmFyIG5ld1N0YXRlRGVzY3JpcHRpb24gPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZURlc2NyaXB0aW9uID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlRGVzY3JpcHRpb24gKz0gJyB3aXRoIG5ldyBzb2NrZXQgSUQgJyArIGRhdGEuc29ja2V0X2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdTdGF0ZSBjaGFuZ2VkJywgcHJldmlvdXNTdGF0ZSArICcgLT4gJyArIG5ld1N0YXRlRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHsgc3RhdGU6IG5ld1N0YXRlLCBwYXJhbXM6IGRhdGEgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3N0YXRlX2NoYW5nZScsIHsgcHJldmlvdXM6IHByZXZpb3VzU3RhdGUsIGN1cnJlbnQ6IG5ld1N0YXRlIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KG5ld1N0YXRlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG91bGRSZXRyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09ICdjb25uZWN0aW5nJyB8fCB0aGlzLnN0YXRlID09PSAnY29ubmVjdGVkJztcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY2hhbm5lbHMvY2hhbm5lbHMudHNcblxuXG5cblxuY2xhc3MgY2hhbm5lbHNfQ2hhbm5lbHMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0ge307XG4gICAgfVxuICAgIGFkZChuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoYW5uZWxzW25hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzW25hbWVdID0gY3JlYXRlQ2hhbm5lbChuYW1lLCBwdXNoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW25hbWVdO1xuICAgIH1cbiAgICBhbGwoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXModGhpcy5jaGFubmVscyk7XG4gICAgfVxuICAgIGZpbmQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc1tuYW1lXTtcbiAgICB9XG4gICAgcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW25hbWVdO1xuICAgICAgICBkZWxldGUgdGhpcy5jaGFubmVsc1tuYW1lXTtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIG9iamVjdEFwcGx5KHRoaXMuY2hhbm5lbHMsIGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgICAgICBjaGFubmVsLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2hhbm5lbChuYW1lLCBwdXNoZXIpIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCdwcml2YXRlLWVuY3J5cHRlZC0nKSA9PT0gMCkge1xuICAgICAgICBpZiAocHVzaGVyLmNvbmZpZy5uYWNsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVFbmNyeXB0ZWRDaGFubmVsKG5hbWUsIHB1c2hlciwgcHVzaGVyLmNvbmZpZy5uYWNsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXJyTXNnID0gJ1RyaWVkIHRvIHN1YnNjcmliZSB0byBhIHByaXZhdGUtZW5jcnlwdGVkLSBjaGFubmVsIGJ1dCBubyBuYWNsIGltcGxlbWVudGF0aW9uIGF2YWlsYWJsZSc7XG4gICAgICAgIGxldCBzdWZmaXggPSB1cmxfc3RvcmUuYnVpbGRMb2dTdWZmaXgoJ2VuY3J5cHRlZENoYW5uZWxTdXBwb3J0Jyk7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZlYXR1cmUoYCR7ZXJyTXNnfS4gJHtzdWZmaXh9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUuaW5kZXhPZigncHJpdmF0ZS0nKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVQcml2YXRlQ2hhbm5lbChuYW1lLCBwdXNoZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ3ByZXNlbmNlLScpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZVByZXNlbmNlQ2hhbm5lbChuYW1lLCBwdXNoZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJyMnKSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgQmFkQ2hhbm5lbE5hbWUoJ0Nhbm5vdCBjcmVhdGUgYSBjaGFubmVsIHdpdGggbmFtZSBcIicgKyBuYW1lICsgJ1wiLicpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlQ2hhbm5lbChuYW1lLCBwdXNoZXIpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy9mYWN0b3J5LnRzXG5cblxuXG5cblxuXG5cblxuXG52YXIgRmFjdG9yeSA9IHtcbiAgICBjcmVhdGVDaGFubmVscygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjaGFubmVsc19DaGFubmVscygpO1xuICAgIH0sXG4gICAgY3JlYXRlQ29ubmVjdGlvbk1hbmFnZXIoa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29ubmVjdGlvbl9tYW5hZ2VyX0Nvbm5lY3Rpb25NYW5hZ2VyKGtleSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBjcmVhdGVDaGFubmVsKG5hbWUsIHB1c2hlcikge1xuICAgICAgICByZXR1cm4gbmV3IGNoYW5uZWxfQ2hhbm5lbChuYW1lLCBwdXNoZXIpO1xuICAgIH0sXG4gICAgY3JlYXRlUHJpdmF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgcHJpdmF0ZV9jaGFubmVsX1ByaXZhdGVDaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgfSxcbiAgICBjcmVhdGVQcmVzZW5jZUNoYW5uZWwobmFtZSwgcHVzaGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgcHJlc2VuY2VfY2hhbm5lbF9QcmVzZW5jZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9LFxuICAgIGNyZWF0ZUVuY3J5cHRlZENoYW5uZWwobmFtZSwgcHVzaGVyLCBuYWNsKSB7XG4gICAgICAgIHJldHVybiBuZXcgZW5jcnlwdGVkX2NoYW5uZWxfRW5jcnlwdGVkQ2hhbm5lbChuYW1lLCBwdXNoZXIsIG5hY2wpO1xuICAgIH0sXG4gICAgY3JlYXRlVGltZWxpbmVTZW5kZXIodGltZWxpbmUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aW1lbGluZV9zZW5kZXJfVGltZWxpbmVTZW5kZXIodGltZWxpbmUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgY3JlYXRlSGFuZHNoYWtlKHRyYW5zcG9ydCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBoYW5kc2hha2VfSGFuZHNoYWtlKHRyYW5zcG9ydCwgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgY3JlYXRlQXNzaXN0YW50VG9UaGVUcmFuc3BvcnRNYW5hZ2VyKG1hbmFnZXIsIHRyYW5zcG9ydCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IGFzc2lzdGFudF90b190aGVfdHJhbnNwb3J0X21hbmFnZXJfQXNzaXN0YW50VG9UaGVUcmFuc3BvcnRNYW5hZ2VyKG1hbmFnZXIsIHRyYW5zcG9ydCwgb3B0aW9ucyk7XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGZhY3RvcnkgPSAoRmFjdG9yeSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy90cmFuc3BvcnRfbWFuYWdlci50c1xuXG5jbGFzcyB0cmFuc3BvcnRfbWFuYWdlcl9UcmFuc3BvcnRNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMubGl2ZXNMZWZ0ID0gdGhpcy5vcHRpb25zLmxpdmVzIHx8IEluZmluaXR5O1xuICAgIH1cbiAgICBnZXRBc3Npc3RhbnQodHJhbnNwb3J0KSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZUFzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlcih0aGlzLCB0cmFuc3BvcnQsIHtcbiAgICAgICAgICAgIG1pblBpbmdEZWxheTogdGhpcy5vcHRpb25zLm1pblBpbmdEZWxheSxcbiAgICAgICAgICAgIG1heFBpbmdEZWxheTogdGhpcy5vcHRpb25zLm1heFBpbmdEZWxheVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNBbGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGl2ZXNMZWZ0ID4gMDtcbiAgICB9XG4gICAgcmVwb3J0RGVhdGgoKSB7XG4gICAgICAgIHRoaXMubGl2ZXNMZWZ0IC09IDE7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvc2VxdWVudGlhbF9zdHJhdGVneS50c1xuXG5cblxuY2xhc3Mgc2VxdWVudGlhbF9zdHJhdGVneV9TZXF1ZW50aWFsU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKHN0cmF0ZWdpZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdHJhdGVnaWVzID0gc3RyYXRlZ2llcztcbiAgICAgICAgdGhpcy5sb29wID0gQm9vbGVhbihvcHRpb25zLmxvb3ApO1xuICAgICAgICB0aGlzLmZhaWxGYXN0ID0gQm9vbGVhbihvcHRpb25zLmZhaWxGYXN0KTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgICAgICB0aGlzLnRpbWVvdXRMaW1pdCA9IG9wdGlvbnMudGltZW91dExpbWl0O1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIGFueSh0aGlzLnN0cmF0ZWdpZXMsIHV0aWwubWV0aG9kKCdpc1N1cHBvcnRlZCcpKTtcbiAgICB9XG4gICAgY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHN0cmF0ZWdpZXMgPSB0aGlzLnN0cmF0ZWdpZXM7XG4gICAgICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICAgICAgdmFyIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIHZhciBydW5uZXIgPSBudWxsO1xuICAgICAgICB2YXIgdHJ5TmV4dFN0cmF0ZWd5ID0gKGVycm9yLCBoYW5kc2hha2UpID0+IHtcbiAgICAgICAgICAgIGlmIChoYW5kc2hha2UpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBoYW5kc2hha2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQgKyAxO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQgJSBzdHJhdGVnaWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPCBzdHJhdGVnaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHRpbWVvdXQgKiAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGltZW91dExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IE1hdGgubWluKHRpbWVvdXQsIHRoaXMudGltZW91dExpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBydW5uZXIgPSB0aGlzLnRyeVN0cmF0ZWd5KHN0cmF0ZWdpZXNbY3VycmVudF0sIG1pblByaW9yaXR5LCB7IHRpbWVvdXQsIGZhaWxGYXN0OiB0aGlzLmZhaWxGYXN0IH0sIHRyeU5leHRTdHJhdGVneSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJ1bm5lciA9IHRoaXMudHJ5U3RyYXRlZ3koc3RyYXRlZ2llc1tjdXJyZW50XSwgbWluUHJpb3JpdHksIHsgdGltZW91dDogdGltZW91dCwgZmFpbEZhc3Q6IHRoaXMuZmFpbEZhc3QgfSwgdHJ5TmV4dFN0cmF0ZWd5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yY2VNaW5Qcmlvcml0eTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBtaW5Qcmlvcml0eSA9IHA7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5lcikge1xuICAgICAgICAgICAgICAgICAgICBydW5uZXIuZm9yY2VNaW5Qcmlvcml0eShwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyeVN0cmF0ZWd5KHN0cmF0ZWd5LCBtaW5Qcmlvcml0eSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHRpbWVyID0gbnVsbDtcbiAgICAgICAgdmFyIHJ1bm5lciA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB0aW1lciA9IG5ldyB0aW1lcnNfT25lT2ZmVGltZXIob3B0aW9ucy50aW1lb3V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBydW5uZXIgPSBzdHJhdGVneS5jb25uZWN0KG1pblByaW9yaXR5LCBmdW5jdGlvbiAoZXJyb3IsIGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIHRpbWVyICYmIHRpbWVyLmlzUnVubmluZygpICYmICFvcHRpb25zLmZhaWxGYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIGhhbmRzaGFrZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5mb3JjZU1pblByaW9yaXR5KHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL2Jlc3RfY29ubmVjdGVkX2V2ZXJfc3RyYXRlZ3kudHNcblxuXG5jbGFzcyBiZXN0X2Nvbm5lY3RlZF9ldmVyX3N0cmF0ZWd5X0Jlc3RDb25uZWN0ZWRFdmVyU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKHN0cmF0ZWdpZXMpIHtcbiAgICAgICAgdGhpcy5zdHJhdGVnaWVzID0gc3RyYXRlZ2llcztcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiBhbnkodGhpcy5zdHJhdGVnaWVzLCB1dGlsLm1ldGhvZCgnaXNTdXBwb3J0ZWQnKSk7XG4gICAgfVxuICAgIGNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0KHRoaXMuc3RyYXRlZ2llcywgbWluUHJpb3JpdHksIGZ1bmN0aW9uIChpLCBydW5uZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVycm9yLCBoYW5kc2hha2UpIHtcbiAgICAgICAgICAgICAgICBydW5uZXJzW2ldLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxSdW5uZXJzRmFpbGVkKHJ1bm5lcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFwcGx5KHJ1bm5lcnMsIGZ1bmN0aW9uIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkoaGFuZHNoYWtlLnRyYW5zcG9ydC5wcmlvcml0eSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgaGFuZHNoYWtlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbm5lY3Qoc3RyYXRlZ2llcywgbWluUHJpb3JpdHksIGNhbGxiYWNrQnVpbGRlcikge1xuICAgIHZhciBydW5uZXJzID0gbWFwKHN0cmF0ZWdpZXMsIGZ1bmN0aW9uIChzdHJhdGVneSwgaSwgXywgcnMpIHtcbiAgICAgICAgcmV0dXJuIHN0cmF0ZWd5LmNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrQnVpbGRlcihpLCBycykpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhcHBseShydW5uZXJzLCBhYm9ydFJ1bm5lcik7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICBhcHBseShydW5uZXJzLCBmdW5jdGlvbiAocnVubmVyKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkocCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBhbGxSdW5uZXJzRmFpbGVkKHJ1bm5lcnMpIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbnNfYWxsKHJ1bm5lcnMsIGZ1bmN0aW9uIChydW5uZXIpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocnVubmVyLmVycm9yKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFib3J0UnVubmVyKHJ1bm5lcikge1xuICAgIGlmICghcnVubmVyLmVycm9yICYmICFydW5uZXIuYWJvcnRlZCkge1xuICAgICAgICBydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgcnVubmVyLmFib3J0ZWQgPSB0cnVlO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL3dlYnNvY2tldF9wcmlvcml0aXplZF9jYWNoZWRfc3RyYXRlZ3kudHNcblxuXG5cblxuY2xhc3Mgd2Vic29ja2V0X3ByaW9yaXRpemVkX2NhY2hlZF9zdHJhdGVneV9XZWJTb2NrZXRQcmlvcml0aXplZENhY2hlZFN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJhdGVneSwgdHJhbnNwb3J0cywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0cyA9IHRyYW5zcG9ydHM7XG4gICAgICAgIHRoaXMudHRsID0gb3B0aW9ucy50dGwgfHwgMTgwMCAqIDEwMDA7XG4gICAgICAgIHRoaXMudXNpbmdUTFMgPSBvcHRpb25zLnVzZVRMUztcbiAgICAgICAgdGhpcy50aW1lbGluZSA9IG9wdGlvbnMudGltZWxpbmU7XG4gICAgfVxuICAgIGlzU3VwcG9ydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJhdGVneS5pc1N1cHBvcnRlZCgpO1xuICAgIH1cbiAgICBjb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdXNpbmdUTFMgPSB0aGlzLnVzaW5nVExTO1xuICAgICAgICB2YXIgaW5mbyA9IGZldGNoVHJhbnNwb3J0Q2FjaGUodXNpbmdUTFMpO1xuICAgICAgICB2YXIgY2FjaGVTa2lwQ291bnQgPSBpbmZvICYmIGluZm8uY2FjaGVTa2lwQ291bnQgPyBpbmZvLmNhY2hlU2tpcENvdW50IDogMDtcbiAgICAgICAgdmFyIHN0cmF0ZWdpZXMgPSBbdGhpcy5zdHJhdGVneV07XG4gICAgICAgIGlmIChpbmZvICYmIGluZm8udGltZXN0YW1wICsgdGhpcy50dGwgPj0gdXRpbC5ub3coKSkge1xuICAgICAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0c1tpbmZvLnRyYW5zcG9ydF07XG4gICAgICAgICAgICBpZiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgaWYgKFsnd3MnLCAnd3NzJ10uaW5jbHVkZXMoaW5mby50cmFuc3BvcnQpIHx8IGNhY2hlU2tpcENvdW50ID4gMykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVsaW5lLmluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0OiBpbmZvLnRyYW5zcG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhdGVuY3k6IGluZm8ubGF0ZW5jeVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RyYXRlZ2llcy5wdXNoKG5ldyBzZXF1ZW50aWFsX3N0cmF0ZWd5X1NlcXVlbnRpYWxTdHJhdGVneShbdHJhbnNwb3J0XSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogaW5mby5sYXRlbmN5ICogMiArIDEwMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsRmFzdDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVNraXBDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnRUaW1lc3RhbXAgPSB1dGlsLm5vdygpO1xuICAgICAgICB2YXIgcnVubmVyID0gc3RyYXRlZ2llc1xuICAgICAgICAgICAgLnBvcCgpXG4gICAgICAgICAgICAuY29ubmVjdChtaW5Qcmlvcml0eSwgZnVuY3Rpb24gY2IoZXJyb3IsIGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmF0ZWdpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcCA9IHV0aWwubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lciA9IHN0cmF0ZWdpZXMucG9wKCkuY29ubmVjdChtaW5Qcmlvcml0eSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3JlVHJhbnNwb3J0Q2FjaGUodXNpbmdUTFMsIGhhbmRzaGFrZS50cmFuc3BvcnQubmFtZSwgdXRpbC5ub3coKSAtIHN0YXJ0VGltZXN0YW1wLCBjYWNoZVNraXBDb3VudCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgaGFuZHNoYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgbWluUHJpb3JpdHkgPSBwO1xuICAgICAgICAgICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFRyYW5zcG9ydENhY2hlS2V5KHVzaW5nVExTKSB7XG4gICAgcmV0dXJuICdwdXNoZXJUcmFuc3BvcnQnICsgKHVzaW5nVExTID8gJ1RMUycgOiAnTm9uVExTJyk7XG59XG5mdW5jdGlvbiBmZXRjaFRyYW5zcG9ydENhY2hlKHVzaW5nVExTKSB7XG4gICAgdmFyIHN0b3JhZ2UgPSBub2RlX3J1bnRpbWUuZ2V0TG9jYWxTdG9yYWdlKCk7XG4gICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVkQ2FjaGUgPSBzdG9yYWdlW2dldFRyYW5zcG9ydENhY2hlS2V5KHVzaW5nVExTKV07XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZENhY2hlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc2VyaWFsaXplZENhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZmx1c2hUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzdG9yZVRyYW5zcG9ydENhY2hlKHVzaW5nVExTLCB0cmFuc3BvcnQsIGxhdGVuY3ksIGNhY2hlU2tpcENvdW50KSB7XG4gICAgdmFyIHN0b3JhZ2UgPSBub2RlX3J1bnRpbWUuZ2V0TG9jYWxTdG9yYWdlKCk7XG4gICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0b3JhZ2VbZ2V0VHJhbnNwb3J0Q2FjaGVLZXkodXNpbmdUTFMpXSA9IHNhZmVKU09OU3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHV0aWwubm93KCksXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0OiB0cmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgbGF0ZW5jeTogbGF0ZW5jeSxcbiAgICAgICAgICAgICAgICBjYWNoZVNraXBDb3VudDogY2FjaGVTa2lwQ291bnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmbHVzaFRyYW5zcG9ydENhY2hlKHVzaW5nVExTKSB7XG4gICAgdmFyIHN0b3JhZ2UgPSBub2RlX3J1bnRpbWUuZ2V0TG9jYWxTdG9yYWdlKCk7XG4gICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdG9yYWdlW2dldFRyYW5zcG9ydENhY2hlS2V5KHVzaW5nVExTKV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL2RlbGF5ZWRfc3RyYXRlZ3kudHNcblxuY2xhc3MgZGVsYXllZF9zdHJhdGVneV9EZWxheWVkU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKHN0cmF0ZWd5LCB7IGRlbGF5OiBudW1iZXIgfSkge1xuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHsgZGVsYXk6IG51bWJlciB9O1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyYXRlZ3kuaXNTdXBwb3J0ZWQoKTtcbiAgICB9XG4gICAgY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHN0cmF0ZWd5ID0gdGhpcy5zdHJhdGVneTtcbiAgICAgICAgdmFyIHJ1bm5lcjtcbiAgICAgICAgdmFyIHRpbWVyID0gbmV3IHRpbWVyc19PbmVPZmZUaW1lcih0aGlzLm9wdGlvbnMuZGVsYXksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJ1bm5lciA9IHN0cmF0ZWd5LmNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRpbWVyLmVuc3VyZUFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICBpZiAocnVubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIG1pblByaW9yaXR5ID0gcDtcbiAgICAgICAgICAgICAgICBpZiAocnVubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lci5mb3JjZU1pblByaW9yaXR5KHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy9pZl9zdHJhdGVneS50c1xuY2xhc3MgSWZTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IodGVzdCwgdHJ1ZUJyYW5jaCwgZmFsc2VCcmFuY2gpIHtcbiAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICAgICAgdGhpcy50cnVlQnJhbmNoID0gdHJ1ZUJyYW5jaDtcbiAgICAgICAgdGhpcy5mYWxzZUJyYW5jaCA9IGZhbHNlQnJhbmNoO1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgdmFyIGJyYW5jaCA9IHRoaXMudGVzdCgpID8gdGhpcy50cnVlQnJhbmNoIDogdGhpcy5mYWxzZUJyYW5jaDtcbiAgICAgICAgcmV0dXJuIGJyYW5jaC5pc1N1cHBvcnRlZCgpO1xuICAgIH1cbiAgICBjb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgYnJhbmNoID0gdGhpcy50ZXN0KCkgPyB0aGlzLnRydWVCcmFuY2ggOiB0aGlzLmZhbHNlQnJhbmNoO1xuICAgICAgICByZXR1cm4gYnJhbmNoLmNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy9maXJzdF9jb25uZWN0ZWRfc3RyYXRlZ3kudHNcbmNsYXNzIEZpcnN0Q29ubmVjdGVkU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKHN0cmF0ZWd5KSB7XG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmF0ZWd5LmlzU3VwcG9ydGVkKCk7XG4gICAgfVxuICAgIGNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBydW5uZXIgPSB0aGlzLnN0cmF0ZWd5LmNvbm5lY3QobWluUHJpb3JpdHksIGZ1bmN0aW9uIChlcnJvciwgaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICBpZiAoaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgaGFuZHNoYWtlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL2RlZmF1bHRfc3RyYXRlZ3kudHNcblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiB0ZXN0U3VwcG9ydHNTdHJhdGVneShzdHJhdGVneSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzdHJhdGVneS5pc1N1cHBvcnRlZCgpO1xuICAgIH07XG59XG52YXIgZ2V0RGVmYXVsdFN0cmF0ZWd5ID0gZnVuY3Rpb24gKGNvbmZpZywgYmFzZU9wdGlvbnMsIGRlZmluZVRyYW5zcG9ydCkge1xuICAgIHZhciBkZWZpbmVkVHJhbnNwb3J0cyA9IHt9O1xuICAgIGZ1bmN0aW9uIGRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5KG5hbWUsIHR5cGUsIHByaW9yaXR5LCBvcHRpb25zLCBtYW5hZ2VyKSB7XG4gICAgICAgIHZhciB0cmFuc3BvcnQgPSBkZWZpbmVUcmFuc3BvcnQoY29uZmlnLCBuYW1lLCB0eXBlLCBwcmlvcml0eSwgb3B0aW9ucywgbWFuYWdlcik7XG4gICAgICAgIGRlZmluZWRUcmFuc3BvcnRzW25hbWVdID0gdHJhbnNwb3J0O1xuICAgICAgICByZXR1cm4gdHJhbnNwb3J0O1xuICAgIH1cbiAgICB2YXIgd3Nfb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VPcHRpb25zLCB7XG4gICAgICAgIGhvc3ROb25UTFM6IGNvbmZpZy53c0hvc3QgKyAnOicgKyBjb25maWcud3NQb3J0LFxuICAgICAgICBob3N0VExTOiBjb25maWcud3NIb3N0ICsgJzonICsgY29uZmlnLndzc1BvcnQsXG4gICAgICAgIGh0dHBQYXRoOiBjb25maWcud3NQYXRoXG4gICAgfSk7XG4gICAgdmFyIHdzc19vcHRpb25zID0gZXh0ZW5kKHt9LCB3c19vcHRpb25zLCB7XG4gICAgICAgIHVzZVRMUzogdHJ1ZVxuICAgIH0pO1xuICAgIHZhciBodHRwX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlT3B0aW9ucywge1xuICAgICAgICBob3N0Tm9uVExTOiBjb25maWcuaHR0cEhvc3QgKyAnOicgKyBjb25maWcuaHR0cFBvcnQsXG4gICAgICAgIGhvc3RUTFM6IGNvbmZpZy5odHRwSG9zdCArICc6JyArIGNvbmZpZy5odHRwc1BvcnQsXG4gICAgICAgIGh0dHBQYXRoOiBjb25maWcuaHR0cFBhdGhcbiAgICB9KTtcbiAgICB2YXIgdGltZW91dHMgPSB7XG4gICAgICAgIGxvb3A6IHRydWUsXG4gICAgICAgIHRpbWVvdXQ6IDE1MDAwLFxuICAgICAgICB0aW1lb3V0TGltaXQ6IDYwMDAwXG4gICAgfTtcbiAgICB2YXIgd3NfbWFuYWdlciA9IG5ldyB0cmFuc3BvcnRfbWFuYWdlcl9UcmFuc3BvcnRNYW5hZ2VyKHtcbiAgICAgICAgbWluUGluZ0RlbGF5OiAxMDAwMCxcbiAgICAgICAgbWF4UGluZ0RlbGF5OiBjb25maWcuYWN0aXZpdHlUaW1lb3V0XG4gICAgfSk7XG4gICAgdmFyIHN0cmVhbWluZ19tYW5hZ2VyID0gbmV3IHRyYW5zcG9ydF9tYW5hZ2VyX1RyYW5zcG9ydE1hbmFnZXIoe1xuICAgICAgICBsaXZlczogMixcbiAgICAgICAgbWluUGluZ0RlbGF5OiAxMDAwMCxcbiAgICAgICAgbWF4UGluZ0RlbGF5OiBjb25maWcuYWN0aXZpdHlUaW1lb3V0XG4gICAgfSk7XG4gICAgdmFyIHdzX3RyYW5zcG9ydCA9IGRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5KCd3cycsICd3cycsIDMsIHdzX29wdGlvbnMsIHdzX21hbmFnZXIpO1xuICAgIHZhciB3c3NfdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3koJ3dzcycsICd3cycsIDMsIHdzc19vcHRpb25zLCB3c19tYW5hZ2VyKTtcbiAgICB2YXIgeGhyX3N0cmVhbWluZ190cmFuc3BvcnQgPSBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneSgneGhyX3N0cmVhbWluZycsICd4aHJfc3RyZWFtaW5nJywgMSwgaHR0cF9vcHRpb25zLCBzdHJlYW1pbmdfbWFuYWdlcik7XG4gICAgdmFyIHhocl9wb2xsaW5nX3RyYW5zcG9ydCA9IGRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5KCd4aHJfcG9sbGluZycsICd4aHJfcG9sbGluZycsIDEsIGh0dHBfb3B0aW9ucyk7XG4gICAgdmFyIHdzX2xvb3AgPSBuZXcgc2VxdWVudGlhbF9zdHJhdGVneV9TZXF1ZW50aWFsU3RyYXRlZ3koW3dzX3RyYW5zcG9ydF0sIHRpbWVvdXRzKTtcbiAgICB2YXIgd3NzX2xvb3AgPSBuZXcgc2VxdWVudGlhbF9zdHJhdGVneV9TZXF1ZW50aWFsU3RyYXRlZ3koW3dzc190cmFuc3BvcnRdLCB0aW1lb3V0cyk7XG4gICAgdmFyIHN0cmVhbWluZ19sb29wID0gbmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5KFt4aHJfc3RyZWFtaW5nX3RyYW5zcG9ydF0sIHRpbWVvdXRzKTtcbiAgICB2YXIgcG9sbGluZ19sb29wID0gbmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5KFt4aHJfcG9sbGluZ190cmFuc3BvcnRdLCB0aW1lb3V0cyk7XG4gICAgdmFyIGh0dHBfbG9vcCA9IG5ldyBzZXF1ZW50aWFsX3N0cmF0ZWd5X1NlcXVlbnRpYWxTdHJhdGVneShbXG4gICAgICAgIG5ldyBJZlN0cmF0ZWd5KHRlc3RTdXBwb3J0c1N0cmF0ZWd5KHN0cmVhbWluZ19sb29wKSwgbmV3IGJlc3RfY29ubmVjdGVkX2V2ZXJfc3RyYXRlZ3lfQmVzdENvbm5lY3RlZEV2ZXJTdHJhdGVneShbXG4gICAgICAgICAgICBzdHJlYW1pbmdfbG9vcCxcbiAgICAgICAgICAgIG5ldyBkZWxheWVkX3N0cmF0ZWd5X0RlbGF5ZWRTdHJhdGVneShwb2xsaW5nX2xvb3AsIHsgZGVsYXk6IDQwMDAgfSlcbiAgICAgICAgXSksIHBvbGxpbmdfbG9vcClcbiAgICBdLCB0aW1lb3V0cyk7XG4gICAgdmFyIHdzU3RyYXRlZ3k7XG4gICAgaWYgKGJhc2VPcHRpb25zLnVzZVRMUykge1xuICAgICAgICB3c1N0cmF0ZWd5ID0gbmV3IGJlc3RfY29ubmVjdGVkX2V2ZXJfc3RyYXRlZ3lfQmVzdENvbm5lY3RlZEV2ZXJTdHJhdGVneShbXG4gICAgICAgICAgICB3c19sb29wLFxuICAgICAgICAgICAgbmV3IGRlbGF5ZWRfc3RyYXRlZ3lfRGVsYXllZFN0cmF0ZWd5KGh0dHBfbG9vcCwgeyBkZWxheTogMjAwMCB9KVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdzU3RyYXRlZ3kgPSBuZXcgYmVzdF9jb25uZWN0ZWRfZXZlcl9zdHJhdGVneV9CZXN0Q29ubmVjdGVkRXZlclN0cmF0ZWd5KFtcbiAgICAgICAgICAgIHdzX2xvb3AsXG4gICAgICAgICAgICBuZXcgZGVsYXllZF9zdHJhdGVneV9EZWxheWVkU3RyYXRlZ3kod3NzX2xvb3AsIHsgZGVsYXk6IDIwMDAgfSksXG4gICAgICAgICAgICBuZXcgZGVsYXllZF9zdHJhdGVneV9EZWxheWVkU3RyYXRlZ3koaHR0cF9sb29wLCB7IGRlbGF5OiA1MDAwIH0pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHdlYnNvY2tldF9wcmlvcml0aXplZF9jYWNoZWRfc3RyYXRlZ3lfV2ViU29ja2V0UHJpb3JpdGl6ZWRDYWNoZWRTdHJhdGVneShuZXcgRmlyc3RDb25uZWN0ZWRTdHJhdGVneShuZXcgSWZTdHJhdGVneSh0ZXN0U3VwcG9ydHNTdHJhdGVneSh3c190cmFuc3BvcnQpLCB3c1N0cmF0ZWd5LCBodHRwX2xvb3ApKSwgZGVmaW5lZFRyYW5zcG9ydHMsIHtcbiAgICAgICAgdHRsOiAxODAwMDAwLFxuICAgICAgICB0aW1lbGluZTogYmFzZU9wdGlvbnMudGltZWxpbmUsXG4gICAgICAgIHVzZVRMUzogYmFzZU9wdGlvbnMudXNlVExTXG4gICAgfSk7XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGVmYXVsdF9zdHJhdGVneSA9IChnZXREZWZhdWx0U3RyYXRlZ3kpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL3RyYW5zcG9ydHMvdHJhbnNwb3J0X2Nvbm5lY3Rpb25faW5pdGlhbGl6ZXIudHNcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcG9ydF9jb25uZWN0aW9uX2luaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi50aW1lbGluZS5pbmZvKHNlbGYuYnVpbGRUaW1lbGluZU1lc3NhZ2Uoe1xuICAgICAgICB0cmFuc3BvcnQ6IHNlbGYubmFtZSArIChzZWxmLm9wdGlvbnMudXNlVExTID8gJ3MnIDogJycpXG4gICAgfSkpO1xuICAgIGlmIChzZWxmLmhvb2tzLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICBzZWxmLmNoYW5nZVN0YXRlKCdpbml0aWFsaXplZCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgfVxufSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvaHR0cC9odHRwX3JlcXVlc3QudHNcblxuXG5jb25zdCBNQVhfQlVGRkVSX0xFTkdUSCA9IDI1NiAqIDEwMjQ7XG5jbGFzcyBodHRwX3JlcXVlc3RfSFRUUFJlcXVlc3QgZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGhvb2tzLCBtZXRob2QsIHVybCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmhvb2tzID0gaG9va3M7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICB9XG4gICAgc3RhcnQocGF5bG9hZCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICAgICAgdGhpcy54aHIgPSB0aGlzLmhvb2tzLmdldFJlcXVlc3QodGhpcyk7XG4gICAgICAgIHRoaXMudW5sb2FkZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIG5vZGVfcnVudGltZS5hZGRVbmxvYWRMaXN0ZW5lcih0aGlzLnVubG9hZGVyKTtcbiAgICAgICAgdGhpcy54aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUpO1xuICAgICAgICBpZiAodGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcikge1xuICAgICAgICAgICAgdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhoci5zZW5kKHBheWxvYWQpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudW5sb2FkZXIpIHtcbiAgICAgICAgICAgIG5vZGVfcnVudGltZS5yZW1vdmVVbmxvYWRMaXN0ZW5lcih0aGlzLnVubG9hZGVyKTtcbiAgICAgICAgICAgIHRoaXMudW5sb2FkZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnhocikge1xuICAgICAgICAgICAgdGhpcy5ob29rcy5hYm9ydFJlcXVlc3QodGhpcy54aHIpO1xuICAgICAgICAgICAgdGhpcy54aHIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQ2h1bmsoc3RhdHVzLCBkYXRhKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgY2h1bmsgPSB0aGlzLmFkdmFuY2VCdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2NodW5rJywgeyBzdGF0dXM6IHN0YXR1cywgZGF0YTogY2h1bmsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0J1ZmZlclRvb0xvbmcoZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnYnVmZmVyX3Rvb19sb25nJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWR2YW5jZUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgdmFyIHVucmVhZERhdGEgPSBidWZmZXIuc2xpY2UodGhpcy5wb3NpdGlvbik7XG4gICAgICAgIHZhciBlbmRPZkxpbmVQb3NpdGlvbiA9IHVucmVhZERhdGEuaW5kZXhPZignXFxuJyk7XG4gICAgICAgIGlmIChlbmRPZkxpbmVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gKz0gZW5kT2ZMaW5lUG9zaXRpb24gKyAxO1xuICAgICAgICAgICAgcmV0dXJuIHVucmVhZERhdGEuc2xpY2UoMCwgZW5kT2ZMaW5lUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNCdWZmZXJUb29Mb25nKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiA9PT0gYnVmZmVyLmxlbmd0aCAmJiBidWZmZXIubGVuZ3RoID4gTUFYX0JVRkZFUl9MRU5HVEg7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2h0dHAvc3RhdGUudHNcbnZhciBTdGF0ZTtcbihmdW5jdGlvbiAoU3RhdGUpIHtcbiAgICBTdGF0ZVtTdGF0ZVtcIkNPTk5FQ1RJTkdcIl0gPSAwXSA9IFwiQ09OTkVDVElOR1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BFTlwiXSA9IDFdID0gXCJPUEVOXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJDTE9TRURcIl0gPSAzXSA9IFwiQ0xPU0VEXCI7XG59KShTdGF0ZSB8fCAoU3RhdGUgPSB7fSkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3RhdGUgPSAoU3RhdGUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2h0dHAvaHR0cF9zb2NrZXQudHNcblxuXG5cbnZhciBhdXRvSW5jcmVtZW50ID0gMTtcbmNsYXNzIGh0dHBfc29ja2V0X0hUVFBTb2NrZXQge1xuICAgIGNvbnN0cnVjdG9yKGhvb2tzLCB1cmwpIHtcbiAgICAgICAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSByYW5kb21OdW1iZXIoMTAwMCkgKyAnLycgKyByYW5kb21TdHJpbmcoOCk7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBnZXRMb2NhdGlvbih1cmwpO1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBzdGF0ZS5DT05ORUNUSU5HO1xuICAgICAgICB0aGlzLm9wZW5TdHJlYW0oKTtcbiAgICB9XG4gICAgc2VuZChwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRSYXcoSlNPTi5zdHJpbmdpZnkoW3BheWxvYWRdKSk7XG4gICAgfVxuICAgIHBpbmcoKSB7XG4gICAgICAgIHRoaXMuaG9va3Muc2VuZEhlYXJ0YmVhdCh0aGlzKTtcbiAgICB9XG4gICAgY2xvc2UoY29kZSwgcmVhc29uKSB7XG4gICAgICAgIHRoaXMub25DbG9zZShjb2RlLCByZWFzb24sIHRydWUpO1xuICAgIH1cbiAgICBzZW5kUmF3KHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gc3RhdGUuT1BFTikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub2RlX3J1bnRpbWUuY3JlYXRlU29ja2V0UmVxdWVzdCgnUE9TVCcsIGdldFVuaXF1ZVVSTChnZXRTZW5kVVJMKHRoaXMubG9jYXRpb24sIHRoaXMuc2Vzc2lvbikpKS5zdGFydChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jbG9zZVN0cmVhbSgpO1xuICAgICAgICB0aGlzLm9wZW5TdHJlYW0oKTtcbiAgICB9XG4gICAgb25DbG9zZShjb2RlLCByZWFzb24sIHdhc0NsZWFuKSB7XG4gICAgICAgIHRoaXMuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gc3RhdGUuQ0xPU0VEO1xuICAgICAgICBpZiAodGhpcy5vbmNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLm9uY2xvc2Uoe1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICAgICAgICAgICAgd2FzQ2xlYW46IHdhc0NsZWFuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkNodW5rKGNodW5rKSB7XG4gICAgICAgIGlmIChjaHVuay5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHN0YXRlLk9QRU4pIHtcbiAgICAgICAgICAgIHRoaXMub25BY3Rpdml0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXlsb2FkO1xuICAgICAgICB2YXIgdHlwZSA9IGNodW5rLmRhdGEuc2xpY2UoMCwgMSk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbyc6XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoY2h1bmsuZGF0YS5zbGljZSgxKSB8fCAne30nKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uT3BlbihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGNodW5rLmRhdGEuc2xpY2UoMSkgfHwgJ1tdJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXlsb2FkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FdmVudChwYXlsb2FkW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShjaHVuay5kYXRhLnNsaWNlKDEpIHx8ICdudWxsJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkV2ZW50KHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgdGhpcy5ob29rcy5vbkhlYXJ0YmVhdCh0aGlzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGNodW5rLmRhdGEuc2xpY2UoMSkgfHwgJ1tdJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKHBheWxvYWRbMF0sIHBheWxvYWRbMV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uT3BlbihvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHN0YXRlLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uLmJhc2UgPSByZXBsYWNlSG9zdCh0aGlzLmxvY2F0aW9uLmJhc2UsIG9wdGlvbnMuaG9zdG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gc3RhdGUuT1BFTjtcbiAgICAgICAgICAgIGlmICh0aGlzLm9ub3Blbikge1xuICAgICAgICAgICAgICAgIHRoaXMub25vcGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoMTAwNiwgJ1NlcnZlciBsb3N0IHNlc3Npb24nLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHN0YXRlLk9QRU4gJiYgdGhpcy5vbm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25tZXNzYWdlKHsgZGF0YTogZXZlbnQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25BY3Rpdml0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMub25hY3Rpdml0eSkge1xuICAgICAgICAgICAgdGhpcy5vbmFjdGl2aXR5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25FcnJvcihlcnJvcikge1xuICAgICAgICBpZiAodGhpcy5vbmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9wZW5TdHJlYW0oKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbm9kZV9ydW50aW1lLmNyZWF0ZVNvY2tldFJlcXVlc3QoJ1BPU1QnLCBnZXRVbmlxdWVVUkwodGhpcy5ob29rcy5nZXRSZWNlaXZlVVJMKHRoaXMubG9jYXRpb24sIHRoaXMuc2Vzc2lvbikpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYmluZCgnY2h1bmsnLCBjaHVuayA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQ2h1bmsoY2h1bmspO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYmluZCgnZmluaXNoZWQnLCBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgdGhpcy5ob29rcy5vbkZpbmlzaGVkKHRoaXMsIHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5iaW5kKCdidWZmZXJfdG9vX2xvbmcnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB1dGlsLmRlZmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZSgxMDA2LCAnQ291bGQgbm90IHN0YXJ0IHN0cmVhbWluZycsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlU3RyZWFtKCkge1xuICAgICAgICBpZiAodGhpcy5zdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnVuYmluZF9hbGwoKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRMb2NhdGlvbih1cmwpIHtcbiAgICB2YXIgcGFydHMgPSAvKFteXFw/XSopXFwvKihcXD8/LiopLy5leGVjKHVybCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZTogcGFydHNbMV0sXG4gICAgICAgIHF1ZXJ5U3RyaW5nOiBwYXJ0c1syXVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRTZW5kVVJMKHVybCwgc2Vzc2lvbikge1xuICAgIHJldHVybiB1cmwuYmFzZSArICcvJyArIHNlc3Npb24gKyAnL3hocl9zZW5kJztcbn1cbmZ1bmN0aW9uIGdldFVuaXF1ZVVSTCh1cmwpIHtcbiAgICB2YXIgc2VwYXJhdG9yID0gdXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJic7XG4gICAgcmV0dXJuIHVybCArIHNlcGFyYXRvciArICd0PScgKyArbmV3IERhdGUoKSArICcmbj0nICsgYXV0b0luY3JlbWVudCsrO1xufVxuZnVuY3Rpb24gcmVwbGFjZUhvc3QodXJsLCBob3N0bmFtZSkge1xuICAgIHZhciB1cmxQYXJ0cyA9IC8oaHR0cHM/OlxcL1xcLykoW15cXC86XSspKChcXC98Oik/LiopLy5leGVjKHVybCk7XG4gICAgcmV0dXJuIHVybFBhcnRzWzFdICsgaG9zdG5hbWUgKyB1cmxQYXJ0c1szXTtcbn1cbmZ1bmN0aW9uIHJhbmRvbU51bWJlcihtYXgpIHtcbiAgICByZXR1cm4gbm9kZV9ydW50aW1lLnJhbmRvbUludChtYXgpO1xufVxuZnVuY3Rpb24gcmFuZG9tU3RyaW5nKGxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHJhbmRvbU51bWJlcigzMikudG9TdHJpbmcoMzIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfc29ja2V0ID0gKGh0dHBfc29ja2V0X0hUVFBTb2NrZXQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2h0dHAvaHR0cF9zdHJlYW1pbmdfc29ja2V0LnRzXG52YXIgaHR0cF9zdHJlYW1pbmdfc29ja2V0X2hvb2tzID0ge1xuICAgIGdldFJlY2VpdmVVUkw6IGZ1bmN0aW9uICh1cmwsIHNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHVybC5iYXNlICsgJy8nICsgc2Vzc2lvbiArICcveGhyX3N0cmVhbWluZycgKyB1cmwucXVlcnlTdHJpbmc7XG4gICAgfSxcbiAgICBvbkhlYXJ0YmVhdDogZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICBzb2NrZXQuc2VuZFJhdygnW10nKTtcbiAgICB9LFxuICAgIHNlbmRIZWFydGJlYXQ6IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgICAgc29ja2V0LnNlbmRSYXcoJ1tdJyk7XG4gICAgfSxcbiAgICBvbkZpbmlzaGVkOiBmdW5jdGlvbiAoc29ja2V0LCBzdGF0dXMpIHtcbiAgICAgICAgc29ja2V0Lm9uQ2xvc2UoMTAwNiwgJ0Nvbm5lY3Rpb24gaW50ZXJydXB0ZWQgKCcgKyBzdGF0dXMgKyAnKScsIGZhbHNlKTtcbiAgICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaHR0cF9zdHJlYW1pbmdfc29ja2V0ID0gKGh0dHBfc3RyZWFtaW5nX3NvY2tldF9ob29rcyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvaHR0cC9odHRwX3BvbGxpbmdfc29ja2V0LnRzXG52YXIgaHR0cF9wb2xsaW5nX3NvY2tldF9ob29rcyA9IHtcbiAgICBnZXRSZWNlaXZlVVJMOiBmdW5jdGlvbiAodXJsLCBzZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB1cmwuYmFzZSArICcvJyArIHNlc3Npb24gKyAnL3hocicgKyB1cmwucXVlcnlTdHJpbmc7XG4gICAgfSxcbiAgICBvbkhlYXJ0YmVhdDogZnVuY3Rpb24gKCkge1xuICAgIH0sXG4gICAgc2VuZEhlYXJ0YmVhdDogZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICBzb2NrZXQuc2VuZFJhdygnW10nKTtcbiAgICB9LFxuICAgIG9uRmluaXNoZWQ6IGZ1bmN0aW9uIChzb2NrZXQsIHN0YXR1cykge1xuICAgICAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHNvY2tldC5yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvY2tldC5vbkNsb3NlKDEwMDYsICdDb25uZWN0aW9uIGludGVycnVwdGVkICgnICsgc3RhdHVzICsgJyknLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaHR0cF9wb2xsaW5nX3NvY2tldCA9IChodHRwX3BvbGxpbmdfc29ja2V0X2hvb2tzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvaXNvbW9ycGhpYy9odHRwL2h0dHBfeGhyX3JlcXVlc3QudHNcblxudmFyIGh0dHBfeGhyX3JlcXVlc3RfaG9va3MgPSB7XG4gICAgZ2V0UmVxdWVzdDogZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBub2RlX3J1bnRpbWUuZ2V0WEhSQVBJKCk7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZVRleHQgJiYgeGhyLnJlc3BvbnNlVGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25DaHVuayh4aHIuc3RhdHVzLCB4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVzcG9uc2VUZXh0ICYmIHhoci5yZXNwb25zZVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uQ2h1bmsoeGhyLnN0YXR1cywgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmVtaXQoJ2ZpbmlzaGVkJywgeGhyLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHhocjtcbiAgICB9LFxuICAgIGFib3J0UmVxdWVzdDogZnVuY3Rpb24gKHhocikge1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfeGhyX3JlcXVlc3QgPSAoaHR0cF94aHJfcmVxdWVzdF9ob29rcyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL2lzb21vcnBoaWMvaHR0cC9odHRwLnRzXG5cblxuXG5cblxudmFyIEhUVFAgPSB7XG4gICAgY3JlYXRlU3RyZWFtaW5nU29ja2V0KHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTb2NrZXQoaHR0cF9zdHJlYW1pbmdfc29ja2V0LCB1cmwpO1xuICAgIH0sXG4gICAgY3JlYXRlUG9sbGluZ1NvY2tldCh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU29ja2V0KGh0dHBfcG9sbGluZ19zb2NrZXQsIHVybCk7XG4gICAgfSxcbiAgICBjcmVhdGVTb2NrZXQoaG9va3MsIHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IGh0dHBfc29ja2V0KGhvb2tzLCB1cmwpO1xuICAgIH0sXG4gICAgY3JlYXRlWEhSKG1ldGhvZCwgdXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJlcXVlc3QoaHR0cF94aHJfcmVxdWVzdCwgbWV0aG9kLCB1cmwpO1xuICAgIH0sXG4gICAgY3JlYXRlUmVxdWVzdChob29rcywgbWV0aG9kLCB1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwX3JlcXVlc3RfSFRUUFJlcXVlc3QoaG9va3MsIG1ldGhvZCwgdXJsKTtcbiAgICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaHR0cF9odHRwID0gKEhUVFApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL3J1bnRpbWUudHNcblxuXG5cblxuXG52YXIgSXNvbW9ycGhpYyA9IHtcbiAgICBnZXREZWZhdWx0U3RyYXRlZ3k6IGRlZmF1bHRfc3RyYXRlZ3ksXG4gICAgVHJhbnNwb3J0czogdHJhbnNwb3J0cyxcbiAgICB0cmFuc3BvcnRDb25uZWN0aW9uSW5pdGlhbGl6ZXI6IHRyYW5zcG9ydF9jb25uZWN0aW9uX2luaXRpYWxpemVyLFxuICAgIEhUVFBGYWN0b3J5OiBodHRwX2h0dHAsXG4gICAgc2V0dXAoUHVzaGVyQ2xhc3MpIHtcbiAgICAgICAgUHVzaGVyQ2xhc3MucmVhZHkoKTtcbiAgICB9LFxuICAgIGdldExvY2FsU3RvcmFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGdldENsaWVudEZlYXR1cmVzKCkge1xuICAgICAgICByZXR1cm4ga2V5cyhmaWx0ZXJPYmplY3QoeyB3czogdHJhbnNwb3J0cy53cyB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQuaXNTdXBwb3J0ZWQoe30pO1xuICAgICAgICB9KSk7XG4gICAgfSxcbiAgICBnZXRQcm90b2NvbCgpIHtcbiAgICAgICAgcmV0dXJuICdodHRwOic7XG4gICAgfSxcbiAgICBpc1hIUlN1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBjcmVhdGVTb2NrZXRSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gICAgICAgIGlmICh0aGlzLmlzWEhSU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkhUVFBGYWN0b3J5LmNyZWF0ZVhIUihtZXRob2QsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnQ3Jvc3Mtb3JpZ2luIEhUVFAgcmVxdWVzdHMgYXJlIG5vdCBzdXBwb3J0ZWQnO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVYSFIoKSB7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXMuZ2V0WEhSQVBJKCk7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICB9LFxuICAgIGNyZWF0ZVdlYlNvY2tldCh1cmwpIHtcbiAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcy5nZXRXZWJTb2NrZXRBUEkoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih1cmwpO1xuICAgIH0sXG4gICAgYWRkVW5sb2FkTGlzdGVuZXIobGlzdGVuZXIpIHsgfSxcbiAgICByZW1vdmVVbmxvYWRMaXN0ZW5lcihsaXN0ZW5lcikgeyB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcnVudGltZSA9IChJc29tb3JwaGljKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9mYXllLXdlYnNvY2tldC9saWIvZmF5ZS93ZWJzb2NrZXQuanNcbnZhciB3ZWJzb2NrZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy94bWxodHRwcmVxdWVzdC9saWIvWE1MSHR0cFJlcXVlc3QuanNcbnZhciBYTUxIdHRwUmVxdWVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9ub2RlL25ldF9pbmZvLnRzXG5cbmNsYXNzIG5ldF9pbmZvX05ldEluZm8gZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGlzT25saW5lKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG52YXIgbmV0X2luZm9fTmV0d29yayA9IG5ldyBuZXRfaW5mb19OZXRJbmZvKCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvYXV0aC9vcHRpb25zLnRzXG52YXIgQXV0aFJlcXVlc3RUeXBlO1xuKGZ1bmN0aW9uIChBdXRoUmVxdWVzdFR5cGUpIHtcbiAgICBBdXRoUmVxdWVzdFR5cGVbXCJVc2VyQXV0aGVudGljYXRpb25cIl0gPSBcInVzZXItYXV0aGVudGljYXRpb25cIjtcbiAgICBBdXRoUmVxdWVzdFR5cGVbXCJDaGFubmVsQXV0aG9yaXphdGlvblwiXSA9IFwiY2hhbm5lbC1hdXRob3JpemF0aW9uXCI7XG59KShBdXRoUmVxdWVzdFR5cGUgfHwgKEF1dGhSZXF1ZXN0VHlwZSA9IHt9KSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL2lzb21vcnBoaWMvYXV0aC94aHJfYXV0aC50c1xuXG5cblxuXG5jb25zdCBhamF4ID0gZnVuY3Rpb24gKGNvbnRleHQsIHF1ZXJ5LCBhdXRoT3B0aW9ucywgYXV0aFJlcXVlc3RUeXBlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHhociA9IG5vZGVfcnVudGltZS5jcmVhdGVYSFIoKTtcbiAgICB4aHIub3BlbignUE9TVCcsIGF1dGhPcHRpb25zLmVuZHBvaW50LCB0cnVlKTtcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgIGZvciAodmFyIGhlYWRlck5hbWUgaW4gYXV0aE9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lLCBhdXRoT3B0aW9ucy5oZWFkZXJzW2hlYWRlck5hbWVdKTtcbiAgICB9XG4gICAgaWYgKGF1dGhPcHRpb25zLmhlYWRlcnNQcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgIGxldCBkeW5hbWljSGVhZGVycyA9IGF1dGhPcHRpb25zLmhlYWRlcnNQcm92aWRlcigpO1xuICAgICAgICBmb3IgKHZhciBoZWFkZXJOYW1lIGluIGR5bmFtaWNIZWFkZXJzKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lLCBkeW5hbWljSGVhZGVyc1toZWFkZXJOYW1lXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgSFRUUEF1dGhFcnJvcigyMDAsIGBKU09OIHJldHVybmVkIGZyb20gJHthdXRoUmVxdWVzdFR5cGUudG9TdHJpbmcoKX0gZW5kcG9pbnQgd2FzIGludmFsaWQsIHlldCBzdGF0dXMgY29kZSB3YXMgMjAwLiBEYXRhIHdhczogJHt4aHIucmVzcG9uc2VUZXh0fWApLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc3VmZml4ID0gJyc7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhdXRoUmVxdWVzdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRoUmVxdWVzdFR5cGUuVXNlckF1dGhlbnRpY2F0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gdXJsX3N0b3JlLmJ1aWxkTG9nU3VmZml4KCdhdXRoZW50aWNhdGlvbkVuZHBvaW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRoUmVxdWVzdFR5cGUuQ2hhbm5lbEF1dGhvcml6YXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSBgQ2xpZW50cyBtdXN0IGJlIGF1dGhvcml6ZWQgdG8gam9pbiBwcml2YXRlIG9yIHByZXNlbmNlIGNoYW5uZWxzLiAke3VybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgnYXV0aG9yaXphdGlvbkVuZHBvaW50Jyl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgSFRUUEF1dGhFcnJvcih4aHIuc3RhdHVzLCBgVW5hYmxlIHRvIHJldHJpZXZlIGF1dGggc3RyaW5nIGZyb20gJHthdXRoUmVxdWVzdFR5cGUudG9TdHJpbmcoKX0gZW5kcG9pbnQgLSBgICtcbiAgICAgICAgICAgICAgICAgICAgYHJlY2VpdmVkIHN0YXR1czogJHt4aHIuc3RhdHVzfSBmcm9tICR7YXV0aE9wdGlvbnMuZW5kcG9pbnR9LiAke3N1ZmZpeH1gKSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHhoci5zZW5kKHF1ZXJ5KTtcbiAgICByZXR1cm4geGhyO1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHhocl9hdXRoID0gKGFqYXgpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL3RpbWVsaW5lL3hocl90aW1lbGluZS50c1xuXG5cblxudmFyIGdldEFnZW50ID0gZnVuY3Rpb24gKHNlbmRlciwgdXNlVExTKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2NoZW1lID0gJ2h0dHAnICsgKHVzZVRMUyA/ICdzJyA6ICcnKSArICc6Ly8nO1xuICAgICAgICB2YXIgdXJsID0gc2NoZW1lICsgKHNlbmRlci5ob3N0IHx8IHNlbmRlci5vcHRpb25zLmhvc3QpICsgc2VuZGVyLm9wdGlvbnMucGF0aDtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gYnVpbGRRdWVyeVN0cmluZyhkYXRhKTtcbiAgICAgICAgdXJsICs9ICcvJyArIDIgKyAnPycgKyBxdWVyeTtcbiAgICAgICAgdmFyIHhociA9IG5vZGVfcnVudGltZS5jcmVhdGVYSFIoKTtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBzdGF0dXMsIHJlc3BvbnNlVGV4dCB9ID0geGhyO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFRpbWVsaW5lU2VuZGVyIEVycm9yOiByZWNlaXZlZCAke3N0YXR1c30gZnJvbSBzdGF0cy5wdXNoZXIuY29tYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHsgaG9zdCB9ID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFRpbWVsaW5lU2VuZGVyRXJyb3I6IGludmFsaWQgcmVzcG9uc2UgJHtyZXNwb25zZVRleHR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRlci5ob3N0ID0gaG9zdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5zZW5kKCk7XG4gICAgfTtcbn07XG52YXIgeGhyX3RpbWVsaW5lX3hociA9IHtcbiAgICBuYW1lOiAneGhyJyxcbiAgICBnZXRBZ2VudFxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHhocl90aW1lbGluZSA9ICh4aHJfdGltZWxpbmVfeGhyKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImNyeXB0b1wiXG52YXIgZXh0ZXJuYWxfY3J5cHRvXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL25vZGUvcnVudGltZS50c1xuXG5cblxuXG5cblxuXG5jb25zdCB7IGdldERlZmF1bHRTdHJhdGVneTogcnVudGltZV9nZXREZWZhdWx0U3RyYXRlZ3ksIFRyYW5zcG9ydHM6IHJ1bnRpbWVfVHJhbnNwb3J0cywgc2V0dXAsIGdldFByb3RvY29sLCBpc1hIUlN1cHBvcnRlZCwgZ2V0TG9jYWxTdG9yYWdlLCBjcmVhdGVYSFIsIGNyZWF0ZVdlYlNvY2tldCwgYWRkVW5sb2FkTGlzdGVuZXIsIHJlbW92ZVVubG9hZExpc3RlbmVyLCB0cmFuc3BvcnRDb25uZWN0aW9uSW5pdGlhbGl6ZXIsIGNyZWF0ZVNvY2tldFJlcXVlc3QsIEhUVFBGYWN0b3J5IH0gPSBydW50aW1lO1xuY29uc3QgTm9kZUpTID0ge1xuICAgIGdldERlZmF1bHRTdHJhdGVneTogcnVudGltZV9nZXREZWZhdWx0U3RyYXRlZ3ksXG4gICAgVHJhbnNwb3J0czogcnVudGltZV9UcmFuc3BvcnRzLFxuICAgIHNldHVwLFxuICAgIGdldFByb3RvY29sLFxuICAgIGlzWEhSU3VwcG9ydGVkLFxuICAgIGNyZWF0ZVNvY2tldFJlcXVlc3QsXG4gICAgZ2V0TG9jYWxTdG9yYWdlLFxuICAgIGNyZWF0ZVhIUixcbiAgICBjcmVhdGVXZWJTb2NrZXQsXG4gICAgYWRkVW5sb2FkTGlzdGVuZXIsXG4gICAgcmVtb3ZlVW5sb2FkTGlzdGVuZXIsXG4gICAgdHJhbnNwb3J0Q29ubmVjdGlvbkluaXRpYWxpemVyLFxuICAgIEhUVFBGYWN0b3J5LFxuICAgIFRpbWVsaW5lVHJhbnNwb3J0OiB4aHJfdGltZWxpbmUsXG4gICAgZ2V0QXV0aG9yaXplcnMoKSB7XG4gICAgICAgIHJldHVybiB7IGFqYXg6IHhocl9hdXRoIH07XG4gICAgfSxcbiAgICBnZXRXZWJTb2NrZXRBUEkoKSB7XG4gICAgICAgIHJldHVybiB3ZWJzb2NrZXRbXCJDbGllbnRcIl07XG4gICAgfSxcbiAgICBnZXRYSFJBUEkoKSB7XG4gICAgICAgIHJldHVybiBYTUxIdHRwUmVxdWVzdFtcIlhNTEh0dHBSZXF1ZXN0XCJdO1xuICAgIH0sXG4gICAgZ2V0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldF9pbmZvX05ldHdvcms7XG4gICAgfSxcbiAgICByYW5kb21JbnQobWF4KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QoZXh0ZXJuYWxfY3J5cHRvX1tcInJhbmRvbUludFwiXSkobWF4KTtcbiAgICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbm9kZV9ydW50aW1lID0gKE5vZGVKUyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdGltZWxpbmUvbGV2ZWwudHNcbnZhciBUaW1lbGluZUxldmVsO1xuKGZ1bmN0aW9uIChUaW1lbGluZUxldmVsKSB7XG4gICAgVGltZWxpbmVMZXZlbFtUaW1lbGluZUxldmVsW1wiRVJST1JcIl0gPSAzXSA9IFwiRVJST1JcIjtcbiAgICBUaW1lbGluZUxldmVsW1RpbWVsaW5lTGV2ZWxbXCJJTkZPXCJdID0gNl0gPSBcIklORk9cIjtcbiAgICBUaW1lbGluZUxldmVsW1RpbWVsaW5lTGV2ZWxbXCJERUJVR1wiXSA9IDddID0gXCJERUJVR1wiO1xufSkoVGltZWxpbmVMZXZlbCB8fCAoVGltZWxpbmVMZXZlbCA9IHt9KSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0aW1lbGluZV9sZXZlbCA9IChUaW1lbGluZUxldmVsKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90aW1lbGluZS90aW1lbGluZS50c1xuXG5cblxuY2xhc3MgdGltZWxpbmVfVGltZWxpbmUge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgc2Vzc2lvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5zZW50ID0gMDtcbiAgICAgICAgdGhpcy51bmlxdWVJRCA9IDA7XG4gICAgfVxuICAgIGxvZyhsZXZlbCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKGxldmVsIDw9IHRoaXMub3B0aW9ucy5sZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMucHVzaChleHRlbmQoe30sIGV2ZW50LCB7IHRpbWVzdGFtcDogdXRpbC5ub3coKSB9KSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxpbWl0ICYmIHRoaXMuZXZlbnRzLmxlbmd0aCA+IHRoaXMub3B0aW9ucy5saW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXJyb3IoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5sb2codGltZWxpbmVfbGV2ZWwuRVJST1IsIGV2ZW50KTtcbiAgICB9XG4gICAgaW5mbyhldmVudCkge1xuICAgICAgICB0aGlzLmxvZyh0aW1lbGluZV9sZXZlbC5JTkZPLCBldmVudCk7XG4gICAgfVxuICAgIGRlYnVnKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubG9nKHRpbWVsaW5lX2xldmVsLkRFQlVHLCBldmVudCk7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50cy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIHNlbmQoc2VuZGZuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZGF0YSA9IGV4dGVuZCh7XG4gICAgICAgICAgICBzZXNzaW9uOiB0aGlzLnNlc3Npb24sXG4gICAgICAgICAgICBidW5kbGU6IHRoaXMuc2VudCArIDEsXG4gICAgICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAgbGliOiAnanMnLFxuICAgICAgICAgICAgdmVyc2lvbjogdGhpcy5vcHRpb25zLnZlcnNpb24sXG4gICAgICAgICAgICBjbHVzdGVyOiB0aGlzLm9wdGlvbnMuY2x1c3RlcixcbiAgICAgICAgICAgIGZlYXR1cmVzOiB0aGlzLm9wdGlvbnMuZmVhdHVyZXMsXG4gICAgICAgICAgICB0aW1lbGluZTogdGhpcy5ldmVudHNcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLnBhcmFtcyk7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIHNlbmRmbihkYXRhLCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2VuZXJhdGVVbmlxdWVJRCgpIHtcbiAgICAgICAgdGhpcy51bmlxdWVJRCsrO1xuICAgICAgICByZXR1cm4gdGhpcy51bmlxdWVJRDtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy90cmFuc3BvcnRfc3RyYXRlZ3kudHNcblxuXG5cblxuY2xhc3MgdHJhbnNwb3J0X3N0cmF0ZWd5X1RyYW5zcG9ydFN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwcmlvcml0eSwgdHJhbnNwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgfVxuICAgIGlzU3VwcG9ydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuaXNTdXBwb3J0ZWQoe1xuICAgICAgICAgICAgdXNlVExTOiB0aGlzLm9wdGlvbnMudXNlVExTXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWxBdHRlbXB0KG5ldyBVbnN1cHBvcnRlZFN0cmF0ZWd5KCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByaW9yaXR5IDwgbWluUHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsQXR0ZW1wdChuZXcgVHJhbnNwb3J0UHJpb3JpdHlUb29Mb3coKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0LmNyZWF0ZUNvbm5lY3Rpb24odGhpcy5uYW1lLCB0aGlzLnByaW9yaXR5LCB0aGlzLm9wdGlvbnMua2V5LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB2YXIgaGFuZHNoYWtlID0gbnVsbDtcbiAgICAgICAgdmFyIG9uSW5pdGlhbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQudW5iaW5kKCdpbml0aWFsaXplZCcsIG9uSW5pdGlhbGl6ZWQpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LmNvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGhhbmRzaGFrZSA9IGZhY3RvcnkuY3JlYXRlSGFuZHNoYWtlKHRyYW5zcG9ydCwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbkNsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRUcmFuc3BvcnQ7XG4gICAgICAgICAgICBzZXJpYWxpemVkVHJhbnNwb3J0ID0gc2FmZUpTT05TdHJpbmdpZnkodHJhbnNwb3J0KTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBUcmFuc3BvcnRDbG9zZWQoc2VyaWFsaXplZFRyYW5zcG9ydCkpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdW5iaW5kTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0LnVuYmluZCgnaW5pdGlhbGl6ZWQnLCBvbkluaXRpYWxpemVkKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC51bmJpbmQoJ29wZW4nLCBvbk9wZW4pO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnVuYmluZCgnZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC51bmJpbmQoJ2Nsb3NlZCcsIG9uQ2xvc2VkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNwb3J0LmJpbmQoJ2luaXRpYWxpemVkJywgb25Jbml0aWFsaXplZCk7XG4gICAgICAgIHRyYW5zcG9ydC5iaW5kKCdvcGVuJywgb25PcGVuKTtcbiAgICAgICAgdHJhbnNwb3J0LmJpbmQoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgIHRyYW5zcG9ydC5iaW5kKCdjbG9zZWQnLCBvbkNsb3NlZCk7XG4gICAgICAgIHRyYW5zcG9ydC5pbml0aWFsaXplKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRzaGFrZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IHAgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmlvcml0eSA8IHApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZHNoYWtlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBmYWlsQXR0ZW1wdChlcnJvciwgY2FsbGJhY2spIHtcbiAgICB1dGlsLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uICgpIHsgfVxuICAgIH07XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy9zdHJhdGVneV9idWlsZGVyLnRzXG5cblxuXG5cblxuY29uc3QgeyBUcmFuc3BvcnRzOiBzdHJhdGVneV9idWlsZGVyX1RyYW5zcG9ydHMgfSA9IG5vZGVfcnVudGltZTtcbnZhciBzdHJhdGVneV9idWlsZGVyX2RlZmluZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChjb25maWcsIG5hbWUsIHR5cGUsIHByaW9yaXR5LCBvcHRpb25zLCBtYW5hZ2VyKSB7XG4gICAgdmFyIHRyYW5zcG9ydENsYXNzID0gc3RyYXRlZ3lfYnVpbGRlcl9UcmFuc3BvcnRzW3R5cGVdO1xuICAgIGlmICghdHJhbnNwb3J0Q2xhc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVHJhbnNwb3J0KHR5cGUpO1xuICAgIH1cbiAgICB2YXIgZW5hYmxlZCA9ICghY29uZmlnLmVuYWJsZWRUcmFuc3BvcnRzIHx8XG4gICAgICAgIGFycmF5SW5kZXhPZihjb25maWcuZW5hYmxlZFRyYW5zcG9ydHMsIG5hbWUpICE9PSAtMSkgJiZcbiAgICAgICAgKCFjb25maWcuZGlzYWJsZWRUcmFuc3BvcnRzIHx8XG4gICAgICAgICAgICBhcnJheUluZGV4T2YoY29uZmlnLmRpc2FibGVkVHJhbnNwb3J0cywgbmFtZSkgPT09IC0xKTtcbiAgICB2YXIgdHJhbnNwb3J0O1xuICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgaWdub3JlTnVsbE9yaWdpbjogY29uZmlnLmlnbm9yZU51bGxPcmlnaW4gfSwgb3B0aW9ucyk7XG4gICAgICAgIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRfc3RyYXRlZ3lfVHJhbnNwb3J0U3RyYXRlZ3kobmFtZSwgcHJpb3JpdHksIG1hbmFnZXIgPyBtYW5hZ2VyLmdldEFzc2lzdGFudCh0cmFuc3BvcnRDbGFzcykgOiB0cmFuc3BvcnRDbGFzcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cmFuc3BvcnQgPSBzdHJhdGVneV9idWlsZGVyX1Vuc3VwcG9ydGVkU3RyYXRlZ3k7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc3BvcnQ7XG59O1xudmFyIHN0cmF0ZWd5X2J1aWxkZXJfVW5zdXBwb3J0ZWRTdHJhdGVneSA9IHtcbiAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBjb25uZWN0OiBmdW5jdGlvbiAoXywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gdXRpbC5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgVW5zdXBwb3J0ZWRTdHJhdGVneSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLmVuc3VyZUFib3J0ZWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAoKSB7IH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL29wdGlvbnMudHNcblxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93ICdZb3UgbXVzdCBwYXNzIGFuIG9wdGlvbnMgb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2x1c3RlciA9PSBudWxsKSB7XG4gICAgICAgIHRocm93ICdPcHRpb25zIG9iamVjdCBtdXN0IHByb3ZpZGUgYSBjbHVzdGVyJztcbiAgICB9XG4gICAgaWYgKCdkaXNhYmxlU3RhdHMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ1RoZSBkaXNhYmxlU3RhdHMgb3B0aW9uIGlzIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgZW5hYmxlU3RhdHMnKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvYXV0aC91c2VyX2F1dGhlbnRpY2F0b3IudHNcblxuXG5jb25zdCBjb21wb3NlQ2hhbm5lbFF1ZXJ5ID0gKHBhcmFtcywgYXV0aE9wdGlvbnMpID0+IHtcbiAgICB2YXIgcXVlcnkgPSAnc29ja2V0X2lkPScgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnNvY2tldElkKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gYXV0aE9wdGlvbnMucGFyYW1zKSB7XG4gICAgICAgIHF1ZXJ5ICs9XG4gICAgICAgICAgICAnJicgK1xuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICtcbiAgICAgICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChhdXRoT3B0aW9ucy5wYXJhbXNba2V5XSk7XG4gICAgfVxuICAgIGlmIChhdXRoT3B0aW9ucy5wYXJhbXNQcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgIGxldCBkeW5hbWljUGFyYW1zID0gYXV0aE9wdGlvbnMucGFyYW1zUHJvdmlkZXIoKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGR5bmFtaWNQYXJhbXMpIHtcbiAgICAgICAgICAgIHF1ZXJ5ICs9XG4gICAgICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgK1xuICAgICAgICAgICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoZHluYW1pY1BhcmFtc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcXVlcnk7XG59O1xuY29uc3QgVXNlckF1dGhlbnRpY2F0b3IgPSAoYXV0aE9wdGlvbnMpID0+IHtcbiAgICBpZiAodHlwZW9mIG5vZGVfcnVudGltZS5nZXRBdXRob3JpemVycygpW2F1dGhPcHRpb25zLnRyYW5zcG9ydF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IGAnJHthdXRoT3B0aW9ucy50cmFuc3BvcnR9JyBpcyBub3QgYSByZWNvZ25pemVkIGF1dGggdHJhbnNwb3J0YDtcbiAgICB9XG4gICAgcmV0dXJuIChwYXJhbXMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gY29tcG9zZUNoYW5uZWxRdWVyeShwYXJhbXMsIGF1dGhPcHRpb25zKTtcbiAgICAgICAgbm9kZV9ydW50aW1lLmdldEF1dGhvcml6ZXJzKClbYXV0aE9wdGlvbnMudHJhbnNwb3J0XShub2RlX3J1bnRpbWUsIHF1ZXJ5LCBhdXRoT3B0aW9ucywgQXV0aFJlcXVlc3RUeXBlLlVzZXJBdXRoZW50aWNhdGlvbiwgY2FsbGJhY2spO1xuICAgIH07XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdXNlcl9hdXRoZW50aWNhdG9yID0gKFVzZXJBdXRoZW50aWNhdG9yKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9hdXRoL2NoYW5uZWxfYXV0aG9yaXplci50c1xuXG5cbmNvbnN0IGNoYW5uZWxfYXV0aG9yaXplcl9jb21wb3NlQ2hhbm5lbFF1ZXJ5ID0gKHBhcmFtcywgYXV0aE9wdGlvbnMpID0+IHtcbiAgICB2YXIgcXVlcnkgPSAnc29ja2V0X2lkPScgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnNvY2tldElkKTtcbiAgICBxdWVyeSArPSAnJmNoYW5uZWxfbmFtZT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5jaGFubmVsTmFtZSk7XG4gICAgZm9yICh2YXIga2V5IGluIGF1dGhPcHRpb25zLnBhcmFtcykge1xuICAgICAgICBxdWVyeSArPVxuICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArXG4gICAgICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoYXV0aE9wdGlvbnMucGFyYW1zW2tleV0pO1xuICAgIH1cbiAgICBpZiAoYXV0aE9wdGlvbnMucGFyYW1zUHJvdmlkZXIgIT0gbnVsbCkge1xuICAgICAgICBsZXQgZHluYW1pY1BhcmFtcyA9IGF1dGhPcHRpb25zLnBhcmFtc1Byb3ZpZGVyKCk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkeW5hbWljUGFyYW1zKSB7XG4gICAgICAgICAgICBxdWVyeSArPVxuICAgICAgICAgICAgICAgICcmJyArXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICtcbiAgICAgICAgICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGR5bmFtaWNQYXJhbXNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5O1xufTtcbmNvbnN0IENoYW5uZWxBdXRob3JpemVyID0gKGF1dGhPcHRpb25zKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBub2RlX3J1bnRpbWUuZ2V0QXV0aG9yaXplcnMoKVthdXRoT3B0aW9ucy50cmFuc3BvcnRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBgJyR7YXV0aE9wdGlvbnMudHJhbnNwb3J0fScgaXMgbm90IGEgcmVjb2duaXplZCBhdXRoIHRyYW5zcG9ydGA7XG4gICAgfVxuICAgIHJldHVybiAocGFyYW1zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCBxdWVyeSA9IGNoYW5uZWxfYXV0aG9yaXplcl9jb21wb3NlQ2hhbm5lbFF1ZXJ5KHBhcmFtcywgYXV0aE9wdGlvbnMpO1xuICAgICAgICBub2RlX3J1bnRpbWUuZ2V0QXV0aG9yaXplcnMoKVthdXRoT3B0aW9ucy50cmFuc3BvcnRdKG5vZGVfcnVudGltZSwgcXVlcnksIGF1dGhPcHRpb25zLCBBdXRoUmVxdWVzdFR5cGUuQ2hhbm5lbEF1dGhvcml6YXRpb24sIGNhbGxiYWNrKTtcbiAgICB9O1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNoYW5uZWxfYXV0aG9yaXplciA9IChDaGFubmVsQXV0aG9yaXplcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvYXV0aC9kZXByZWNhdGVkX2NoYW5uZWxfYXV0aG9yaXplci50c1xuY29uc3QgQ2hhbm5lbEF1dGhvcml6ZXJQcm94eSA9IChwdXNoZXIsIGF1dGhPcHRpb25zLCBjaGFubmVsQXV0aG9yaXplckdlbmVyYXRvcikgPT4ge1xuICAgIGNvbnN0IGRlcHJlY2F0ZWRBdXRob3JpemVyT3B0aW9ucyA9IHtcbiAgICAgICAgYXV0aFRyYW5zcG9ydDogYXV0aE9wdGlvbnMudHJhbnNwb3J0LFxuICAgICAgICBhdXRoRW5kcG9pbnQ6IGF1dGhPcHRpb25zLmVuZHBvaW50LFxuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgICBwYXJhbXM6IGF1dGhPcHRpb25zLnBhcmFtcyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGF1dGhPcHRpb25zLmhlYWRlcnNcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChwYXJhbXMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBwdXNoZXIuY2hhbm5lbChwYXJhbXMuY2hhbm5lbE5hbWUpO1xuICAgICAgICBjb25zdCBjaGFubmVsQXV0aG9yaXplciA9IGNoYW5uZWxBdXRob3JpemVyR2VuZXJhdG9yKGNoYW5uZWwsIGRlcHJlY2F0ZWRBdXRob3JpemVyT3B0aW9ucyk7XG4gICAgICAgIGNoYW5uZWxBdXRob3JpemVyLmF1dGhvcml6ZShwYXJhbXMuc29ja2V0SWQsIGNhbGxiYWNrKTtcbiAgICB9O1xufTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jb25maWcudHNcblxuXG5cblxuXG5mdW5jdGlvbiBnZXRDb25maWcob3B0cywgcHVzaGVyKSB7XG4gICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgICAgYWN0aXZpdHlUaW1lb3V0OiBvcHRzLmFjdGl2aXR5VGltZW91dCB8fCBkZWZhdWx0cy5hY3Rpdml0eVRpbWVvdXQsXG4gICAgICAgIGNsdXN0ZXI6IG9wdHMuY2x1c3RlcixcbiAgICAgICAgaHR0cFBhdGg6IG9wdHMuaHR0cFBhdGggfHwgZGVmYXVsdHMuaHR0cFBhdGgsXG4gICAgICAgIGh0dHBQb3J0OiBvcHRzLmh0dHBQb3J0IHx8IGRlZmF1bHRzLmh0dHBQb3J0LFxuICAgICAgICBodHRwc1BvcnQ6IG9wdHMuaHR0cHNQb3J0IHx8IGRlZmF1bHRzLmh0dHBzUG9ydCxcbiAgICAgICAgcG9uZ1RpbWVvdXQ6IG9wdHMucG9uZ1RpbWVvdXQgfHwgZGVmYXVsdHMucG9uZ1RpbWVvdXQsXG4gICAgICAgIHN0YXRzSG9zdDogb3B0cy5zdGF0c0hvc3QgfHwgZGVmYXVsdHMuc3RhdHNfaG9zdCxcbiAgICAgICAgdW5hdmFpbGFibGVUaW1lb3V0OiBvcHRzLnVuYXZhaWxhYmxlVGltZW91dCB8fCBkZWZhdWx0cy51bmF2YWlsYWJsZVRpbWVvdXQsXG4gICAgICAgIHdzUGF0aDogb3B0cy53c1BhdGggfHwgZGVmYXVsdHMud3NQYXRoLFxuICAgICAgICB3c1BvcnQ6IG9wdHMud3NQb3J0IHx8IGRlZmF1bHRzLndzUG9ydCxcbiAgICAgICAgd3NzUG9ydDogb3B0cy53c3NQb3J0IHx8IGRlZmF1bHRzLndzc1BvcnQsXG4gICAgICAgIGVuYWJsZVN0YXRzOiBnZXRFbmFibGVTdGF0c0NvbmZpZyhvcHRzKSxcbiAgICAgICAgaHR0cEhvc3Q6IGdldEh0dHBIb3N0KG9wdHMpLFxuICAgICAgICB1c2VUTFM6IHNob3VsZFVzZVRMUyhvcHRzKSxcbiAgICAgICAgd3NIb3N0OiBnZXRXZWJzb2NrZXRIb3N0KG9wdHMpLFxuICAgICAgICB1c2VyQXV0aGVudGljYXRvcjogYnVpbGRVc2VyQXV0aGVudGljYXRvcihvcHRzKSxcbiAgICAgICAgY2hhbm5lbEF1dGhvcml6ZXI6IGJ1aWxkQ2hhbm5lbEF1dGhvcml6ZXIob3B0cywgcHVzaGVyKVxuICAgIH07XG4gICAgaWYgKCdkaXNhYmxlZFRyYW5zcG9ydHMnIGluIG9wdHMpXG4gICAgICAgIGNvbmZpZy5kaXNhYmxlZFRyYW5zcG9ydHMgPSBvcHRzLmRpc2FibGVkVHJhbnNwb3J0cztcbiAgICBpZiAoJ2VuYWJsZWRUcmFuc3BvcnRzJyBpbiBvcHRzKVxuICAgICAgICBjb25maWcuZW5hYmxlZFRyYW5zcG9ydHMgPSBvcHRzLmVuYWJsZWRUcmFuc3BvcnRzO1xuICAgIGlmICgnaWdub3JlTnVsbE9yaWdpbicgaW4gb3B0cylcbiAgICAgICAgY29uZmlnLmlnbm9yZU51bGxPcmlnaW4gPSBvcHRzLmlnbm9yZU51bGxPcmlnaW47XG4gICAgaWYgKCd0aW1lbGluZVBhcmFtcycgaW4gb3B0cylcbiAgICAgICAgY29uZmlnLnRpbWVsaW5lUGFyYW1zID0gb3B0cy50aW1lbGluZVBhcmFtcztcbiAgICBpZiAoJ25hY2wnIGluIG9wdHMpIHtcbiAgICAgICAgY29uZmlnLm5hY2wgPSBvcHRzLm5hY2w7XG4gICAgfVxuICAgIHJldHVybiBjb25maWc7XG59XG5mdW5jdGlvbiBnZXRIdHRwSG9zdChvcHRzKSB7XG4gICAgaWYgKG9wdHMuaHR0cEhvc3QpIHtcbiAgICAgICAgcmV0dXJuIG9wdHMuaHR0cEhvc3Q7XG4gICAgfVxuICAgIGlmIChvcHRzLmNsdXN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGBzb2NranMtJHtvcHRzLmNsdXN0ZXJ9LnB1c2hlci5jb21gO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdHMuaHR0cEhvc3Q7XG59XG5mdW5jdGlvbiBnZXRXZWJzb2NrZXRIb3N0KG9wdHMpIHtcbiAgICBpZiAob3B0cy53c0hvc3QpIHtcbiAgICAgICAgcmV0dXJuIG9wdHMud3NIb3N0O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0V2Vic29ja2V0SG9zdEZyb21DbHVzdGVyKG9wdHMuY2x1c3Rlcik7XG59XG5mdW5jdGlvbiBnZXRXZWJzb2NrZXRIb3N0RnJvbUNsdXN0ZXIoY2x1c3Rlcikge1xuICAgIHJldHVybiBgd3MtJHtjbHVzdGVyfS5wdXNoZXIuY29tYDtcbn1cbmZ1bmN0aW9uIHNob3VsZFVzZVRMUyhvcHRzKSB7XG4gICAgaWYgKG5vZGVfcnVudGltZS5nZXRQcm90b2NvbCgpID09PSAnaHR0cHM6Jykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0cy5mb3JjZVRMUyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldEVuYWJsZVN0YXRzQ29uZmlnKG9wdHMpIHtcbiAgICBpZiAoJ2VuYWJsZVN0YXRzJyBpbiBvcHRzKSB7XG4gICAgICAgIHJldHVybiBvcHRzLmVuYWJsZVN0YXRzO1xuICAgIH1cbiAgICBpZiAoJ2Rpc2FibGVTdGF0cycgaW4gb3B0cykge1xuICAgICAgICByZXR1cm4gIW9wdHMuZGlzYWJsZVN0YXRzO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBoYXNDdXN0b21IYW5kbGVyID0gKGF1dGgpID0+IHtcbiAgICByZXR1cm4gJ2N1c3RvbUhhbmRsZXInIGluIGF1dGggJiYgYXV0aFsnY3VzdG9tSGFuZGxlciddICE9IG51bGw7XG59O1xuZnVuY3Rpb24gYnVpbGRVc2VyQXV0aGVudGljYXRvcihvcHRzKSB7XG4gICAgY29uc3QgdXNlckF1dGhlbnRpY2F0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cy51c2VyQXV0aGVudGljYXRpb24pLCBvcHRzLnVzZXJBdXRoZW50aWNhdGlvbik7XG4gICAgaWYgKGhhc0N1c3RvbUhhbmRsZXIodXNlckF1dGhlbnRpY2F0aW9uKSkge1xuICAgICAgICByZXR1cm4gdXNlckF1dGhlbnRpY2F0aW9uWydjdXN0b21IYW5kbGVyJ107XG4gICAgfVxuICAgIHJldHVybiB1c2VyX2F1dGhlbnRpY2F0b3IodXNlckF1dGhlbnRpY2F0aW9uKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ2hhbm5lbEF1dGgob3B0cywgcHVzaGVyKSB7XG4gICAgbGV0IGNoYW5uZWxBdXRob3JpemF0aW9uO1xuICAgIGlmICgnY2hhbm5lbEF1dGhvcml6YXRpb24nIGluIG9wdHMpIHtcbiAgICAgICAgY2hhbm5lbEF1dGhvcml6YXRpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLmNoYW5uZWxBdXRob3JpemF0aW9uKSwgb3B0cy5jaGFubmVsQXV0aG9yaXphdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGFubmVsQXV0aG9yaXphdGlvbiA9IHtcbiAgICAgICAgICAgIHRyYW5zcG9ydDogb3B0cy5hdXRoVHJhbnNwb3J0IHx8IGRlZmF1bHRzLmF1dGhUcmFuc3BvcnQsXG4gICAgICAgICAgICBlbmRwb2ludDogb3B0cy5hdXRoRW5kcG9pbnQgfHwgZGVmYXVsdHMuYXV0aEVuZHBvaW50XG4gICAgICAgIH07XG4gICAgICAgIGlmICgnYXV0aCcgaW4gb3B0cykge1xuICAgICAgICAgICAgaWYgKCdwYXJhbXMnIGluIG9wdHMuYXV0aClcbiAgICAgICAgICAgICAgICBjaGFubmVsQXV0aG9yaXphdGlvbi5wYXJhbXMgPSBvcHRzLmF1dGgucGFyYW1zO1xuICAgICAgICAgICAgaWYgKCdoZWFkZXJzJyBpbiBvcHRzLmF1dGgpXG4gICAgICAgICAgICAgICAgY2hhbm5lbEF1dGhvcml6YXRpb24uaGVhZGVycyA9IG9wdHMuYXV0aC5oZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnYXV0aG9yaXplcicgaW4gb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjdXN0b21IYW5kbGVyOiBDaGFubmVsQXV0aG9yaXplclByb3h5KHB1c2hlciwgY2hhbm5lbEF1dGhvcml6YXRpb24sIG9wdHMuYXV0aG9yaXplcilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWxBdXRob3JpemF0aW9uO1xufVxuZnVuY3Rpb24gYnVpbGRDaGFubmVsQXV0aG9yaXplcihvcHRzLCBwdXNoZXIpIHtcbiAgICBjb25zdCBjaGFubmVsQXV0aG9yaXphdGlvbiA9IGJ1aWxkQ2hhbm5lbEF1dGgob3B0cywgcHVzaGVyKTtcbiAgICBpZiAoaGFzQ3VzdG9tSGFuZGxlcihjaGFubmVsQXV0aG9yaXphdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWxBdXRob3JpemF0aW9uWydjdXN0b21IYW5kbGVyJ107XG4gICAgfVxuICAgIHJldHVybiBjaGFubmVsX2F1dGhvcml6ZXIoY2hhbm5lbEF1dGhvcml6YXRpb24pO1xufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3dhdGNobGlzdC50c1xuXG5cbmNsYXNzIHdhdGNobGlzdF9XYXRjaGxpc3RGYWNhZGUgZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHB1c2hlcikge1xuICAgICAgICBzdXBlcihmdW5jdGlvbiAoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYE5vIGNhbGxiYWNrcyBvbiB3YXRjaGxpc3QgZXZlbnRzIGZvciAke2V2ZW50TmFtZX1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHVzaGVyID0gcHVzaGVyO1xuICAgICAgICB0aGlzLmJpbmRXYXRjaGxpc3RJbnRlcm5hbEV2ZW50KCk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KHB1c2hlckV2ZW50KSB7XG4gICAgICAgIHB1c2hlckV2ZW50LmRhdGEuZXZlbnRzLmZvckVhY2god2F0Y2hsaXN0RXZlbnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KHdhdGNobGlzdEV2ZW50Lm5hbWUsIHdhdGNobGlzdEV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJpbmRXYXRjaGxpc3RJbnRlcm5hbEV2ZW50KCkge1xuICAgICAgICB0aGlzLnB1c2hlci5jb25uZWN0aW9uLmJpbmQoJ21lc3NhZ2UnLCBwdXNoZXJFdmVudCA9PiB7XG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gcHVzaGVyRXZlbnQuZXZlbnQ7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAncHVzaGVyX2ludGVybmFsOndhdGNobGlzdF9ldmVudHMnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudChwdXNoZXJFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy9mbGF0X3Byb21pc2UudHNcbmZ1bmN0aW9uIGZsYXRQcm9taXNlKCkge1xuICAgIGxldCByZXNvbHZlLCByZWplY3Q7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICByZWplY3QgPSByZWo7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH07XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmbGF0X3Byb21pc2UgPSAoZmxhdFByb21pc2UpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3VzZXIudHNcblxuXG5cblxuXG5jbGFzcyB1c2VyX1VzZXJGYWNhZGUgZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHB1c2hlcikge1xuICAgICAgICBzdXBlcihmdW5jdGlvbiAoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ05vIGNhbGxiYWNrcyBvbiB1c2VyIGZvciAnICsgZXZlbnROYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2lnbmluX3JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVzZXJfZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2lnbmluRG9uZVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9zaWduaW5Eb25lUmVzb2x2ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uQXV0aG9yaXplID0gKGVyciwgYXV0aERhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgRXJyb3IgZHVyaW5nIHNpZ25pbjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoJ3B1c2hlcjpzaWduaW4nLCB7XG4gICAgICAgICAgICAgICAgYXV0aDogYXV0aERhdGEuYXV0aCxcbiAgICAgICAgICAgICAgICB1c2VyX2RhdGE6IGF1dGhEYXRhLnVzZXJfZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHVzaGVyID0gcHVzaGVyO1xuICAgICAgICB0aGlzLnB1c2hlci5jb25uZWN0aW9uLmJpbmQoJ3N0YXRlX2NoYW5nZScsICh7IHByZXZpb3VzLCBjdXJyZW50IH0pID0+IHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyAhPT0gJ2Nvbm5lY3RlZCcgJiYgY3VycmVudCA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaWduaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gJ2Nvbm5lY3RlZCcgJiYgY3VycmVudCAhPT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV3U2lnbmluUHJvbWlzZUlmTmVlZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndhdGNobGlzdCA9IG5ldyB3YXRjaGxpc3RfV2F0Y2hsaXN0RmFjYWRlKHB1c2hlcik7XG4gICAgICAgIHRoaXMucHVzaGVyLmNvbm5lY3Rpb24uYmluZCgnbWVzc2FnZScsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudC5ldmVudDtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdwdXNoZXI6c2lnbmluX3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TaWduaW5TdWNjZXNzKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbC5uYW1lID09PSBldmVudC5jaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25pbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmluX3JlcXVlc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lnbmluX3JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NpZ25pbigpO1xuICAgIH1cbiAgICBfc2lnbmluKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2lnbmluX3JlcXVlc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25ld1NpZ25pblByb21pc2VJZk5lZWRlZCgpO1xuICAgICAgICBpZiAodGhpcy5wdXNoZXIuY29ubmVjdGlvbi5zdGF0ZSAhPT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hlci5jb25maWcudXNlckF1dGhlbnRpY2F0b3Ioe1xuICAgICAgICAgICAgc29ja2V0SWQ6IHRoaXMucHVzaGVyLmNvbm5lY3Rpb24uc29ja2V0X2lkXG4gICAgICAgIH0sIHRoaXMuX29uQXV0aG9yaXplKTtcbiAgICB9XG4gICAgX29uU2lnbmluU3VjY2VzcyhkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJfZGF0YSA9IEpTT04ucGFyc2UoZGF0YS51c2VyX2RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCBwYXJzaW5nIHVzZXIgZGF0YSBhZnRlciBzaWduaW46ICR7ZGF0YS51c2VyX2RhdGF9YCk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnVzZXJfZGF0YS5pZCAhPT0gJ3N0cmluZycgfHwgdGhpcy51c2VyX2RhdGEuaWQgPT09ICcnKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYHVzZXJfZGF0YSBkb2Vzbid0IGNvbnRhaW4gYW4gaWQuIHVzZXJfZGF0YTogJHt0aGlzLnVzZXJfZGF0YX1gKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaWduaW5Eb25lUmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVDaGFubmVscygpO1xuICAgIH1cbiAgICBfc3Vic2NyaWJlQ2hhbm5lbHMoKSB7XG4gICAgICAgIGNvbnN0IGVuc3VyZV9zdWJzY3JpYmVkID0gY2hhbm5lbCA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbm5lbC5zdWJzY3JpcHRpb25QZW5kaW5nICYmIGNoYW5uZWwuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5yZWluc3RhdGVTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hlci5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCA9IG5ldyBjaGFubmVsX0NoYW5uZWwoYCNzZXJ2ZXItdG8tdXNlci0ke3RoaXMudXNlcl9kYXRhLmlkfWAsIHRoaXMucHVzaGVyKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLmJpbmRfZ2xvYmFsKChldmVudE5hbWUsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUuaW5kZXhPZigncHVzaGVyX2ludGVybmFsOicpID09PSAwIHx8XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcjonKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudE5hbWUsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgZW5zdXJlX3N1YnNjcmliZWQodGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsKTtcbiAgICB9XG4gICAgX2NsZWFudXAoKSB7XG4gICAgICAgIHRoaXMudXNlcl9kYXRhID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLnVuYmluZF9hbGwoKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnNlcnZlclRvVXNlckNoYW5uZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNpZ25pbl9yZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25pbkRvbmVSZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX25ld1NpZ25pblByb21pc2VJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpZ25pbl9yZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaWduaW5Eb25lUHJvbWlzZSAmJiAhdGhpcy5zaWduaW5Eb25lUHJvbWlzZS5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3Q6IF8gfSA9IGZsYXRfcHJvbWlzZSgpO1xuICAgICAgICBwcm9taXNlLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc2V0RG9uZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHByb21pc2UuZG9uZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHByb21pc2UudGhlbihzZXREb25lKS5jYXRjaChzZXREb25lKTtcbiAgICAgICAgdGhpcy5zaWduaW5Eb25lUHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHRoaXMuX3NpZ25pbkRvbmVSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvcHVzaGVyLnRzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNsYXNzIHB1c2hlcl9QdXNoZXIge1xuICAgIHN0YXRpYyByZWFkeSgpIHtcbiAgICAgICAgcHVzaGVyX1B1c2hlci5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwdXNoZXJfUHVzaGVyLmluc3RhbmNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHB1c2hlcl9QdXNoZXIuaW5zdGFuY2VzW2ldLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q2xpZW50RmVhdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGZpbHRlck9iamVjdCh7IHdzOiBub2RlX3J1bnRpbWUuVHJhbnNwb3J0cy53cyB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQuaXNTdXBwb3J0ZWQoe30pO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGFwcF9rZXksIG9wdGlvbnMpIHtcbiAgICAgICAgY2hlY2tBcHBLZXkoYXBwX2tleSk7XG4gICAgICAgIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5rZXkgPSBhcHBfa2V5O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGdldENvbmZpZyh0aGlzLm9wdGlvbnMsIHRoaXMpO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gZmFjdG9yeS5jcmVhdGVDaGFubmVscygpO1xuICAgICAgICB0aGlzLmdsb2JhbF9lbWl0dGVyID0gbmV3IGRpc3BhdGNoZXJfRGlzcGF0Y2hlcigpO1xuICAgICAgICB0aGlzLnNlc3Npb25JRCA9IG5vZGVfcnVudGltZS5yYW5kb21JbnQoMTAwMDAwMDAwMCk7XG4gICAgICAgIHRoaXMudGltZWxpbmUgPSBuZXcgdGltZWxpbmVfVGltZWxpbmUodGhpcy5rZXksIHRoaXMuc2Vzc2lvbklELCB7XG4gICAgICAgICAgICBjbHVzdGVyOiB0aGlzLmNvbmZpZy5jbHVzdGVyLFxuICAgICAgICAgICAgZmVhdHVyZXM6IHB1c2hlcl9QdXNoZXIuZ2V0Q2xpZW50RmVhdHVyZXMoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy5jb25maWcudGltZWxpbmVQYXJhbXMgfHwge30sXG4gICAgICAgICAgICBsaW1pdDogNTAsXG4gICAgICAgICAgICBsZXZlbDogdGltZWxpbmVfbGV2ZWwuSU5GTyxcbiAgICAgICAgICAgIHZlcnNpb246IGRlZmF1bHRzLlZFUlNJT05cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVTdGF0cykge1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZVNlbmRlciA9IGZhY3RvcnkuY3JlYXRlVGltZWxpbmVTZW5kZXIodGhpcy50aW1lbGluZSwge1xuICAgICAgICAgICAgICAgIGhvc3Q6IHRoaXMuY29uZmlnLnN0YXRzSG9zdCxcbiAgICAgICAgICAgICAgICBwYXRoOiAnL3RpbWVsaW5lL3YyLycgKyBub2RlX3J1bnRpbWUuVGltZWxpbmVUcmFuc3BvcnQubmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdldFN0cmF0ZWd5ID0gKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlX3J1bnRpbWUuZ2V0RGVmYXVsdFN0cmF0ZWd5KHRoaXMuY29uZmlnLCBvcHRpb25zLCBzdHJhdGVneV9idWlsZGVyX2RlZmluZVRyYW5zcG9ydCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGZhY3RvcnkuY3JlYXRlQ29ubmVjdGlvbk1hbmFnZXIodGhpcy5rZXksIHtcbiAgICAgICAgICAgIGdldFN0cmF0ZWd5OiBnZXRTdHJhdGVneSxcbiAgICAgICAgICAgIHRpbWVsaW5lOiB0aGlzLnRpbWVsaW5lLFxuICAgICAgICAgICAgYWN0aXZpdHlUaW1lb3V0OiB0aGlzLmNvbmZpZy5hY3Rpdml0eVRpbWVvdXQsXG4gICAgICAgICAgICBwb25nVGltZW91dDogdGhpcy5jb25maWcucG9uZ1RpbWVvdXQsXG4gICAgICAgICAgICB1bmF2YWlsYWJsZVRpbWVvdXQ6IHRoaXMuY29uZmlnLnVuYXZhaWxhYmxlVGltZW91dCxcbiAgICAgICAgICAgIHVzZVRMUzogQm9vbGVhbih0aGlzLmNvbmZpZy51c2VUTFMpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uYmluZCgnY29ubmVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVBbGwoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVsaW5lU2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lbGluZVNlbmRlci5zZW5kKHRoaXMuY29ubmVjdGlvbi5pc1VzaW5nVExTKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ21lc3NhZ2UnLCBldmVudCA9PiB7XG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQuZXZlbnQ7XG4gICAgICAgICAgICB2YXIgaW50ZXJuYWwgPSBldmVudE5hbWUuaW5kZXhPZigncHVzaGVyX2ludGVybmFsOicpID09PSAwO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbChldmVudC5jaGFubmVsKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWludGVybmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlci5lbWl0KGV2ZW50LmV2ZW50LCBldmVudC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5iaW5kKCdjb25uZWN0aW5nJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVscy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uYmluZCgnZGlzY29ubmVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVscy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uYmluZCgnZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHB1c2hlcl9QdXNoZXIuaW5zdGFuY2VzLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMudGltZWxpbmUuaW5mbyh7IGluc3RhbmNlczogcHVzaGVyX1B1c2hlci5pbnN0YW5jZXMubGVuZ3RoIH0pO1xuICAgICAgICB0aGlzLnVzZXIgPSBuZXcgdXNlcl9Vc2VyRmFjYWRlKHRoaXMpO1xuICAgICAgICBpZiAocHVzaGVyX1B1c2hlci5pc1JlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2hDbHVzdGVyKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBhcHBLZXksIGNsdXN0ZXIgfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMua2V5ID0gYXBwS2V5O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIHsgY2x1c3RlciB9KTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBnZXRDb25maWcodGhpcy5vcHRpb25zLCB0aGlzKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnN3aXRjaENsdXN0ZXIodGhpcy5rZXkpO1xuICAgIH1cbiAgICBjaGFubmVsKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHMuZmluZChuYW1lKTtcbiAgICB9XG4gICAgYWxsQ2hhbm5lbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzLmFsbCgpO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCgpO1xuICAgICAgICBpZiAodGhpcy50aW1lbGluZVNlbmRlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRpbWVsaW5lU2VuZGVyVGltZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXNpbmdUTFMgPSB0aGlzLmNvbm5lY3Rpb24uaXNVc2luZ1RMUygpO1xuICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZVNlbmRlciA9IHRoaXMudGltZWxpbmVTZW5kZXI7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lbGluZVNlbmRlclRpbWVyID0gbmV3IHRpbWVyc19QZXJpb2RpY1RpbWVyKDYwMDAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lU2VuZGVyLnNlbmQodXNpbmdUTFMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgICAgIGlmICh0aGlzLnRpbWVsaW5lU2VuZGVyVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVTZW5kZXJUaW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lU2VuZGVyVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJpbmQoZXZlbnRfbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlci5iaW5kKGV2ZW50X25hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZChldmVudF9uYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB0aGlzLmdsb2JhbF9lbWl0dGVyLnVuYmluZChldmVudF9uYW1lLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBiaW5kX2dsb2JhbChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmdsb2JhbF9lbWl0dGVyLmJpbmRfZ2xvYmFsKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZF9nbG9iYWwoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlci51bmJpbmRfZ2xvYmFsKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZF9hbGwoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlci51bmJpbmRfYWxsKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdWJzY3JpYmVBbGwoKSB7XG4gICAgICAgIHZhciBjaGFubmVsTmFtZTtcbiAgICAgICAgZm9yIChjaGFubmVsTmFtZSBpbiB0aGlzLmNoYW5uZWxzLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVscy5jaGFubmVscy5oYXNPd25Qcm9wZXJ0eShjaGFubmVsTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZShjaGFubmVsTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlKGNoYW5uZWxfbmFtZSkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuYWRkKGNoYW5uZWxfbmFtZSwgdGhpcyk7XG4gICAgICAgIGlmIChjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcgJiYgY2hhbm5lbC5zdWJzY3JpcHRpb25DYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucmVpbnN0YXRlU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWNoYW5uZWwuc3Vic2NyaXB0aW9uUGVuZGluZyAmJlxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgY2hhbm5lbC5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbm5lbDtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoY2hhbm5lbF9uYW1lKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKGNoYW5uZWxfbmFtZSk7XG4gICAgICAgIGlmIChjaGFubmVsICYmIGNoYW5uZWwuc3Vic2NyaXB0aW9uUGVuZGluZykge1xuICAgICAgICAgICAgY2hhbm5lbC5jYW5jZWxTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLnJlbW92ZShjaGFubmVsX25hbWUpO1xuICAgICAgICAgICAgaWYgKGNoYW5uZWwgJiYgY2hhbm5lbC5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRfZXZlbnQoZXZlbnRfbmFtZSwgZGF0YSwgY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRfZXZlbnQoZXZlbnRfbmFtZSwgZGF0YSwgY2hhbm5lbCk7XG4gICAgfVxuICAgIHNob3VsZFVzZVRMUygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnVzZVRMUztcbiAgICB9XG4gICAgc2lnbmluKCkge1xuICAgICAgICB0aGlzLnVzZXIuc2lnbmluKCk7XG4gICAgfVxufVxucHVzaGVyX1B1c2hlci5pbnN0YW5jZXMgPSBbXTtcbnB1c2hlcl9QdXNoZXIuaXNSZWFkeSA9IGZhbHNlO1xucHVzaGVyX1B1c2hlci5sb2dUb0NvbnNvbGUgPSBmYWxzZTtcbnB1c2hlcl9QdXNoZXIuUnVudGltZSA9IG5vZGVfcnVudGltZTtcbnB1c2hlcl9QdXNoZXIuU2NyaXB0UmVjZWl2ZXJzID0gbm9kZV9ydW50aW1lLlNjcmlwdFJlY2VpdmVycztcbnB1c2hlcl9QdXNoZXIuRGVwZW5kZW5jaWVzUmVjZWl2ZXJzID0gbm9kZV9ydW50aW1lLkRlcGVuZGVuY2llc1JlY2VpdmVycztcbnB1c2hlcl9QdXNoZXIuYXV0aF9jYWxsYmFja3MgPSBub2RlX3J1bnRpbWUuYXV0aF9jYWxsYmFja3M7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb3JlX3B1c2hlciA9IChwdXNoZXJfUHVzaGVyKTtcbmZ1bmN0aW9uIGNoZWNrQXBwS2V5KGtleSkge1xuICAgIGlmIChrZXkgPT09IG51bGwgfHwga2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgJ1lvdSBtdXN0IHBhc3MgeW91ciBhcHAga2V5IHdoZW4geW91IGluc3RhbnRpYXRlIFB1c2hlci4nO1xuICAgIH1cbn1cbm5vZGVfcnVudGltZS5zZXR1cChwdXNoZXJfUHVzaGVyKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy90d2VldG5hY2wvbmFjbC1mYXN0LmpzXG52YXIgbmFjbF9mYXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvcHVzaGVyLXdpdGgtZW5jcnlwdGlvbi50c1xuXG5cblxuY2xhc3MgcHVzaGVyX3dpdGhfZW5jcnlwdGlvbl9QdXNoZXJXaXRoRW5jcnlwdGlvbiBleHRlbmRzIGNvcmVfcHVzaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhcHBfa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIGNvcmVfcHVzaGVyLmxvZ1RvQ29uc29sZSA9IHB1c2hlcl93aXRoX2VuY3J5cHRpb25fUHVzaGVyV2l0aEVuY3J5cHRpb24ubG9nVG9Db25zb2xlO1xuICAgICAgICBjb3JlX3B1c2hlci5sb2cgPSBwdXNoZXJfd2l0aF9lbmNyeXB0aW9uX1B1c2hlcldpdGhFbmNyeXB0aW9uLmxvZztcbiAgICAgICAgdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLm5hY2wgPSBuYWNsX2Zhc3Q7XG4gICAgICAgIHN1cGVyKGFwcF9rZXksIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdXNoZXIuanMubWFwIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiciIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJ0IiwibW9kZSIsIl9fZXNNb2R1bGUiLCJucyIsImNyZWF0ZSIsImtleSIsImJpbmQiLCJuIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJyZXF1aXJlIiwiYnVmZmVyIiwiQnVmZmVyIiwiY29weVByb3BzIiwic3JjIiwiZHN0IiwiZnJvbSIsImFsbG9jIiwiYWxsb2NVbnNhZmUiLCJhbGxvY1Vuc2FmZVNsb3ciLCJTYWZlQnVmZmVyIiwiYXJnIiwiZW5jb2RpbmdPck9mZnNldCIsImxlbmd0aCIsIlR5cGVFcnJvciIsInNpemUiLCJmaWxsIiwiZW5jb2RpbmciLCJidWYiLCJ1bmRlZmluZWQiLCJTbG93QnVmZmVyIiwiRW1pdHRlciIsIkV2ZW50RW1pdHRlciIsInV0aWwiLCJzdHJlYW1zIiwiSGVhZGVycyIsIlJlYWRlciIsIkJhc2UiLCJyZXF1ZXN0IiwidXJsIiwib3B0aW9ucyIsInZhbGlkYXRlT3B0aW9ucyIsIl9yZXF1ZXN0IiwiX3JlYWRlciIsIl9vcHRpb25zIiwiX21heExlbmd0aCIsIm1heExlbmd0aCIsIk1BWF9MRU5HVEgiLCJfaGVhZGVycyIsIl9fcXVldWUiLCJyZWFkeVN0YXRlIiwiaW8iLCJJTyIsIm1lc3NhZ2VzIiwiTWVzc2FnZXMiLCJfYmluZEV2ZW50TGlzdGVuZXJzIiwiaW5oZXJpdHMiLCJpc1dlYlNvY2tldCIsImNvbm5lY3Rpb24iLCJoZWFkZXJzIiwidXBncmFkZSIsIm1ldGhvZCIsInRvTG93ZXJDYXNlIiwic3BsaXQiLCJpbmRleE9mIiwidmFsaWRLZXlzIiwiRXJyb3IiLCJpbnN0YW5jZSIsIlNUQVRFUyIsInNlbGYiLCJvbiIsImV2ZW50IiwicmVhZGFibGUiLCJlbWl0IiwiZGF0YSIsImVycm9yIiwid3JpdGFibGUiLCJnZXRTdGF0ZSIsImFkZEV4dGVuc2lvbiIsImV4dGVuc2lvbiIsInNldEhlYWRlciIsInNldCIsInN0YXJ0IiwiX2ZhaWxIYW5kc2hha2UiLCJyZXNwb25zZSIsIl9oYW5kc2hha2VSZXNwb25zZSIsIl93cml0ZSIsIl9zdGFnZSIsIl9vcGVuIiwiYnl0ZUxlbmd0aCIsIm1lc3NhZ2UiLCJ0b1N0cmluZyIsImpvaW4iLCJfZmFpbCIsInRleHQiLCJmcmFtZSIsImJpbmFyeSIsInBpbmciLCJwb25nIiwiY2xvc2UiLCJyZWFzb24iLCJjb2RlIiwiQ2xvc2VFdmVudCIsImZvckVhY2giLCJhcmdzIiwiYXBwbHkiLCJPcGVuRXZlbnQiLCJfcXVldWUiLCJwdXNoIiwiY2h1bmsiLCJ0eXBlIiwiQ29ubmVjdEV2ZW50IiwiTWVzc2FnZUV2ZW50IiwiUGluZ0V2ZW50IiwiUG9uZ0V2ZW50IiwiQ2xpZW50IiwiU2VydmVyIiwiRHJpdmVyIiwiY2xpZW50IiwibWFza2luZyIsInNlcnZlciIsInJlcXVpcmVNYXNraW5nIiwiaHR0cCIsImFyZ3VtZW50cyIsImlzU2VjdXJlUmVxdWVzdCIsIkV2ZW50IiwiZXZlbnRUeXBlIiwiaW5pdEV2ZW50IiwiY2FuQnViYmxlIiwiY2FuY2VsYWJsZSIsImJ1YmJsZXMiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsIkNBUFRVUklOR19QSEFTRSIsIkFUX1RBUkdFVCIsIkJVQkJMSU5HX1BIQVNFIiwiX19leHRlbmRzIiwiZXh0ZW5kU3RhdGljcyIsImIiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIkFycmF5IiwiX18iLCJjb25zdHJ1Y3RvciIsIklOVkFMSURfQllURSIsIkNvZGVyIiwiX3BhZGRpbmdDaGFyYWN0ZXIiLCJlbmNvZGVkTGVuZ3RoIiwiZW5jb2RlIiwib3V0IiwiX2VuY29kZUJ5dGUiLCJsZWZ0IiwibWF4RGVjb2RlZExlbmd0aCIsImRlY29kZWRMZW5ndGgiLCJfZ2V0UGFkZGluZ0xlbmd0aCIsImRlY29kZSIsIlVpbnQ4QXJyYXkiLCJwYWRkaW5nTGVuZ3RoIiwib3AiLCJoYXZlQmFkIiwidjAiLCJ2MSIsInYyIiwidjMiLCJfZGVjb2RlQ2hhciIsImNoYXJDb2RlQXQiLCJyZXN1bHQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzdGRDb2RlciIsIlVSTFNhZmVDb2RlciIsIl9zdXBlciIsInVybFNhZmVDb2RlciIsImVuY29kZVVSTFNhZmUiLCJkZWNvZGVVUkxTYWZlIiwiY2xlYXIiLCJBTExPV0VEX0RVUExJQ0FURVMiLCJfc2VudCIsIl9saW5lcyIsIl9zdHJpcCIsInN0cmluZyIsInJlcGxhY2UiLCJOb2RlSFRUUFBhcnNlciIsIkhUVFBQYXJzZXIiLCJUWVBFUyIsIlJFUVVFU1QiLCJSRVNQT05TRSIsIkh0dHBQYXJzZXIiLCJfdHlwZSIsIl9wYXJzZXIiLCJfY29tcGxldGUiLCJjdXJyZW50Iiwib25IZWFkZXJGaWVsZCIsIm9uSGVhZGVyVmFsdWUiLCJvbkhlYWRlcnNDb21wbGV0ZSIsImtPbkhlYWRlcnNDb21wbGV0ZSIsIm1ham9yVmVyc2lvbiIsIm1pbm9yVmVyc2lvbiIsInBhdGhuYW1lIiwic3RhdHVzQ29kZSIsImluZm8iLCJNRVRIT0RTIiwiVkVSU0lPTiIsInByb2Nlc3MiLCJ2ZXJzaW9uIiwibWF0Y2giLCJtYXAiLCJwYXJzZUludCIsImlzQ29tcGxldGUiLCJwYXJzZSIsImNvbnN1bWVkIiwiZXhlY3V0ZSIsImJvZHkiLCJzbGljZSIsIlN0cmVhbSIsImRyaXZlciIsIkV2ZW50VGFyZ2V0IiwiQVBJIiwiX2RyaXZlciIsImV4dGVuc2lvbnMiLCJjb25jYXQiLCJfcGluZyIsIl9waW5nSWQiLCJDT05ORUNUSU5HIiwiYnVmZmVyZWRBbW91bnQiLCJwcm90b2NvbCIsImUiLCJfcmVjZWl2ZU1lc3NhZ2UiLCJfYmVnaW5DbG9zZSIsIl9lbWl0RXJyb3IiLCJfcGluZ1RpbWVyIiwic2V0SW50ZXJ2YWwiLCJfY29uZmlndXJlU3RyZWFtIiwiX3Byb3h5IiwiX3N0cmVhbSIsInBpcGUiLCJPUEVOIiwiQ0xPU0lORyIsIkNMT1NFRCIsIkNMT1NFX1RJTUVPVVQiLCJ3cml0ZSIsInNlbmQiLCJlbmQiLCJwYXVzZSIsInJlc3VtZSIsImNhbGxiYWNrIiwiX2Nsb3NlVGltZXIiLCJzZXRUaW1lb3V0Iiwic2V0Tm9EZWxheSIsIl9maW5hbGl6ZUNsb3NlIiwiZGlzcGF0Y2hFdmVudCIsIl9jbG9zZVBhcmFtcyIsImRlc3Ryb3kiLCJjbGVhclRpbWVvdXQiLCJjbGVhckludGVydmFsIiwiY3J5cHRvIiwiRXh0ZW5zaW9ucyIsIkZyYW1lIiwiTWVzc2FnZSIsIkh5YmkiLCJfZXh0ZW5zaW9ucyIsIl9tYXNraW5nIiwiX3Byb3RvY29scyIsInByb3RvY29scyIsIl9yZXF1aXJlTWFza2luZyIsIl9waW5nQ2FsbGJhY2tzIiwicHJvdG9zIiwic3VwcG9ydGVkIiwiZmlsdGVyIiwibWFzayIsInBheWxvYWQiLCJvZmZzZXQiLCJnZW5lcmF0ZUFjY2VwdCIsInNoYTEiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiR1VJRCIsImRpZ2VzdCIsIkZJTiIsIk1BU0siLCJSU1YxIiwiUlNWMiIsIlJTVjMiLCJPUENPREUiLCJMRU5HVEgiLCJPUENPREVTIiwiY29udGludWF0aW9uIiwiT1BDT0RFX0NPREVTIiwiTUVTU0FHRV9PUENPREVTIiwiT1BFTklOR19PUENPREVTIiwiRVJST1JTIiwibm9ybWFsX2Nsb3N1cmUiLCJnb2luZ19hd2F5IiwicHJvdG9jb2xfZXJyb3IiLCJ1bmFjY2VwdGFibGUiLCJlbmNvZGluZ19lcnJvciIsInBvbGljeV92aW9sYXRpb24iLCJ0b29fbGFyZ2UiLCJleHRlbnNpb25fZXJyb3IiLCJ1bmV4cGVjdGVkX2NvbmRpdGlvbiIsIkVSUk9SX0NPREVTIiwiREVGQVVMVF9FUlJPUl9DT0RFIiwiTUlOX1JFU0VSVkVEX0VSUk9SIiwiTUFYX1JFU0VSVkVEX0VSUk9SIiwiVVRGOF9NQVRDSCIsImFkZCIsInB1dCIsInJlYWQiLCJfcGFyc2VPcGNvZGUiLCJfcGFyc2VMZW5ndGgiLCJfZnJhbWUiLCJsZW5ndGhCeXRlcyIsIl9wYXJzZUV4dGVuZGVkTGVuZ3RoIiwibWFza2luZ0tleSIsIl9lbWl0RnJhbWUiLCJpc1RleHQiLCJjb3B5IiwicnN2MSIsInJzdjIiLCJyc3YzIiwib3Bjb2RlIiwid3JpdGVVSW50MTZCRSIsIm9uTWVzc2FnZVJlYWR5IiwiZmluYWwiLCJtYXNrZWQiLCJyYW5kb21CeXRlcyIsIl9zZW5kRnJhbWUiLCJwcm9jZXNzT3V0Z29pbmdNZXNzYWdlIiwiaGVhZGVyIiwid3JpdGVVSW50MzJCRSIsIk1hdGgiLCJmbG9vciIsInNlY0tleSIsImdlbmVyYXRlUmVzcG9uc2UiLCJfc2h1dGRvd24iLCJfbWVzc2FnZSIsInNlbmRDbG9zZUZyYW1lIiwib2N0ZXQiLCJyc3ZzIiwicnN2IiwidmFsaWRGcmFtZVJzdiIsIl9jaGVja0ZyYW1lTGVuZ3RoIiwiX3JlYWRVSW50IiwiY2FsbGJhY2tzIiwicHVzaEZyYW1lIiwiX2VtaXRNZXNzYWdlIiwicmVhZFVJbnQxNkJFIiwiX2VuY29kZSIsInByb2Nlc3NJbmNvbWluZ01lc3NhZ2UiLCJ0ZXN0IiwicmVhZFVJbnQzMkJFIiwiUmluZ0J1ZmZlciIsImJ1ZmZlclNpemUiLCJfYnVmZmVyU2l6ZSIsIl9idWZmZXIiLCJfcmluZ09mZnNldCIsIl9yaW5nU2l6ZSIsIl9oZWFkIiwiX3RhaWwiLCJleHBhbmRCdWZmZXIiLCJleHBhbmRSaW5nIiwicGVlayIsInNoaWZ0IiwiUGxlZGdlIiwiX2NhbGxiYWNrcyIsIlFVRVVFX1NJWkUiLCJhbGwiLCJsaXN0IiwicGxlZGdlIiwicGVuZGluZyIsImRvbmUiLCJ0aGVuIiwiRHJhZnQ3NSIsIm9yaWdpbiIsImVhY2hCeXRlIiwiX2JvZHkiLCJfc2VuZEhhbmRzaGFrZUJvZHkiLCJfcGFyc2VMZWFkaW5nQnl0ZSIsIl9sZW5ndGgiLCJfY2xvc2luZyIsIl9za2lwcGVkIiwib25vcGVuIiwib25tZXNzYWdlIiwib25lcnJvciIsIm9uY2xvc2UiLCJhZGRFdmVudExpc3RlbmVyIiwibGlzdGVuZXIiLCJ1c2VDYXB0dXJlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwidGFyZ2V0IiwiY3VycmVudFRhcmdldCIsImV2ZW50UGhhc2UiLCJJTlZBTElEX1VURjE2IiwiSU5WQUxJRF9VVEY4IiwiYXJyIiwicG9zIiwiY2hhcnMiLCJtaW4iLCJuMSIsIm4yIiwibjMiLCJXZWJTb2NrZXQiLCJzb2NrZXQiLCJjYXRjaHVwIiwibmV4dFRpY2siLCJFdmVudFNvdXJjZSIsIlVybCIsInNwYXduIiwiZnMiLCJYTUxIdHRwUmVxdWVzdCIsImh0dHBzIiwic2V0dGluZ3MiLCJkaXNhYmxlSGVhZGVyQ2hlY2siLCJkZWZhdWx0SGVhZGVycyIsImhlYWRlcnNDYXNlIiwiZm9yYmlkZGVuUmVxdWVzdEhlYWRlcnMiLCJmb3JiaWRkZW5SZXF1ZXN0TWV0aG9kcyIsInNlbmRGbGFnIiwiZXJyb3JGbGFnIiwibGlzdGVuZXJzIiwiVU5TRU5UIiwiT1BFTkVEIiwiSEVBREVSU19SRUNFSVZFRCIsIkxPQURJTkciLCJET05FIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVzcG9uc2VUZXh0IiwicmVzcG9uc2VYTUwiLCJzdGF0dXMiLCJzdGF0dXNUZXh0Iiwid2l0aENyZWRlbnRpYWxzIiwiaXNBbGxvd2VkSHR0cEhlYWRlciIsImlzQWxsb3dlZEh0dHBNZXRob2QiLCJvcGVuIiwiYXN5bmMiLCJ1c2VyIiwicGFzc3dvcmQiLCJhYm9ydCIsInNldFN0YXRlIiwic2V0RGlzYWJsZUhlYWRlckNoZWNrIiwic3RhdGUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwiY29uc29sZSIsIndhcm4iLCJnZXRSZXNwb25zZUhlYWRlciIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInN1YnN0ciIsImdldFJlcXVlc3RIZWFkZXIiLCJzc2wiLCJsb2NhbCIsImhvc3QiLCJob3N0bmFtZSIsInJlYWRGaWxlIiwiaGFuZGxlRXJyb3IiLCJyZWFkRmlsZVN5bmMiLCJwb3J0IiwidXJpIiwic2VhcmNoIiwiSG9zdCIsImF1dGhCdWYiLCJBdXRob3JpemF0aW9uIiwiaXNCdWZmZXIiLCJwYXRoIiwiYWdlbnQiLCJkb1JlcXVlc3QiLCJyZXNwb25zZUhhbmRsZXIiLCJyZXNwIiwibG9jYXRpb24iLCJuZXdPcHRpb25zIiwiZXJyb3JIYW5kbGVyIiwic2V0RW5jb2RpbmciLCJjb250ZW50RmlsZSIsInBpZCIsInN5bmNGaWxlIiwid3JpdGVGaWxlU3luYyIsImV4ZWNTdHJpbmciLCJKU09OIiwic3RyaW5naWZ5Iiwic3luY1Byb2MiLCJhcmd2IiwiZXhpc3RzU3luYyIsInN0ZGluIiwidW5saW5rU3luYyIsImVyciIsInN0YWNrIiwiZXYiLCJsZW4iLCJuYWNsIiwiZ2YiLCJpbml0IiwiRmxvYXQ2NEFycmF5IiwicmFuZG9tYnl0ZXMiLCJfMCIsIl85IiwiZ2YwIiwiZ2YxIiwiXzEyMTY2NSIsIkQiLCJEMiIsIlgiLCJZIiwiSSIsInRzNjQiLCJ4IiwiaCIsInZuIiwieGkiLCJ5IiwieWkiLCJjcnlwdG9fdmVyaWZ5XzE2IiwiY3J5cHRvX3ZlcmlmeV8zMiIsImNvcmVfc2Fsc2EyMCIsImsiLCJqMCIsImoxIiwiajIiLCJqMyIsImo0IiwiajUiLCJqNiIsImo3IiwiajgiLCJqOSIsImoxMCIsImoxMSIsImoxMiIsImoxMyIsImoxNCIsImoxNSIsIngwIiwieDEiLCJ4MiIsIngzIiwieDQiLCJ4NSIsIng2IiwieDciLCJ4OCIsIng5IiwieDEwIiwieDExIiwieDEyIiwieDEzIiwieDE0IiwieDE1IiwidSIsImNvcmVfaHNhbHNhMjAiLCJjcnlwdG9fY29yZV9zYWxzYTIwIiwiaW5wIiwiY3J5cHRvX2NvcmVfaHNhbHNhMjAiLCJzaWdtYSIsImNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IiLCJjcG9zIiwibXBvcyIsInoiLCJjcnlwdG9fc3RyZWFtX3NhbHNhMjAiLCJjcnlwdG9fc3RyZWFtIiwic24iLCJjcnlwdG9fc3RyZWFtX3hvciIsInBvbHkxMzA1IiwiVWludDE2QXJyYXkiLCJwYWQiLCJsZWZ0b3ZlciIsImZpbiIsInQwIiwidDEiLCJ0MiIsInQzIiwidDQiLCJ0NSIsInQ2IiwidDciLCJibG9ja3MiLCJieXRlcyIsImhpYml0IiwiZDAiLCJkMSIsImQyIiwiZDMiLCJkNCIsImQ1IiwiZDYiLCJkNyIsImQ4IiwiZDkiLCJoMCIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImg3IiwiaDgiLCJoOSIsInIwIiwicjEiLCJyMiIsInIzIiwicjQiLCJyNSIsInI2IiwicjciLCJyOCIsInI5IiwiZmluaXNoIiwibWFjIiwibWFjcG9zIiwiZyIsImYiLCJ3YW50IiwiY3J5cHRvX29uZXRpbWVhdXRoIiwib3V0cG9zIiwiY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeSIsImhwb3MiLCJjcnlwdG9fc2VjcmV0Ym94IiwiY3J5cHRvX3NlY3JldGJveF9vcGVuIiwic2V0MjU1MTkiLCJhIiwiY2FyMjU1MTkiLCJ2Iiwic2VsMjU1MTkiLCJxIiwicGFjazI1NTE5IiwiaiIsIm5lcTI1NTE5IiwicGFyMjU1MTkiLCJ1bnBhY2syNTUxOSIsIkEiLCJaIiwiTSIsInQ4IiwidDkiLCJ0MTAiLCJ0MTEiLCJ0MTIiLCJ0MTMiLCJ0MTQiLCJ0MTUiLCJ0MTYiLCJ0MTciLCJ0MTgiLCJ0MTkiLCJ0MjAiLCJ0MjEiLCJ0MjIiLCJ0MjMiLCJ0MjQiLCJ0MjUiLCJ0MjYiLCJ0MjciLCJ0MjgiLCJ0MjkiLCJ0MzAiLCJiMCIsImIxIiwiYjIiLCJiMyIsImI0IiwiYjUiLCJiNiIsImI3IiwiYjgiLCJiOSIsImIxMCIsImIxMSIsImIxMiIsImIxMyIsImIxNCIsImIxNSIsIlMiLCJpbnYyNTUxOSIsInBvdzI1MjMiLCJjcnlwdG9fc2NhbGFybXVsdCIsIngzMiIsInN1YmFycmF5IiwieDE2IiwiY3J5cHRvX3NjYWxhcm11bHRfYmFzZSIsImNyeXB0b19ib3hfa2V5cGFpciIsImNyeXB0b19ib3hfYmVmb3Jlbm0iLCJjcnlwdG9fYm94X2FmdGVybm0iLCJjcnlwdG9fYm94X29wZW5fYWZ0ZXJubSIsImNyeXB0b19ib3giLCJjcnlwdG9fYm94X29wZW4iLCJLIiwiY3J5cHRvX2hhc2hibG9ja3NfaGwiLCJoaCIsImhsIiwid2giLCJJbnQzMkFycmF5Iiwid2wiLCJiaDAiLCJiaDEiLCJiaDIiLCJiaDMiLCJiaDQiLCJiaDUiLCJiaDYiLCJiaDciLCJibDAiLCJibDEiLCJibDIiLCJibDMiLCJibDQiLCJibDUiLCJibDYiLCJibDciLCJ0aCIsInRsIiwiYWgwIiwiYWgxIiwiYWgyIiwiYWgzIiwiYWg0IiwiYWg1IiwiYWg2IiwiYWg3IiwiYWwwIiwiYWwxIiwiYWwyIiwiYWwzIiwiYWw0IiwiYWw1IiwiYWw2IiwiYWw3IiwiY3J5cHRvX2hhc2giLCJjc3dhcCIsInBhY2siLCJ0eCIsInR5IiwiemkiLCJzY2FsYXJtdWx0Iiwic2NhbGFyYmFzZSIsImNyeXB0b19zaWduX2tleXBhaXIiLCJwayIsInNrIiwic2VlZGVkIiwiTCIsIm1vZEwiLCJjYXJyeSIsInJlZHVjZSIsImNyeXB0b19zaWduIiwic20iLCJzbWxlbiIsInVucGFja25lZyIsImNoayIsIm51bSIsImRlbiIsImRlbjIiLCJkZW40IiwiZGVuNiIsImNyeXB0b19zaWduX29wZW4iLCJjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTIiwiY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTIiwiY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMiLCJjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyIsImNyeXB0b19zY2FsYXJtdWx0X0JZVEVTIiwiY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMiLCJjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTIiwiY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyIsImNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyIsImNyeXB0b19ib3hfTk9OQ0VCWVRFUyIsImNyeXB0b19ib3hfWkVST0JZVEVTIiwiY3J5cHRvX2JveF9CT1haRVJPQllURVMiLCJjcnlwdG9fc2lnbl9CWVRFUyIsImNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTIiwiY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMiLCJjcnlwdG9fc2lnbl9TRUVEQllURVMiLCJjcnlwdG9faGFzaF9CWVRFUyIsImxvd2xldmVsIiwiY2hlY2tMZW5ndGhzIiwiY2hlY2tCb3hMZW5ndGhzIiwiY2hlY2tBcnJheVR5cGVzIiwiY2xlYW51cCIsInNlY3JldGJveCIsIm1zZyIsIm5vbmNlIiwiYm94Iiwia2V5TGVuZ3RoIiwibm9uY2VMZW5ndGgiLCJvdmVyaGVhZExlbmd0aCIsInNjYWxhck11bHQiLCJiYXNlIiwic2NhbGFyTGVuZ3RoIiwiZ3JvdXBFbGVtZW50TGVuZ3RoIiwicHVibGljS2V5Iiwic2VjcmV0S2V5IiwiYmVmb3JlIiwiYWZ0ZXIiLCJrZXlQYWlyIiwiZnJvbVNlY3JldEtleSIsInB1YmxpY0tleUxlbmd0aCIsInNlY3JldEtleUxlbmd0aCIsInNoYXJlZEtleUxlbmd0aCIsInNpZ24iLCJzaWduZWRNc2ciLCJ0bXAiLCJtbGVuIiwiZGV0YWNoZWQiLCJzaWciLCJ2ZXJpZnkiLCJmcm9tU2VlZCIsInNlZWQiLCJzZWVkTGVuZ3RoIiwic2lnbmF0dXJlTGVuZ3RoIiwiaGFzaCIsImhhc2hMZW5ndGgiLCJzZXRQUk5HIiwiZm4iLCJtc0NyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsIlFVT1RBIiwiZGVmYXVsdCIsIl9wYXVzZWQiLCJTdHJlYW1SZWFkZXIiLCJfcXVldWVTaXplIiwiX29mZnNldCIsInF1ZXVlIiwicmVtYWluIiwiZmlyc3QiLCJidWZmZXJzIiwic3BsaWNlIiwiY29udGV4dCIsImluZGV4IiwiUHJveHkiLCJfdXJsIiwiX2tleSIsImdlbmVyYXRlS2V5IiwiX2FjY2VwdCIsIl9odHRwIiwiYXV0aCIsIlZBTElEX1BST1RPQ09MUyIsIl9wYXRobmFtZSIsInByb3h5IiwiX2hhbmRzaGFrZVJlcXVlc3QiLCJfdmFsaWRhdGVIYW5kc2hha2UiLCJnZW5lcmF0ZU9mZmVyIiwiYWNjZXB0IiwiYWN0aXZhdGUiLCJhc3NlcnQiLCJvayIsImluaXRpYWxpemUiLCJtYXhIZWFkZXJTaXplIiwiYXN5bmNfcmVzb3VyY2UiLCJ0cmFpbGVycyIsImxpbmUiLCJpc0NodW5rZWQiLCJoZWFkZXJTaXplIiwiYm9keV9ieXRlcyIsImlzVXNlckNhbGwiLCJoYWRFcnJvciIsImtPbkhlYWRlcnMiLCJrT25Cb2R5Iiwia09uTWVzc2FnZUNvbXBsZXRlIiwiY29tcGF0TW9kZTBfMTIiLCJtZXRob2RzIiwibWV0aG9kX2Nvbm5lY3QiLCJyZWluaXRpYWxpemUiLCJmcmVlIiwiX2NvbXBhdE1vZGUwXzExIiwiZ2V0QXN5bmNJZCIsImhlYWRlclN0YXRlIiwiUkVRVUVTVF9MSU5FIiwiUkVTUE9OU0VfTElORSIsIkhFQURFUiIsInN0YXRlRmluaXNoQWxsb3dlZCIsIkJPRFlfUkFXIiwidXNlckNhbGwiLCJjb25zdW1lIiwidW5jb25zdW1lIiwiZ2V0Q3VycmVudEJ1ZmZlciIsInJldCIsIm5leHRSZXF1ZXN0IiwiY29uc3VtZUxpbmUiLCJjaGFyQXQiLCJoZWFkZXJFeHAiLCJoZWFkZXJDb250aW51ZUV4cCIsInBhcnNlSGVhZGVyIiwicGFyc2VFcnJvckNvZGUiLCJleGVjIiwibWF0Y2hDb250aW51ZSIsInJlcXVlc3RFeHAiLCJ2ZXJzaW9uTWFqb3IiLCJ2ZXJzaW9uTWlub3IiLCJyZXNwb25zZUV4cCIsInN0YXR1c01lc3NhZ2UiLCJzaG91bGRLZWVwQWxpdmUiLCJoYXNDb250ZW50TGVuZ3RoIiwiY3VycmVudENvbnRlbnRMZW5ndGhWYWx1ZSIsImhhc1VwZ3JhZGVIZWFkZXIiLCJza2lwQm9keSIsIkJPRFlfQ0hVTktIRUFEIiwiQk9EWV9DSFVOSyIsIkJPRFlfQ0hVTktFTVBUWUxJTkUiLCJlcXVhbCIsIkJPRFlfQ0hVTktUUkFJTEVSUyIsIkJPRFlfU0laRUQiLCJ0byIsIlBhcnNlciIsIlBpcGVsaW5lIiwiX3JzdjEiLCJfcnN2MiIsIl9yc3YzIiwiX2J5TmFtZSIsIl9pbk9yZGVyIiwiX3Nlc3Npb25zIiwiX2luZGV4IiwiZXh0Iiwic2Vzc2lvbnMiLCJvZmZlciIsInNlc3Npb24iLCJjcmVhdGVDbGllbnRTZXNzaW9uIiwicmVjb3JkIiwib2ZmZXJzIiwib2ZmIiwic2VyaWFsaXplUGFyYW1zIiwicmVzcG9uc2VzIiwiZWFjaE9mZmVyIiwicGFyYW1zIiwicmVzZXJ2ZWQiLCJfcmVzZXJ2ZWQiLCJfcmVzZXJ2ZSIsIl9waXBlbGluZSIsImJ5TmFtZSIsImNyZWF0ZVNlcnZlclNlc3Npb24iLCJhbGxvd2VkIiwiVE9LRU4iLCJOT1RPS0VOIiwiUVVPVEVEIiwiUEFSQU0iLCJSZWdFeHAiLCJzb3VyY2UiLCJFWFQiLCJFWFRfTElTVCIsIk5VTUJFUiIsIk9mZmVycyIsIlN5bnRheEVycm9yIiwidmFsdWVzIiwicGFyYW0iLCJwYXJzZUZsb2F0IiwicHJpbnQiLCJ0b0FycmF5IiwiQ2VsbCIsIl9jZWxscyIsIl9zdG9wcGVkIiwiaW5jb21pbmciLCJvdXRnb2luZyIsIl9sb29wIiwiY2xvc2VkIiwiZGlyZWN0aW9uIiwic3RlcCIsImNlbGxzIiwiRnVuY3RvciIsInR1cGxlIiwiX2V4dCIsIl9zZXNzaW9uIiwiX2Z1bmN0b3JzIiwiZnVuY3RvciIsIl9leGVjIiwiX2Nsb3NlZCIsIl9kb0Nsb3NlIiwiZm91dCIsIl9tZXRob2QiLCJjYWxsZWQiLCJfc3RvcCIsIl9mbHVzaFF1ZXVlIiwiaGFuZGxlciIsIl9jaHVua3MiLCJQT1JUUyIsIl9jbGllbnQiLCJfb3JpZ2luIiwiX3N0YXRlIiwiaHJlZiIsIkRyYWZ0NzYiLCJFVkVOVFMiLCJfZGVsZWdhdGUiLCJhdXRob3JpemVkIiwic2VjdXJlIiwiZGV0ZXJtaW5lVXJsIiwic2NoZW1lIiwia2V5MSIsImtleTIiLCJudW1iZXJGcm9tS2V5Iiwic3BhY2VzSW5LZXkiLCJCT0RZX1NJWkUiLCJfc3RhcnRlZCIsIm51bWJlcjEiLCJzcGFjZXMxIiwibnVtYmVyMiIsInNwYWNlczIiLCJfa2V5VmFsdWVzIiwiX2hhbmRzaGFrZVNpZ25hdHVyZSIsIm1kNSIsInNpZ25hdHVyZSIsIm5ldCIsInRscyIsIkRFRkFVTFRfUE9SVFMiLCJTRUNVUkVfUFJPVE9DT0xTIiwiZW5kcG9pbnQiLCJvbkNvbm5lY3QiLCJfb25Db25uZWN0IiwibmV0T3B0aW9ucyIsIm9yaWdpblRMUyIsInNvY2tldFRMUyIsImNhIiwic2VydmVybmFtZSIsImNvbm5lY3QiLCJfY29uZmlndXJlUHJveHkiLCJ3b3JrZXIiLCJERUZBVUxUX1BJTkciLCJfcmV0cnkiLCJyZXRyeSIsIkRFRkFVTFRfUkVUUlkiLCJsYXN0RXZlbnRJZCIsImhhbmRzaGFrZSIsImlzRXZlbnRTb3VyY2UiLCJpZCIsIl9fd2VicGFja19leHBvcnRzX18iLCJwdXNoZXJfd2l0aF9lbmNyeXB0aW9uX1B1c2hlcldpdGhFbmNyeXB0aW9uIiwiYnRvYSIsInV0b2IiLCJiNjRjaGFycyIsImI2NHRhYiIsImJhc2U2NF9pIiwiY2JfdXRvYiIsImNjIiwiY2JfZW5jb2RlIiwiY2NjIiwicGFkbGVuIiwib3JkIiwiZ2xvYmFsIiwiVGltZXIiLCJkZWxheSIsInRpbWVyIiwiaXNSdW5uaW5nIiwiZW5zdXJlQWJvcnRlZCIsImFic3RyYWN0X3RpbWVyIiwidGltZXJzX2NsZWFyVGltZW91dCIsInRpbWVyc19jbGVhckludGVydmFsIiwidGltZXJzX09uZU9mZlRpbWVyIiwidGltZXJzX1BlcmlvZGljVGltZXIiLCJVdGlsIiwibm93IiwiRGF0ZSIsInZhbHVlT2YiLCJkZWZlciIsImJvdW5kQXJndW1lbnRzIiwiZXh0ZW5kIiwic291cmNlcyIsInNhZmVKU09OU3RyaW5naWZ5IiwiYXJyYXlJbmRleE9mIiwiYXJyYXkiLCJpdGVtIiwibmF0aXZlSW5kZXhPZiIsIm9iamVjdEFwcGx5Iiwia2V5cyIsIl8iLCJtYXBPYmplY3QiLCJmaWx0ZXJPYmplY3QiLCJCb29sZWFuIiwiZmxhdHRlbiIsImFueSIsImNvbGxlY3Rpb25zX2FsbCIsImVuY29kZVBhcmFtc09iamVjdCIsImVuY29kZVVSSUNvbXBvbmVudCIsImJ1aWxkUXVlcnlTdHJpbmciLCJxdWVyeSIsImRlY3ljbGVPYmplY3QiLCJvYmplY3RzIiwicGF0aHMiLCJkZXJleiIsIm51IiwiJHJlZiIsIkRlZmF1bHRzIiwiUFJPVE9DT0wiLCJ3c1BvcnQiLCJ3c3NQb3J0Iiwid3NQYXRoIiwiaHR0cEhvc3QiLCJodHRwUG9ydCIsImh0dHBzUG9ydCIsImh0dHBQYXRoIiwic3RhdHNfaG9zdCIsImF1dGhFbmRwb2ludCIsImF1dGhUcmFuc3BvcnQiLCJhY3Rpdml0eVRpbWVvdXQiLCJwb25nVGltZW91dCIsInVuYXZhaWxhYmxlVGltZW91dCIsInVzZXJBdXRoZW50aWNhdGlvbiIsInRyYW5zcG9ydCIsImNoYW5uZWxBdXRob3JpemF0aW9uIiwiY2RuX2h0dHAiLCJjZG5faHR0cHMiLCJkZXBlbmRlbmN5X3N1ZmZpeCIsImRlZmF1bHRzIiwiZ2V0R2VuZXJpY1VSTCIsImJhc2VTY2hlbWUiLCJ1c2VUTFMiLCJob3N0VExTIiwiaG9zdE5vblRMUyIsImdldEdlbmVyaWNQYXRoIiwicXVlcnlTdHJpbmciLCJ3cyIsImdldEluaXRpYWwiLCJzb2NranMiLCJnZXRQYXRoIiwiY2FsbGJhY2tfcmVnaXN0cnlfQ2FsbGJhY2tSZWdpc3RyeSIsInByZWZpeCIsInByZWZpeGVkRXZlbnROYW1lIiwicmVtb3ZlIiwibmFtZXMiLCJyZW1vdmVDYWxsYmFjayIsInJlbW92ZUFsbENhbGxiYWNrcyIsImJpbmRpbmciLCJkaXNwYXRjaGVyX0Rpc3BhdGNoZXIiLCJmYWlsVGhyb3VnaCIsImdsb2JhbF9jYWxsYmFja3MiLCJldmVudE5hbWUiLCJiaW5kX2dsb2JhbCIsInVuYmluZCIsInVuYmluZF9nbG9iYWwiLCJ1bmJpbmRfYWxsIiwibWV0YWRhdGEiLCJsb2dnZXJfTG9nZ2VyIiwiZ2xvYmFsTG9nIiwibG9nIiwiZGVidWciLCJnbG9iYWxMb2dXYXJuIiwiZ2xvYmFsTG9nRXJyb3IiLCJkZWZhdWx0TG9nZ2luZ0Z1bmN0aW9uIiwiY29yZV9wdXNoZXIiLCJsb2dUb0NvbnNvbGUiLCJsb2dnZXIiLCJ0cmFuc3BvcnRfY29ubmVjdGlvbl9UcmFuc3BvcnRDb25uZWN0aW9uIiwiaG9va3MiLCJwcmlvcml0eSIsIm5vZGVfcnVudGltZSIsInRyYW5zcG9ydENvbm5lY3Rpb25Jbml0aWFsaXplciIsInRpbWVsaW5lIiwiZ2VuZXJhdGVVbmlxdWVJRCIsImhhbmRsZXNBY3Rpdml0eUNoZWNrcyIsInN1cHBvcnRzUGluZyIsInVybHMiLCJnZXRTb2NrZXQiLCJvbkVycm9yIiwiY2hhbmdlU3RhdGUiLCJiaW5kTGlzdGVuZXJzIiwib25PcGVuIiwiYmVmb3JlT3BlbiIsImJ1aWxkVGltZWxpbmVNZXNzYWdlIiwib25DbG9zZSIsImNsb3NlRXZlbnQiLCJ3YXNDbGVhbiIsInVuYmluZExpc3RlbmVycyIsIm9uTWVzc2FnZSIsIm9uQWN0aXZpdHkiLCJvbmFjdGl2aXR5IiwiY2lkIiwidHJhbnNwb3J0X1RyYW5zcG9ydCIsImlzU3VwcG9ydGVkIiwiZW52aXJvbm1lbnQiLCJjcmVhdGVDb25uZWN0aW9uIiwiV1NUcmFuc3BvcnQiLCJpc0luaXRpYWxpemVkIiwiZ2V0V2ViU29ja2V0QVBJIiwiY3JlYXRlV2ViU29ja2V0IiwiaHR0cENvbmZpZ3VyYXRpb24iLCJzdHJlYW1pbmdDb25maWd1cmF0aW9uIiwiSFRUUEZhY3RvcnkiLCJjcmVhdGVTdHJlYW1pbmdTb2NrZXQiLCJwb2xsaW5nQ29uZmlndXJhdGlvbiIsImNyZWF0ZVBvbGxpbmdTb2NrZXQiLCJ4aHJDb25maWd1cmF0aW9uIiwiaXNYSFJTdXBwb3J0ZWQiLCJYSFJTdHJlYW1pbmdUcmFuc3BvcnQiLCJYSFJQb2xsaW5nVHJhbnNwb3J0IiwiVHJhbnNwb3J0cyIsInhocl9zdHJlYW1pbmciLCJ4aHJfcG9sbGluZyIsInRyYW5zcG9ydHMiLCJhc3Npc3RhbnRfdG9fdGhlX3RyYW5zcG9ydF9tYW5hZ2VyX0Fzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlciIsIm1hbmFnZXIiLCJtaW5QaW5nRGVsYXkiLCJtYXhQaW5nRGVsYXkiLCJwaW5nRGVsYXkiLCJvcGVuVGltZXN0YW1wIiwib25DbG9zZWQiLCJyZXBvcnREZWF0aCIsImxpZmVzcGFuIiwibWF4IiwiaXNBbGl2ZSIsIlByb3RvY29sIiwiZGVjb2RlTWVzc2FnZSIsIm1lc3NhZ2VFdmVudCIsIm1lc3NhZ2VEYXRhIiwicHVzaGVyRXZlbnREYXRhIiwicHVzaGVyRXZlbnQiLCJjaGFubmVsIiwidXNlcl9pZCIsImVuY29kZU1lc3NhZ2UiLCJwcm9jZXNzSGFuZHNoYWtlIiwiYWN0aXZpdHlfdGltZW91dCIsImFjdGlvbiIsInNvY2tldF9pZCIsImdldENsb3NlQWN0aW9uIiwiZ2V0Q2xvc2VFcnJvciIsImNvbm5lY3Rpb25fQ29ubmVjdGlvbiIsInNlbmRfZXZlbnQiLCJhY3Rpdml0eSIsImhhbmRsZUNsb3NlRXZlbnQiLCJoYW5kc2hha2VfSGFuZHNoYWtlIiwidGltZWxpbmVfc2VuZGVyX1RpbWVsaW5lU2VuZGVyIiwiaXNFbXB0eSIsIlRpbWVsaW5lVHJhbnNwb3J0IiwiZ2V0QWdlbnQiLCJCYWRFdmVudE5hbWUiLCJCYWRDaGFubmVsTmFtZSIsIlJlcXVlc3RUaW1lZE91dCIsIlRyYW5zcG9ydFByaW9yaXR5VG9vTG93IiwiVHJhbnNwb3J0Q2xvc2VkIiwiVW5zdXBwb3J0ZWRGZWF0dXJlIiwiVW5zdXBwb3J0ZWRUcmFuc3BvcnQiLCJVbnN1cHBvcnRlZFN0cmF0ZWd5IiwiSFRUUEF1dGhFcnJvciIsInVybFN0b3JlIiwiYmFzZVVybCIsImF1dGhlbnRpY2F0aW9uRW5kcG9pbnQiLCJhdXRob3JpemF0aW9uRW5kcG9pbnQiLCJqYXZhc2NyaXB0UXVpY2tTdGFydCIsInRyaWdnZXJpbmdDbGllbnRFdmVudHMiLCJlbmNyeXB0ZWRDaGFubmVsU3VwcG9ydCIsImZ1bGxVcmwiLCJidWlsZExvZ1N1ZmZpeCIsInVybFByZWZpeCIsInVybE9iaiIsInVybF9zdG9yZSIsImNoYW5uZWxfQ2hhbm5lbCIsInB1c2hlciIsInN1YnNjcmliZWQiLCJzdWJzY3JpcHRpb25QZW5kaW5nIiwic3Vic2NyaXB0aW9uQ2FuY2VsbGVkIiwiYXV0aG9yaXplIiwic29ja2V0SWQiLCJ0cmlnZ2VyIiwic3VmZml4IiwiZGlzY29ubmVjdCIsImhhbmRsZUV2ZW50IiwiaGFuZGxlU3Vic2NyaXB0aW9uU3VjY2VlZGVkRXZlbnQiLCJoYW5kbGVTdWJzY3JpcHRpb25Db3VudEV2ZW50IiwidW5zdWJzY3JpYmUiLCJzdWJzY3JpcHRpb25fY291bnQiLCJzdWJzY3JpcHRpb25Db3VudCIsInN1YnNjcmliZSIsImFzc2lnbiIsImNoYW5uZWxfZGF0YSIsImNhbmNlbFN1YnNjcmlwdGlvbiIsInJlaW5zdGF0ZVN1YnNjcmlwdGlvbiIsInByaXZhdGVfY2hhbm5lbF9Qcml2YXRlQ2hhbm5lbCIsImNvbmZpZyIsImNoYW5uZWxBdXRob3JpemVyIiwiY2hhbm5lbE5hbWUiLCJtZW1iZXJzX01lbWJlcnMiLCJyZXNldCIsIm1lbWJlcnMiLCJlYWNoIiwibWVtYmVyIiwic2V0TXlJRCIsIm15SUQiLCJvblN1YnNjcmlwdGlvbiIsInN1YnNjcmlwdGlvbkRhdGEiLCJwcmVzZW5jZSIsImNvdW50IiwibWUiLCJhZGRNZW1iZXIiLCJtZW1iZXJEYXRhIiwidXNlcl9pbmZvIiwicmVtb3ZlTWVtYmVyIiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsIm5leHQiLCJyZWplY3RlZCIsInByZXNlbmNlX2NoYW5uZWxfUHJlc2VuY2VDaGFubmVsIiwiYXV0aERhdGEiLCJjaGFubmVsRGF0YSIsInNpZ25pbkRvbmVQcm9taXNlIiwidXNlcl9kYXRhIiwiaGFuZGxlSW50ZXJuYWxFdmVudCIsImFkZGVkTWVtYmVyIiwicmVtb3ZlZE1lbWJlciIsInV0ZjgiLCJiYXNlNjQiLCJlbmNyeXB0ZWRfY2hhbm5lbF9FbmNyeXB0ZWRDaGFubmVsIiwic2hhcmVkU2VjcmV0IiwiaGFuZGxlRW5jcnlwdGVkRXZlbnQiLCJjaXBoZXJ0ZXh0IiwiY2lwaGVyVGV4dCIsImdldERhdGFUb0VtaXQiLCJyYXciLCJfYSIsImNvbm5lY3Rpb25fbWFuYWdlcl9Db25uZWN0aW9uTWFuYWdlciIsInVzaW5nVExTIiwiZXJyb3JDYWxsYmFja3MiLCJidWlsZEVycm9yQ2FsbGJhY2tzIiwiY29ubmVjdGlvbkNhbGxiYWNrcyIsImJ1aWxkQ29ubmVjdGlvbkNhbGxiYWNrcyIsImhhbmRzaGFrZUNhbGxiYWNrcyIsImJ1aWxkSGFuZHNoYWtlQ2FsbGJhY2tzIiwiTmV0d29yayIsImdldE5ldHdvcmsiLCJuZXRpbmZvIiwicmV0cnlJbiIsInNlbmRBY3Rpdml0eUNoZWNrIiwidXBkYXRlU3RyYXRlZ3kiLCJzd2l0Y2hDbHVzdGVyIiwicnVubmVyIiwic3RyYXRlZ3kiLCJ1cGRhdGVTdGF0ZSIsInN0YXJ0Q29ubmVjdGluZyIsInNldFVuYXZhaWxhYmxlVGltZXIiLCJkaXNjb25uZWN0SW50ZXJuYWxseSIsImlzVXNpbmdUTFMiLCJoYW5kc2hha2VFcnJvciIsImFib3J0Q29ubmVjdGluZyIsImNsZWFyUmV0cnlUaW1lciIsImNsZWFyVW5hdmFpbGFibGVUaW1lciIsImFiYW5kb25Db25uZWN0aW9uIiwiZ2V0U3RyYXRlZ3kiLCJyb3VuZCIsInJldHJ5VGltZXIiLCJ1bmF2YWlsYWJsZVRpbWVyIiwic3RvcEFjdGl2aXR5Q2hlY2siLCJhY3Rpdml0eVRpbWVyIiwicG9uZ190aW1lZF9vdXQiLCJyZXNldEFjdGl2aXR5Q2hlY2siLCJzaG91bGRSZXRyeSIsImNvbm5lY3RlZCIsIkluZmluaXR5Iiwic2V0Q29ubmVjdGlvbiIsIndpdGhFcnJvckVtaXR0ZWQiLCJ0bHNfb25seSIsInJlZnVzZWQiLCJiYWNrb2ZmIiwibmV3U3RhdGUiLCJwcmV2aW91c1N0YXRlIiwibmV3U3RhdGVEZXNjcmlwdGlvbiIsInByZXZpb3VzIiwiY2hhbm5lbHNfQ2hhbm5lbHMiLCJjaGFubmVscyIsImNyZWF0ZUNoYW5uZWwiLCJmaW5kIiwiZmFjdG9yeSIsImNyZWF0ZUVuY3J5cHRlZENoYW5uZWwiLCJlcnJNc2ciLCJjcmVhdGVQcml2YXRlQ2hhbm5lbCIsImNyZWF0ZVByZXNlbmNlQ2hhbm5lbCIsIkZhY3RvcnkiLCJjcmVhdGVDaGFubmVscyIsImNyZWF0ZUNvbm5lY3Rpb25NYW5hZ2VyIiwiY3JlYXRlVGltZWxpbmVTZW5kZXIiLCJjcmVhdGVIYW5kc2hha2UiLCJjcmVhdGVBc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXIiLCJ0cmFuc3BvcnRfbWFuYWdlcl9UcmFuc3BvcnRNYW5hZ2VyIiwibGl2ZXNMZWZ0IiwibGl2ZXMiLCJnZXRBc3Npc3RhbnQiLCJzZXF1ZW50aWFsX3N0cmF0ZWd5X1NlcXVlbnRpYWxTdHJhdGVneSIsInN0cmF0ZWdpZXMiLCJsb29wIiwiZmFpbEZhc3QiLCJ0aW1lb3V0IiwidGltZW91dExpbWl0IiwibWluUHJpb3JpdHkiLCJ0cnlOZXh0U3RyYXRlZ3kiLCJ0cnlTdHJhdGVneSIsImZvcmNlTWluUHJpb3JpdHkiLCJiZXN0X2Nvbm5lY3RlZF9ldmVyX3N0cmF0ZWd5X0Jlc3RDb25uZWN0ZWRFdmVyU3RyYXRlZ3kiLCJydW5uZXJzIiwiYWxsUnVubmVyc0ZhaWxlZCIsImNhbGxiYWNrQnVpbGRlciIsInJzIiwiYWJvcnRSdW5uZXIiLCJhYm9ydGVkIiwid2Vic29ja2V0X3ByaW9yaXRpemVkX2NhY2hlZF9zdHJhdGVneV9XZWJTb2NrZXRQcmlvcml0aXplZENhY2hlZFN0cmF0ZWd5IiwidHRsIiwiZmV0Y2hUcmFuc3BvcnRDYWNoZSIsImNhY2hlU2tpcENvdW50IiwidGltZXN0YW1wIiwiaW5jbHVkZXMiLCJjYWNoZWQiLCJsYXRlbmN5Iiwic3RhcnRUaW1lc3RhbXAiLCJwb3AiLCJjYiIsImZsdXNoVHJhbnNwb3J0Q2FjaGUiLCJzdG9yZVRyYW5zcG9ydENhY2hlIiwiZ2V0VHJhbnNwb3J0Q2FjaGVLZXkiLCJzdG9yYWdlIiwiZ2V0TG9jYWxTdG9yYWdlIiwic2VyaWFsaXplZENhY2hlIiwiZGVsYXllZF9zdHJhdGVneV9EZWxheWVkU3RyYXRlZ3kiLCJudW1iZXIiLCJJZlN0cmF0ZWd5IiwidHJ1ZUJyYW5jaCIsImZhbHNlQnJhbmNoIiwiYnJhbmNoIiwiRmlyc3RDb25uZWN0ZWRTdHJhdGVneSIsInRlc3RTdXBwb3J0c1N0cmF0ZWd5IiwiZ2V0RGVmYXVsdFN0cmF0ZWd5IiwiYmFzZU9wdGlvbnMiLCJkZWZpbmVUcmFuc3BvcnQiLCJkZWZpbmVkVHJhbnNwb3J0cyIsImRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5Iiwid3Nfb3B0aW9ucyIsIndzSG9zdCIsIndzc19vcHRpb25zIiwiaHR0cF9vcHRpb25zIiwidGltZW91dHMiLCJ3c19tYW5hZ2VyIiwic3RyZWFtaW5nX21hbmFnZXIiLCJ3c190cmFuc3BvcnQiLCJ3c3NfdHJhbnNwb3J0IiwieGhyX3N0cmVhbWluZ190cmFuc3BvcnQiLCJ4aHJfcG9sbGluZ190cmFuc3BvcnQiLCJ3c19sb29wIiwid3NzX2xvb3AiLCJzdHJlYW1pbmdfbG9vcCIsInBvbGxpbmdfbG9vcCIsImh0dHBfbG9vcCIsIndzU3RyYXRlZ3kiLCJkZWZhdWx0X3N0cmF0ZWd5IiwidHJhbnNwb3J0X2Nvbm5lY3Rpb25faW5pdGlhbGl6ZXIiLCJNQVhfQlVGRkVSX0xFTkdUSCIsImh0dHBfcmVxdWVzdF9IVFRQUmVxdWVzdCIsInBvc2l0aW9uIiwieGhyIiwiZ2V0UmVxdWVzdCIsInVubG9hZGVyIiwiYWRkVW5sb2FkTGlzdGVuZXIiLCJyZW1vdmVVbmxvYWRMaXN0ZW5lciIsImFib3J0UmVxdWVzdCIsIm9uQ2h1bmsiLCJhZHZhbmNlQnVmZmVyIiwiaXNCdWZmZXJUb29Mb25nIiwidW5yZWFkRGF0YSIsImVuZE9mTGluZVBvc2l0aW9uIiwiU3RhdGUiLCJhdXRvSW5jcmVtZW50IiwiaHR0cF9zb2NrZXRfSFRUUFNvY2tldCIsInJhbmRvbU51bWJlciIsInJhbmRvbVN0cmluZyIsImdldExvY2F0aW9uIiwib3BlblN0cmVhbSIsInNlbmRSYXciLCJzZW5kSGVhcnRiZWF0IiwiY3JlYXRlU29ja2V0UmVxdWVzdCIsImdldFVuaXF1ZVVSTCIsImdldFNlbmRVUkwiLCJyZWNvbm5lY3QiLCJjbG9zZVN0cmVhbSIsIm9uRXZlbnQiLCJvbkhlYXJ0YmVhdCIsInJlcGxhY2VIb3N0Iiwic3RyZWFtIiwiZ2V0UmVjZWl2ZVVSTCIsIm9uRmluaXNoZWQiLCJwYXJ0cyIsInNlcGFyYXRvciIsInVybFBhcnRzIiwicmFuZG9tSW50IiwiaHR0cF9zb2NrZXQiLCJodHRwX3N0cmVhbWluZ19zb2NrZXRfaG9va3MiLCJodHRwX3N0cmVhbWluZ19zb2NrZXQiLCJodHRwX3BvbGxpbmdfc29ja2V0X2hvb2tzIiwiaHR0cF9wb2xsaW5nX3NvY2tldCIsImh0dHBfeGhyX3JlcXVlc3RfaG9va3MiLCJDb25zdHJ1Y3RvciIsImdldFhIUkFQSSIsIm9ucHJvZ3Jlc3MiLCJodHRwX3hocl9yZXF1ZXN0IiwiSFRUUCIsImNyZWF0ZVNvY2tldCIsImNyZWF0ZVhIUiIsImNyZWF0ZVJlcXVlc3QiLCJodHRwX2h0dHAiLCJJc29tb3JwaGljIiwic2V0dXAiLCJQdXNoZXJDbGFzcyIsInJlYWR5IiwiZ2V0Q2xpZW50RmVhdHVyZXMiLCJnZXRQcm90b2NvbCIsInJ1bnRpbWUiLCJ3ZWJzb2NrZXQiLCJuZXRfaW5mb19OZXRJbmZvIiwiaXNPbmxpbmUiLCJuZXRfaW5mb19OZXR3b3JrIiwiQXV0aFJlcXVlc3RUeXBlIiwiYWpheCIsImF1dGhPcHRpb25zIiwiYXV0aFJlcXVlc3RUeXBlIiwiaGVhZGVyTmFtZSIsImhlYWRlcnNQcm92aWRlciIsImR5bmFtaWNIZWFkZXJzIiwicGFyc2VkIiwiVXNlckF1dGhlbnRpY2F0aW9uIiwiQ2hhbm5lbEF1dGhvcml6YXRpb24iLCJ4aHJfYXV0aCIsInNlbmRlciIsInhocl90aW1lbGluZV94aHIiLCJ4aHJfdGltZWxpbmUiLCJleHRlcm5hbF9jcnlwdG9fIiwicnVudGltZV9nZXREZWZhdWx0U3RyYXRlZ3kiLCJydW50aW1lX1RyYW5zcG9ydHMiLCJOb2RlSlMiLCJnZXRBdXRob3JpemVycyIsIlRpbWVsaW5lTGV2ZWwiLCJ0aW1lbGluZV9sZXZlbCIsInRpbWVsaW5lX1RpbWVsaW5lIiwiZXZlbnRzIiwic2VudCIsInVuaXF1ZUlEIiwibGV2ZWwiLCJsaW1pdCIsIkVSUk9SIiwiSU5GTyIsIkRFQlVHIiwic2VuZGZuIiwiYnVuZGxlIiwibGliIiwiY2x1c3RlciIsImZlYXR1cmVzIiwidHJhbnNwb3J0X3N0cmF0ZWd5X1RyYW5zcG9ydFN0cmF0ZWd5IiwiZmFpbEF0dGVtcHQiLCJvbkluaXRpYWxpemVkIiwic2VyaWFsaXplZFRyYW5zcG9ydCIsInN0cmF0ZWd5X2J1aWxkZXJfVHJhbnNwb3J0cyIsInN0cmF0ZWd5X2J1aWxkZXJfZGVmaW5lVHJhbnNwb3J0IiwidHJhbnNwb3J0Q2xhc3MiLCJlbmFibGVkIiwiZW5hYmxlZFRyYW5zcG9ydHMiLCJkaXNhYmxlZFRyYW5zcG9ydHMiLCJpZ25vcmVOdWxsT3JpZ2luIiwic3RyYXRlZ3lfYnVpbGRlcl9VbnN1cHBvcnRlZFN0cmF0ZWd5IiwiZGVmZXJyZWQiLCJjb21wb3NlQ2hhbm5lbFF1ZXJ5IiwicGFyYW1zUHJvdmlkZXIiLCJkeW5hbWljUGFyYW1zIiwiVXNlckF1dGhlbnRpY2F0b3IiLCJ1c2VyX2F1dGhlbnRpY2F0b3IiLCJjaGFubmVsX2F1dGhvcml6ZXJfY29tcG9zZUNoYW5uZWxRdWVyeSIsIkNoYW5uZWxBdXRob3JpemVyIiwiY2hhbm5lbF9hdXRob3JpemVyIiwiQ2hhbm5lbEF1dGhvcml6ZXJQcm94eSIsImNoYW5uZWxBdXRob3JpemVyR2VuZXJhdG9yIiwiZGVwcmVjYXRlZEF1dGhvcml6ZXJPcHRpb25zIiwiZ2V0Q29uZmlnIiwib3B0cyIsInN0YXRzSG9zdCIsImVuYWJsZVN0YXRzIiwiZ2V0RW5hYmxlU3RhdHNDb25maWciLCJnZXRIdHRwSG9zdCIsInNob3VsZFVzZVRMUyIsImdldFdlYnNvY2tldEhvc3QiLCJ1c2VyQXV0aGVudGljYXRvciIsImJ1aWxkVXNlckF1dGhlbnRpY2F0b3IiLCJidWlsZENoYW5uZWxBdXRob3JpemVyIiwidGltZWxpbmVQYXJhbXMiLCJnZXRXZWJzb2NrZXRIb3N0RnJvbUNsdXN0ZXIiLCJmb3JjZVRMUyIsImRpc2FibGVTdGF0cyIsImhhc0N1c3RvbUhhbmRsZXIiLCJidWlsZENoYW5uZWxBdXRoIiwiY3VzdG9tSGFuZGxlciIsImF1dGhvcml6ZXIiLCJ3YXRjaGxpc3RfV2F0Y2hsaXN0RmFjYWRlIiwiYmluZFdhdGNobGlzdEludGVybmFsRXZlbnQiLCJ3YXRjaGxpc3RFdmVudCIsImZsYXRQcm9taXNlIiwicHJvbWlzZSIsInJlcyIsInJlaiIsImZsYXRfcHJvbWlzZSIsInVzZXJfVXNlckZhY2FkZSIsInNpZ25pbl9yZXF1ZXN0ZWQiLCJzZXJ2ZXJUb1VzZXJDaGFubmVsIiwiX3NpZ25pbkRvbmVSZXNvbHZlIiwiX29uQXV0aG9yaXplIiwiX2NsZWFudXAiLCJfc2lnbmluIiwiX25ld1NpZ25pblByb21pc2VJZk5lZWRlZCIsIndhdGNobGlzdCIsIl9vblNpZ25pblN1Y2Nlc3MiLCJzaWduaW4iLCJfc3Vic2NyaWJlQ2hhbm5lbHMiLCJlbnN1cmVfc3Vic2NyaWJlZCIsInNldERvbmUiLCJjYXRjaCIsInB1c2hlcl9QdXNoZXIiLCJpc1JlYWR5IiwiaW5zdGFuY2VzIiwiYXBwX2tleSIsImNoZWNrQXBwS2V5IiwiZ2xvYmFsX2VtaXR0ZXIiLCJzZXNzaW9uSUQiLCJ0aW1lbGluZVNlbmRlciIsInN1YnNjcmliZUFsbCIsImludGVybmFsIiwiYXBwS2V5IiwiYWxsQ2hhbm5lbHMiLCJ0aW1lbGluZVNlbmRlclRpbWVyIiwiZXZlbnRfbmFtZSIsImNoYW5uZWxfbmFtZSIsIlJ1bnRpbWUiLCJTY3JpcHRSZWNlaXZlcnMiLCJEZXBlbmRlbmNpZXNSZWNlaXZlcnMiLCJhdXRoX2NhbGxiYWNrcyIsIm5hY2xfZmFzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pusher-js/dist/node/pusher.js\n");

/***/ })

};
;